## Focused Project Concatenation
This file includes only UI, interactivity, model, and core logic files.
Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
Current date: 2025-10-23 10:27:08
Table of Contents:
1. GraphEditorShared/Sources/GraphEditorShared/PhysicsEngine.swift
2. GraphEditorShared/Sources/GraphEditorShared/PositionUpdater.swift
3. GraphEditorShared/Sources/GraphEditorShared/Protocols.swift
4. GraphEditorShared/Sources/GraphEditorShared/Quadtree.swift
5. GraphEditorShared/Sources/GraphEditorShared/RepulsionCalculator.swift
6. GraphEditorShared/Sources/GraphEditorShared/ToggleNode.swift--------------------------------------------------
File: PhysicsEngine.swift
Path: GraphEditorShared/Sources/GraphEditorShared/PhysicsEngine.swift
Last modified: 2025-10-15 08:27:30

Contents:
//
//  PhysicsEngine.swift
//  GraphEditorShared
//
//  Created by handcart on 8/1/25.
//

import os
import SwiftUI
import Foundation
import CoreGraphics

@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public class PhysicsEngine {
    private static let logger = Logger.forCategory("physics")
    
    // NEW: Signposter for performance tracing
    #if DEBUG
    private static let signposter = OSSignposter(subsystem: "io.handcart.GraphEditor", category: "physics")
    #endif
    
    var simulationBounds: CGSize
    private var stepCount: Int = 0
    private let maxNodesForQuadtree = 200
    private let symmetricFactor: CGFloat = 0.5
    internal let repulsionCalculator: RepulsionCalculator
    private var dampingBoostSteps: Int = 0
    internal let attractionCalculator: AttractionCalculator
    internal let centeringCalculator: CenteringCalculator
    internal let positionUpdater: PositionUpdater
    public var useAsymmetricAttraction: Bool = false
    public var alpha: CGFloat = 1.0  // New: Cooling parameter
    
    public init(simulationBounds: CGSize) {
        self.simulationBounds = simulationBounds
        self.repulsionCalculator = RepulsionCalculator(maxNodesForQuadtree: 200, simulationBounds: simulationBounds)
        self.attractionCalculator = AttractionCalculator(symmetricFactor: self.symmetricFactor, useAsymmetric: useAsymmetricAttraction)
        self.centeringCalculator = CenteringCalculator(simulationBounds: simulationBounds)
        self.positionUpdater = PositionUpdater(simulationBounds: simulationBounds)
    }
    
    public func temporaryDampingBoost(steps: Int = 20) {
        dampingBoostSteps = steps
    }
     
    private var simulationSteps = 0
    
    public func resetSimulation() {
        simulationSteps = 0
        stepCount = 0
        alpha = 1.0  // New: Reset alpha
    }
    
    public var isPaused: Bool = false
    
    @discardableResult
    public func simulationStep(nodes: [any NodeProtocol], edges: [GraphEdge]) -> ([any NodeProtocol], Bool) {
        if isPaused || stepCount > Constants.Physics.maxSimulationSteps { return (nodes, false) }
        stepCount += 1
        
        #if DEBUG
        let stepState = Self.signposter.beginInterval("SimulationStep", "Step \(self.stepCount), Nodes: \(nodes.count), Edges: \(edges.count)")
        #endif
        
        let (forces, quadtree) = computeRepulsions(nodes: nodes)
        var updatedForces = applyAttractions(forces: forces, edges: edges, nodes: nodes)
        updatedForces = applyCentering(forces: updatedForces, nodes: nodes)
        updatedForces = scaleForcesByAlpha(forces: updatedForces)
        
        let (tempNodes, isActive) = updatePositions(nodes: nodes, forces: updatedForces, edges: edges, quadtree: quadtree)
        let updatedNodes = postProcessNodes(tempNodes: tempNodes, isActive: isActive)
        
        logVelocityIfNeeded(nodes: updatedNodes)
        
        #if DEBUG
        Self.signposter.endInterval("SimulationStep", stepState, "Active: \(isActive)")
        #endif
        
        return (updatedNodes, isActive)
    }
    
    private func computeRepulsions(nodes: [any NodeProtocol]) -> ([NodeID: CGPoint], Quadtree?) {
        #if DEBUG
        let repulsionState = Self.signposter.beginInterval("RepulsionCalculation")
        #endif
        let result = repulsionCalculator.computeRepulsions(nodes: nodes)
        #if DEBUG
        Self.signposter.endInterval("RepulsionCalculation", repulsionState)
        #endif
        return result
    }
    
    private func applyAttractions(forces: [NodeID: CGPoint], edges: [GraphEdge], nodes: [any NodeProtocol]) -> [NodeID: CGPoint] {
        #if DEBUG
        let attractionState = Self.signposter.beginInterval("AttractionCalculation")
        #endif
        let result = attractionCalculator.applyAttractions(forces: forces, edges: edges, nodes: nodes)
        #if DEBUG
        Self.signposter.endInterval("AttractionCalculation", attractionState)
        #endif
        return result
    }
    
    private func applyCentering(forces: [NodeID: CGPoint], nodes: [any NodeProtocol]) -> [NodeID: CGPoint] {
        #if DEBUG
        let centeringState = Self.signposter.beginInterval("CenteringCalculation")
        #endif
        let result = centeringCalculator.applyCentering(forces: forces, nodes: nodes)
        #if DEBUG
        Self.signposter.endInterval("CenteringCalculation", centeringState)
        #endif
        return result
    }
    
    private func scaleForcesByAlpha(forces: [NodeID: CGPoint]) -> [NodeID: CGPoint] {
        #if DEBUG
        let scalingState = Self.signposter.beginInterval("ForceScaling", "Alpha: \(self.alpha)")
        #endif
        var updatedForces = forces
        for id in updatedForces.keys {
            updatedForces[id]! *= alpha
        }
        #if DEBUG
        Self.signposter.endInterval("ForceScaling", scalingState)
        #endif
        return updatedForces
    }
    
    private func updatePositions(nodes: [any NodeProtocol], forces: [NodeID: CGPoint], edges: [GraphEdge], quadtree: Quadtree?) -> ([any NodeProtocol], Bool) {
        #if DEBUG
        let positionState = Self.signposter.beginInterval("PositionUpdate")
        #endif
        let result = positionUpdater.updatePositionsAndVelocities(nodes: nodes, forces: forces, edges: edges, quadtree: quadtree)
        #if DEBUG
        Self.signposter.endInterval("PositionUpdate", positionState)
        #endif
        return result
    }
    
    private func postProcessNodes(tempNodes: [any NodeProtocol], isActive: Bool) -> [any NodeProtocol] {
        let updatedNodes = tempNodes.map { node in
            var clamped = node
            if hypot(clamped.velocity.x, clamped.velocity.y) < 0.001 {
                clamped.velocity = .zero
            }
            return clamped
        }
        
        var resetNodes = isActive ? updatedNodes : updatedNodes.map { $0.with(position: $0.position, velocity: CGPoint.zero) }
        
        if dampingBoostSteps > 0 {
            #if DEBUG
            let dampingState = Self.signposter.beginInterval("DampingBoost", "Remaining steps: \(self.dampingBoostSteps)")
            #endif
            let extraDamping = Constants.Physics.damping * 1.2
            resetNodes = resetNodes.map { node in
                var boostedNode = node
                boostedNode.velocity *= extraDamping
                return boostedNode
            }
            dampingBoostSteps -= 1
            #if DEBUG
            Self.signposter.endInterval("DampingBoost", dampingState)
            #endif
        }
        
        return resetNodes
    }
    
    private func logVelocityIfNeeded(nodes: [any NodeProtocol]) {
        if stepCount % 10 == 0 {  // Reduced logging frequency
            let totalVel = nodes.reduce(0.0) { $0 + $1.velocity.magnitude }
            Self.logger.debugLog("Step \(stepCount): Total velocity = \(String(format: "%.2f", totalVel))")
            #if DEBUG
            Self.signposter.emitEvent("VelocityCheck", "Step \(self.stepCount): Total velocity = \(totalVel)")
            #endif
        }
    }
    
    // Add to PhysicsEngine class
    public func runSimulation(steps: Int, nodes: [any NodeProtocol], edges: [GraphEdge]) -> [any NodeProtocol] {
        #if DEBUG
        let runState = Self.signposter.beginInterval("RunSimulation", "Steps: \(steps), Nodes: \(nodes.count)")
        #endif
        var currentNodes = nodes
        for _ in 0..<steps {
            let (updatedNodes, isActive) = simulationStep(nodes: currentNodes, edges: edges)
            currentNodes = updatedNodes
            if !isActive { break }  // Early exit if stable
        }
        #if DEBUG
        Self.signposter.endInterval("RunSimulation", runState)
        #endif
        return currentNodes
    }
    
    public func boundingBox(nodes: [any NodeProtocol]) -> CGRect {
        #if DEBUG
        let state = Self.signposter.beginInterval("BoundingBoxCalculation", "Nodes: \(nodes.count)")
        defer { Self.signposter.endInterval("BoundingBoxCalculation", state) }
        #endif
        guard !nodes.isEmpty else { return .zero }
        var minX = nodes[0].position.x, minY = nodes[0].position.y
        var maxX = nodes[0].position.x, maxY = nodes[0].position.y
        for node in nodes {
            minX = min(minX, node.position.x - node.radius)
            minY = min(minY, node.position.y - node.radius)
            maxX = max(maxX, node.position.x + node.radius)
            maxY = max(maxY, node.position.y + node.radius)
        }
        return CGRect(x: minX, y: minY, width: maxX - minX, height: maxY - minY)
    }
    
    public func centerNodes(nodes: [any NodeProtocol], around center: CGPoint? = nil) -> [any NodeProtocol] {
        #if DEBUG
        let state = Self.signposter.beginInterval("CenterNodes", "Nodes: \(nodes.count)")
        defer { Self.signposter.endInterval("CenterNodes", state) }
        #endif
        guard !nodes.isEmpty else { return [] }
        let targetCenter = center ?? CGPoint(x: simulationBounds.width / 2, y: simulationBounds.height / 2)
        
        // Compute current centroid
        let totalX = nodes.reduce(0.0) { $0 + $1.position.x }
        let totalY = nodes.reduce(0.0) { $0 + $1.position.y }
        let centroid = CGPoint(x: totalX / CGFloat(nodes.count), y: totalY / CGFloat(nodes.count))
        
        // Create updated nodes with translation
        let deltaX = targetCenter.x - centroid.x
        let deltaY = targetCenter.y - centroid.y
        return nodes.map { node in
            let newPosition = CGPoint(x: node.position.x + deltaX, y: node.position.y + deltaY)
            return node.with(position: newPosition, velocity: node.velocity)
        }
    }
    
    public func queryNearby(position: CGPoint, radius: CGFloat, nodes: [any NodeProtocol]) -> [any NodeProtocol] {
        #if DEBUG
        let state = Self.signposter.beginInterval("QueryNearby", "Position: (\(position.x), \(position.y)), Radius: \(radius), Nodes: \(nodes.count)")
        defer { Self.signposter.endInterval("QueryNearby", state) }
        #endif
        guard !nodes.isEmpty else { return [] }
        let quadtree = repulsionCalculator.buildQuadtree(nodes: nodes)
        return quadtree.queryNearby(position: position, radius: radius)
    }
}
----------------------------------------------------------------------------------------------------
File: PositionUpdater.swift
Path: GraphEditorShared/Sources/GraphEditorShared/PositionUpdater.swift
Last modified: 2025-10-08 13:12:23

Contents:
//
//  PositionUpdater.swift
//  GraphEditorShared
//
//  Created by handcart on 8/12/25.
//

import Foundation
import CoreGraphics

struct PositionUpdater {
    let simulationBounds: CGSize

    private func clampedPositionAndBouncedVelocity(for tentativePosition: CGPoint, with tentativeVelocity: CGPoint) -> (CGPoint, CGPoint) {
        let oldPosition = tentativePosition
        var newPosition = tentativePosition
        newPosition.x = max(0, min(simulationBounds.width, newPosition.x))
        newPosition.y = max(0, min(simulationBounds.height, newPosition.y))
        var newVelocity = tentativeVelocity
        if newPosition.x != oldPosition.x {
            newVelocity.x = -newVelocity.x * 0.8
        }
        if newPosition.y != oldPosition.y {
            newVelocity.y = -newVelocity.y * 0.8
        }
        return (newPosition, newVelocity)
    }

    private func adjustPositionForCollisions(_ position: CGPoint, excluding nodeID: NodeID, using quadtree: Quadtree?, allNodes nodes: [any NodeProtocol]) -> CGPoint {
        let minDist: CGFloat = 35.0
        var newPosition = position
        if let quadTree = quadtree {
            let nearby = quadTree.queryNearby(position: newPosition, radius: minDist)
            for other in nearby where other.id != nodeID {
                let delta = newPosition - other.position
                let distance = hypot(delta.x, delta.y)
                if distance < minDist && distance > 0 {
                    newPosition += (delta / distance) * (minDist - distance) / 2
                }
            }
        } else {
            for other in nodes where other.id != nodeID {
                let delta = newPosition - other.position
                let distance = hypot(delta.x, delta.y)
                if distance < minDist && distance > 0 {
                    newPosition += (delta / distance) * (minDist - distance) / 2
                }
            }
        }
        return newPosition
    }

    private func buildParentMap(from edges: [GraphEdge]) -> [NodeID: [NodeID]] {
        var parentMap = [NodeID: [NodeID]]()
        for edge in edges {
            parentMap[edge.target, default: []].append(edge.from)
        }
        return parentMap
    }

    private func finalPositionAndVelocity(for nodeID: NodeID, tentative: (position: CGPoint, velocity: CGPoint), parentMap: [NodeID: [NodeID]], isExpandedMap: [NodeID: Bool], tentativeUpdates: [NodeID: (position: CGPoint, velocity: CGPoint)]) -> (CGPoint, CGPoint) {
        var newPosition = tentative.position
        var newVelocity = tentative.velocity
        if let parents = parentMap[nodeID], !parents.isEmpty {
            let collapsedParents = parents.filter { parentID in
                isExpandedMap[parentID] == false
            }
            if !collapsedParents.isEmpty {
                var avgPos = CGPoint.zero
                for parentID in collapsedParents {
                    avgPos += tentativeUpdates[parentID]!.position
                }
                avgPos /= CGFloat(collapsedParents.count)
                newPosition = avgPos
                newVelocity = .zero  // Override velocity for collapsed children
            }
        }
        return (newPosition, newVelocity)
    }

    func updatePositionsAndVelocities(nodes: [any NodeProtocol], forces: [NodeID: CGPoint], edges: [GraphEdge], quadtree: Quadtree?) -> ([any NodeProtocol], Bool) {
        let timeStep: CGFloat = Constants.Physics.timeStep  // Updated: Use constant
        var tentativeUpdates: [NodeID: (position: CGPoint, velocity: CGPoint)] = [:]
        var isActive = false

        for node in nodes {
            let force = forces[node.id] ?? .zero
            var newVelocity = node.velocity + force / node.mass * timeStep
            var newPosition = node.position + newVelocity * timeStep

            newVelocity *= Constants.Physics.damping  // Apply global damping

            let (clampedPosition, bouncedVelocity) = clampedPositionAndBouncedVelocity(for: newPosition, with: newVelocity)
            newPosition = clampedPosition
            newVelocity = bouncedVelocity

            newPosition = adjustPositionForCollisions(newPosition, excluding: node.id, using: quadtree, allNodes: nodes)

            if hypot(newVelocity.x, newVelocity.y) > 0.001 {
                isActive = true
            }

            tentativeUpdates[node.id] = (newPosition, newVelocity)
        }

        let parentMap = buildParentMap(from: edges)
        let isExpandedMap = nodes.reduce(into: [NodeID: Bool]()) { $0[$1.id] = $1.isExpanded }
        var updatedNodes: [any NodeProtocol] = []

        for node in nodes {
            let tentative = tentativeUpdates[node.id]!
            let (finalPosition, finalVelocity) = finalPositionAndVelocity(for: node.id, tentative: tentative, parentMap: parentMap, isExpandedMap: isExpandedMap, tentativeUpdates: tentativeUpdates)
            updatedNodes.append(node.with(position: finalPosition, velocity: finalVelocity))
        }

        return (updatedNodes, isActive)
    }
}
----------------------------------------------------------------------------------------------------
File: Protocols.swift
Path: GraphEditorShared/Sources/GraphEditorShared/Protocols.swift
Last modified: 2025-10-03 14:47:43

Contents:
//
//  Protocols.swift
//  GraphEditorShared
//
//  Created by handcart on 8/1/25.
//

// Sources/GraphEditorShared/Protocols.swift

import SwiftUI

@available(iOS 16.0, watchOS 6.0, *)
public struct ViewState: Codable {
    public var offset: CGPoint
    public var zoomScale: CGFloat
    public var selectedNodeID: UUID?
    public var selectedEdgeID: UUID?

    // Explicit initializer to fix "Extra arguments" error
    public init(offset: CGPoint, zoomScale: CGFloat, selectedNodeID: UUID? = nil, selectedEdgeID: UUID? = nil) {
        self.offset = offset
        self.zoomScale = zoomScale
        self.selectedNodeID = selectedNodeID
        self.selectedEdgeID = selectedEdgeID
    }

    // Custom Codable conformance to handle decoding/encoding
    enum CodingKeys: String, CodingKey {
        case offset
        case zoomScale
        case selectedNodeID
        case selectedEdgeID
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let offsetX = try container.decode(CGFloat.self, forKey: .offset)
        let offsetY = try container.decode(CGFloat.self, forKey: .offset)
        offset = CGPoint(x: offsetX, y: offsetY)  // Assuming offset is encoded as two values; adjust if encoded as dict/array
        zoomScale = try container.decode(CGFloat.self, forKey: .zoomScale)
        selectedNodeID = try container.decodeIfPresent(UUID.self, forKey: .selectedNodeID)
        selectedEdgeID = try container.decodeIfPresent(UUID.self, forKey: .selectedEdgeID)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(offset.x, forKey: .offset)  // Adjust encoding if needed
        try container.encode(offset.y, forKey: .offset)
        try container.encode(zoomScale, forKey: .zoomScale)
        try container.encodeIfPresent(selectedNodeID, forKey: .selectedNodeID)
        try container.encodeIfPresent(selectedEdgeID, forKey: .selectedEdgeID)
    }
}

@available(iOS 16.0, watchOS 6.0, *)
public protocol GraphStorage {
    /// Saves the graph nodes and edges, throwing on failure (e.g., encoding or writing errors).
    func save(nodes: [any NodeProtocol], edges: [GraphEdge]) async throws
    /// Loads the graph nodes and edges, throwing on failure (e.g., file not found or decoding errors).
    func load() async throws -> (nodes: [any NodeProtocol], edges: [GraphEdge])
    func clear() async throws  // Unchanged
    func saveViewState(_ viewState: ViewState) async throws
    func loadViewState() async throws -> ViewState?
    // Multi-graph methods (required to preserve functionality)
    func listGraphNames() async throws -> [String]
    func createNewGraph(name: String) async throws
    func save(nodes: [any NodeProtocol], edges: [GraphEdge], for name: String) async throws
    func load(for name: String) async throws -> (nodes: [any NodeProtocol], edges: [GraphEdge])
    func deleteGraph(name: String) async throws
    func saveViewState(_ viewState: ViewState, for name: String) throws
    func loadViewState(for name: String) throws -> ViewState?
}

@available(iOS 16.0, watchOS 6.0, *)
extension GraphStorage {
    func saveViewState(_ viewState: ViewState) throws {
        // Default: Do nothing (for storages that don't support view state)
    }
    
    func loadViewState() throws -> ViewState? {
        return nil  // Default: No state
    }
}
----------------------------------------------------------------------------------------------------
File: Quadtree.swift
Path: GraphEditorShared/Sources/GraphEditorShared/Quadtree.swift
Last modified: 2025-09-19 13:45:29

Contents:
//
//  Quadtree.swift
//  GraphEditorShared
//
//  Created by [original author]; updated for completeness and consistency.
//

import Foundation
import CoreGraphics

@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public class Quadtree {  // Public for consistency and test access
    let bounds: CGRect
    public var centerOfMass: CGPoint = .zero
    public var totalMass: CGFloat = 0
    public var children: [Quadtree]?
    var nodes: [any NodeProtocol] = []  // Existential array for protocol conformance
    
    public init(bounds: CGRect) {
        self.bounds = bounds
    }
    
    public func insert(_ node: any NodeProtocol, depth: Int = 0) {
        // Guard against invalid bounds or excessive depth
        guard bounds.width >= Constants.Physics.minQuadSize,
              bounds.height >= Constants.Physics.minQuadSize,
              depth <= Constants.Physics.maxQuadtreeDepth else {
            nodes.append(node)
            updateCenterOfMass(with: node)
            return
        }
        
        if let children = children {
            // Existing subdivided quad: Insert into appropriate child
            let quadrant = getQuadrant(for: node.position)
            children[quadrant].insert(node, depth: depth + 1)
            aggregateFromChildren()  // Update aggregates post-insert
        } else if !nodes.isEmpty {
            // Leaf with nodes: Subdivide and redistribute all (including new node)
            subdivide()
            guard let children = children else {
                // Failed to subdivide (too small); append to leaf
                nodes.append(node)
                updateCenterOfMass(with: node)
                return
            }
            // Redistribute existing nodes
            for existing in nodes {
                let quadrant = getQuadrant(for: existing.position)
                children[quadrant].insert(existing, depth: depth + 1)
            }
            nodes = []  // Clear leaf nodes after redistribution
            // Insert the new node
            let quadrant = getQuadrant(for: node.position)
            children[quadrant].insert(node, depth: depth + 1)
            aggregateFromChildren()
        } else {
            // Empty leaf: Simply append
            nodes.append(node)
            updateCenterOfMass(with: node)
        }
    }
    
    public func batchInsert(_ batchNodes: [any NodeProtocol], depth: Int = 0) {
        guard depth <= Constants.Physics.maxQuadtreeDepth,
              bounds.width >= Constants.Physics.minQuadSize,
              bounds.height >= Constants.Physics.minQuadSize else {
            appendBatchAndUpdateCOM(batchNodes)
            return
        }

        if let children {
            distribute(batchNodes, to: children, depth: depth + 1)
            aggregateFromChildren()
        } else {
            let allNodes = nodes + batchNodes
            if allNodes.isEmpty { return }
            if allNodes.count <= 1 {
                appendBatchAndUpdateCOM(batchNodes)
            } else {
                subdivide()
                if let children {
                    nodes = []
                    distribute(allNodes, to: children, depth: depth + 1)
                    aggregateFromChildren()
                } else {
                    appendBatchAndUpdateCOM(batchNodes)
                }
            }
        }
    }

    private func appendBatchAndUpdateCOM(_ batch: [any NodeProtocol]) {
        nodes.append(contentsOf: batch)
        for node in batch {
            updateCenterOfMass(with: node)
        }
    }

    private func distribute(_ nodesToDistribute: [any NodeProtocol], to children: [Quadtree], depth: Int) {
        var childBatches: [[any NodeProtocol]] = Array(repeating: [], count: 4)
        for node in nodesToDistribute {
            let quadrant = getQuadrant(for: node.position)
            childBatches[quadrant].append(node)
        }
        for index in 0..<4 where !childBatches[index].isEmpty {
            children[index].batchInsert(childBatches[index], depth: depth)
        }
    }
    
    private func aggregateFromChildren() {
        // Recompute totalMass and centerOfMass from children (bottom-up weighted average)
        centerOfMass = .zero
        totalMass = 0
        guard let children = children else { return }
        for child in children where child.totalMass > 0 {
            let newTotalMass = totalMass + child.totalMass
            centerOfMass = (centerOfMass * totalMass + child.centerOfMass * child.totalMass) / newTotalMass
            totalMass = newTotalMass
        }
    }
    
    private func subdivide() {
        let halfWidth = bounds.width / 2
        let halfHeight = bounds.height / 2
        guard halfWidth >= Constants.Physics.minQuadSize && halfHeight >= Constants.Physics.minQuadSize else {
            return  // Too small to subdivide
        }
        children = [
            Quadtree(bounds: CGRect(x: bounds.minX, y: bounds.minY, width: halfWidth, height: halfHeight)),      // SW
            Quadtree(bounds: CGRect(x: bounds.minX + halfWidth, y: bounds.minY, width: halfWidth, height: halfHeight)), // SE
            Quadtree(bounds: CGRect(x: bounds.minX, y: bounds.minY + halfHeight, width: halfWidth, height: halfHeight)), // NW
            Quadtree(bounds: CGRect(x: bounds.minX + halfWidth, y: bounds.minY + halfHeight, width: halfWidth, height: halfHeight)) // NE
        ]
    }
    
    private func getQuadrant(for point: CGPoint) -> Int {
        let midX = bounds.midX
        let midY = bounds.midY
        if point.x < midX {
            return point.y < midY ? 0 : 2  // 0: SW, 2: NW
        } else {
            return point.y < midY ? 1 : 3  // 1: SE, 3: NE
        }
    }
    
    private func updateCenterOfMass(with node: any NodeProtocol) {
        // Incremental update assuming unit mass per node (extend protocol if variable mass needed)
        let newTotalMass = totalMass + 1
        if newTotalMass > 0 {
            centerOfMass = (centerOfMass * totalMass + node.position) / newTotalMass
        }
        totalMass = newTotalMass
    }
    
    public func computeForce(on queryNode: any NodeProtocol, theta: CGFloat = 0.5) -> CGPoint {
        guard totalMass > 0 else { return .zero }
        
        if !nodes.isEmpty {
            // Leaf: Compute exact repulsion from each node
            var force: CGPoint = .zero
            for leafNode in nodes where leafNode.id != queryNode.id {
                force += repulsionForce(from: leafNode.position, target: queryNode.position)
            }
            return force
        }
        
        // Internal node: Use Barnes-Hut approximation
        let delta = centerOfMass - queryNode.position
        let dist = max(hypot(delta.x, delta.y), Constants.Physics.distanceEpsilon)  // Fixed: Use hypot instead of .magnitude
        if (bounds.width / dist) < theta || children == nil {
            return repulsionForce(from: centerOfMass, target: queryNode.position, mass: totalMass)
        } else {
            var force: CGPoint = .zero
            if let children = children {
                for child in children {
                    force += child.computeForce(on: queryNode, theta: theta)
                }
            }
            return force
        }
    }
    
    public func queryNearby(position: CGPoint, radius: CGFloat) -> [any NodeProtocol] {
        var results: [any NodeProtocol] = []
        func traverse(quadTree: Quadtree) {
            // Quick reject: Check if quad intersects query circle
            let closestX = max(quadTree.bounds.minX, min(position.x, quadTree.bounds.maxX))
            let closestY = max(quadTree.bounds.minY, min(position.y, quadTree.bounds.maxY))
            let distToQuad = hypot(closestX - position.x, closestY - position.y)
            let quadDiagonalHalf = hypot(quadTree.bounds.width / 2, quadTree.bounds.height / 2)
            if distToQuad > radius + quadDiagonalHalf { return }  // No intersection
            
            if let children = quadTree.children {
                // Traverse children
                for child in children {
                    traverse(quadTree: child)
                }
            } else {
                // Leaf: Check individual nodes
                for node in quadTree.nodes {
                    let delta = node.position - position
                    if hypot(delta.x, delta.y) < radius {
                        results.append(node)
                    }
                }
            }
        }
        traverse(quadTree: self)
        return results
    }
    
    private func repulsionForce(from: CGPoint, target: CGPoint, mass: CGFloat = 1) -> CGPoint {
        let deltaX = target.x - from.x
        let deltaY = target.y - from.y
        let distSquared = deltaX * deltaX + deltaY * deltaY
        let epsilonSquared = Constants.Physics.distanceEpsilon * Constants.Physics.distanceEpsilon
        if distSquared < epsilonSquared {
            // Jitter to avoid singularity
            return CGPoint(
                x: CGFloat.random(in: -0.01...0.01),
                y: CGFloat.random(in: -0.01...0.01)
            ) * Constants.Physics.repulsion * mass
        }
        let dist = sqrt(distSquared)
        let forceMagnitude = Constants.Physics.repulsion * mass / distSquared
        return CGPoint(x: (deltaX / dist) * forceMagnitude, y: (deltaY / dist) * forceMagnitude)
    }
}
----------------------------------------------------------------------------------------------------
File: RepulsionCalculator.swift
Path: GraphEditorShared/Sources/GraphEditorShared/RepulsionCalculator.swift
Last modified: 2025-09-15 10:22:34

Contents:
//
//  RepulsionCalculator.swift
//  GraphEditorShared
//
//  Created by handcart on 8/12/25.
//

import Foundation
import CoreGraphics

struct RepulsionCalculator {
    private let maxNodesForQuadtree: Int
    private let simulationBounds: CGSize

    init(maxNodesForQuadtree: Int, simulationBounds: CGSize) {
        self.maxNodesForQuadtree = maxNodesForQuadtree
        self.simulationBounds = simulationBounds
    }

    func computeRepulsions(nodes: [any NodeProtocol]) -> ([NodeID: CGPoint], Quadtree?) {
        var forces: [NodeID: CGPoint] = [:]
        let useQuadtree = nodes.count > maxNodesForQuadtree && simulationBounds.width >= Constants.Physics.minQuadSize && simulationBounds.height >= Constants.Physics.minQuadSize
        let quadtree: Quadtree? = useQuadtree ? buildQuadtree(nodes: nodes) : nil

        for node in nodes {
            var repulsion: CGPoint = .zero
            if let quadtree = quadtree {
                let dynamicTheta: CGFloat = nodes.count > 100 ? 1.5 : (nodes.count > 50 ? 1.2 : 0.8)
                repulsion = quadtreeRepulsion(for: node, quadtree: quadtree, theta: dynamicTheta)  // Updated call
            } else {
                for otherNode in nodes where otherNode.id != node.id {
                    repulsion += repulsionForce(repellerPosition: otherNode.position, queryPosition: node.position)
                }
            }
            forces[node.id] = (forces[node.id] ?? .zero) + repulsion
        }
        return (forces, quadtree)  // New: Return tuple
    }

    public func buildQuadtree(nodes: [any NodeProtocol]) -> Quadtree {
        let boundingBox = boundingBox(nodes: nodes)  // Calls local func
        let quadtree = Quadtree(bounds: boundingBox)
        for node in nodes {
            quadtree.insert(node)
        }
        return quadtree
    }

    private func repulsionForce(repellerPosition: CGPoint, queryPosition: CGPoint, mass: CGFloat = 1.0) -> CGPoint {
        let deltaX = queryPosition.x - repellerPosition.x
        let deltaY = queryPosition.y - repellerPosition.y
        let distanceSquared = max(deltaX * deltaX + deltaY * deltaY, Constants.Physics.distanceEpsilon)
        let distance = sqrt(distanceSquared)
        let forceMagnitude = Constants.Physics.repulsion * mass / distanceSquared
        return CGPoint(x: (deltaX / distance) * forceMagnitude, y: (deltaY / distance) * forceMagnitude)
    }
    
    private func quadtreeRepulsion(for node: any NodeProtocol, quadtree: Quadtree, theta: CGFloat) -> CGPoint {  // Added theta
        var force = CGPoint.zero
        func calculateRepulsion(quadTree: Quadtree) {
            if quadTree.children == nil {
                for other in quadTree.nodes where other.id != node.id {
                    force += repulsionForce(repellerPosition: other.position, queryPosition: node.position, mass: 1.0)
                }
                return
            }

            let deltaX = quadTree.centerOfMass.x - node.position.x
            let deltaY = quadTree.centerOfMass.y - node.position.y
            let distance = hypot(deltaX, deltaY)
            let width = quadTree.bounds.width

            if width / distance < theta && distance > 0 {  // Use theta
                let approxForce = repulsionForce(repellerPosition: quadTree.centerOfMass, queryPosition: node.position, mass: quadTree.totalMass)
                force += approxForce
            } else {
                if let children = quadTree.children {
                    calculateRepulsion(quadTree: children[0])
                    calculateRepulsion(quadTree: children[1])
                    calculateRepulsion(quadTree: children[2])
                    calculateRepulsion(quadTree: children[3])
                }
            }
        }

        calculateRepulsion(quadTree: quadtree)
        return force
    }

    // Added missing boundingBox func
    private func boundingBox(nodes: [any NodeProtocol]) -> CGRect {
        guard !nodes.isEmpty else { return .zero }
        var minX = nodes[0].position.x, minY = nodes[0].position.y
        var maxX = nodes[0].position.x, maxY = nodes[0].position.y
        for node in nodes {
            minX = min(minX, node.position.x - node.radius)
            minY = min(minY, node.position.y - node.radius)
            maxX = max(maxX, node.position.x + node.radius)
            maxY = max(maxY, node.position.y + node.radius)
        }
        return CGRect(x: minX, y: minY, width: maxX - minX, height: maxY - minY)
    }
}
----------------------------------------------------------------------------------------------------
File: ToggleNode.swift
Path: GraphEditorShared/Sources/GraphEditorShared/ToggleNode.swift
Last modified: 2025-10-21 08:07:24

Contents:
//
//  ToggleNode.swift
//  GraphEditorShared
//
//  Created by handcart on [date]; updated for completeness.
//

import SwiftUI
import Foundation

@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public struct ToggleNode: NodeProtocol, Equatable {
    public let id: NodeID
    public let label: Int
    public var position: CGPoint
    public var velocity: CGPoint = .zero
    public var radius: CGFloat = Constants.App.nodeModelRadius  // Use constant for consistency
    public var isExpanded: Bool = true
    public var contents: [NodeContent] = []  // NEW: Ordered list, default empty
    public var fillColor: Color { isExpanded ? .green : .red }

    public init(id: NodeID = NodeID(), label: Int, position: CGPoint, velocity: CGPoint = .zero, radius: CGFloat = Constants.App.nodeModelRadius, isExpanded: Bool = true, contents: [NodeContent] = []) {
        self.id = id
        self.label = label
        self.position = position
        self.velocity = velocity
        self.radius = radius
        self.isExpanded = isExpanded
        self.contents = contents
    }

    public func with(position: CGPoint, velocity: CGPoint) -> Self {
        ToggleNode(id: id, label: label, position: position, velocity: velocity, radius: radius, isExpanded: isExpanded, contents: contents)
    }

    public func with(position: CGPoint, velocity: CGPoint, contents: [NodeContent]) -> Self {
        ToggleNode(id: id, label: label, position: position, velocity: velocity, radius: radius, isExpanded: isExpanded, contents: contents)
    }

    public func handlingTap() -> Self {
        var updated = self
        updated.isExpanded.toggle()
        updated.velocity = .zero  // Reset to prevent immediate jumps
        return updated
    }
    
    public func shouldHideChildren() -> Bool {
        !isExpanded
    }
    
    @available(iOS 16.0, *)
    @available(watchOS 9.0, *)
    public func renderView(zoomScale: CGFloat, isSelected: Bool) -> AnyView {
        AnyView(Circle().fill(fillColor).frame(width: radius * 2 * zoomScale, height: radius * 2 * zoomScale))  // Simple default
    }

    @available(iOS 16.0, *)
    @available(watchOS 9.0, *)
    public func draw(in context: GraphicsContext, at position: CGPoint, zoomScale: CGFloat, isSelected: Bool) {
        let scaledRadius = radius * zoomScale
        let borderWidth: CGFloat = isSelected ? max(3.0, 4 * zoomScale) : 0
        let borderRadius = scaledRadius + borderWidth / 2

        // Draw border if selected
        if borderWidth > 0 {
            let borderPath = Path(ellipseIn: CGRect(x: position.x - borderRadius, y: position.y - borderRadius, width: 2 * borderRadius, height: 2 * borderRadius))
            context.stroke(borderPath, with: .color(.yellow), lineWidth: borderWidth)
        }

        // Draw node circle
        let innerPath = Path(ellipseIn: CGRect(x: position.x - scaledRadius, y: position.y - scaledRadius, width: 2 * scaledRadius, height: 2 * scaledRadius))
        context.fill(innerPath, with: .color(fillColor))

        // Draw +/- icon centered in node
        let iconText = isExpanded ? "-" : "+"
        let iconFontSize = max(8.0, 12.0 * zoomScale)
        let iconResolved = context.resolve(Text(iconText).foregroundColor(.white).font(.system(size: iconFontSize, weight: .bold)))
        context.draw(iconResolved, at: position, anchor: .center)

        // Draw label above node
        let labelFontSize = max(8.0, 12.0 * zoomScale)
        let labelResolved = context.resolve(Text("\(label)").foregroundColor(.white).font(.system(size: labelFontSize)))
        let labelPosition = CGPoint(x: position.x, y: position.y - (scaledRadius + 10 * zoomScale))
        context.draw(labelResolved, at: labelPosition, anchor: .center)

        // NEW: Draw contents list vertically below node
        if !contents.isEmpty && zoomScale > 0.5 {  // Only if zoomed
            var yOffset = scaledRadius + 5 * zoomScale  // Start below node
            let contentFontSize = max(6.0, 8.0 * zoomScale)
            let maxItems = 3  // Limit for watchOS
            for content in contents.prefix(maxItems) {
                let contentText = Text(content.displayText).font(.system(size: contentFontSize)).foregroundColor(.gray)
                let resolved = context.resolve(contentText)
                let contentPosition = CGPoint(x: position.x, y: position.y + yOffset)
                context.draw(resolved, at: contentPosition, anchor: .center)
                yOffset += 10 * zoomScale  // Line spacing
            }
            if contents.count > maxItems {
                let moreText = Text("+\(contents.count - maxItems) more").font(.system(size: contentFontSize * 0.75)).foregroundColor(.gray)
                let resolved = context.resolve(moreText)
                context.draw(resolved, at: CGPoint(x: position.x, y: position.y + yOffset), anchor: .center)
            }
        }
    }

    // Codable conformance (updated for contents array)
    enum CodingKeys: String, CodingKey {
        case id, label, positionX, positionY, velocityX, velocityY, radius, isExpanded, contents  // Updated key
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(NodeID.self, forKey: .id)
        label = try container.decode(Int.self, forKey: .label)
        radius = try container.decode(CGFloat.self, forKey: .radius)
        isExpanded = try container.decode(Bool.self, forKey: .isExpanded)
        contents = try container.decode([NodeContent].self, forKey: .contents)  // NEW: Decode array
        let posX = try container.decode(CGFloat.self, forKey: .positionX)
        let posY = try container.decode(CGFloat.self, forKey: .positionY)
        position = CGPoint(x: posX, y: posY)
        let velX = try container.decode(CGFloat.self, forKey: .velocityX)
        let velY = try container.decode(CGFloat.self, forKey: .velocityY)
        velocity = CGPoint(x: velX, y: velY)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(label, forKey: .label)
        try container.encode(radius, forKey: .radius)
        try container.encode(isExpanded, forKey: .isExpanded)
        try container.encode(contents, forKey: .contents)  // NEW: Encode array
        try container.encode(position.x, forKey: .positionX)
        try container.encode(position.y, forKey: .positionY)
        try container.encode(velocity.x, forKey: .velocityX)
        try container.encode(velocity.y, forKey: .velocityY)
    }

    public static func == (lhs: ToggleNode, rhs: ToggleNode) -> Bool {
        lhs.id == rhs.id &&
        lhs.label == rhs.label &&
        lhs.position == rhs.position &&
        lhs.velocity == rhs.velocity &&
        lhs.radius == rhs.radius &&
        lhs.isExpanded == rhs.isExpanded &&
        lhs.contents == rhs.contents  // Updated for array
    }
}
--------------------------------------------------
