## Focused Project Concatenation
This file includes only UI, interactivity, model, and core logic files.
Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
Current date: 2025-11-08 13:41:16
Table of Contents:
1. GraphEditorShared/Sources/GraphEditorShared/NodeProtocol.swift
2. GraphEditorShared/Sources/GraphEditorShared/PersistenceManager.swift
3. GraphEditorShared/Sources/GraphEditorShared/PhysicsEngine.swift
4. GraphEditorShared/Sources/GraphEditorShared/PositionUpdater.swift
5. GraphEditorShared/Sources/GraphEditorShared/Protocols.swift--------------------------------------------------
File: NodeProtocol.swift
Path: GraphEditorShared/Sources/GraphEditorShared/NodeProtocol.swift
Last modified: 2025-10-29 08:26:21

Contents:
// Sources/GraphEditorShared/NodeProtocol.swift

import SwiftUI
import Foundation
import os

@available(iOS 15.0, *)
private var nodeTextCache: [String: GraphicsContext.ResolvedText] = [:]
private let maxCacheSize = 100  // Arbitrary limit; adjust based on testing
private let nodeCacheQueue = DispatchQueue(label: "nodeTextCache", attributes: .concurrent)
private var insertionOrder: [String] = []  // New: Track order

// NEW: Define NodeContent enum here (was missing; added with all primitives)
public enum NodeContent: Codable, Equatable {
    case string(String)
    case date(Date)
    case number(Double)
    case boolean(Bool)
    
    public var displayText: String {
        switch self {
        case .string(let value): return value.prefix(10) + (value.count > 10 ? "â€¦" : "")
        case .date(let value):
            let formatter = DateFormatter()
            formatter.dateStyle = .short
            formatter.timeStyle = .none
            formatter.timeZone = TimeZone(secondsFromGMT: 0)  // Force UTC for consistent output
            return formatter.string(from: value)
        case .number(let value): return String(format: "%.2f", value)  // Format to 2 decimal places
        case .boolean(let value): return value ? "True" : "False"
        }
    }
    
    private enum CodingKeys: String, CodingKey {
        case type, value
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(String.self, forKey: .type)
        switch type {
        case "string":
            let value = try container.decode(String.self, forKey: .value)
            self = .string(value)
        case "date":
            let value = try container.decode(Date.self, forKey: .value)
            self = .date(value)
        case "number":
            let value = try container.decode(Double.self, forKey: .value)
            self = .number(value)
        case "boolean":
            let value = try container.decode(Bool.self, forKey: .value)
            self = .boolean(value)
        default:
            throw DecodingError.dataCorruptedError(forKey: .type, in: container, debugDescription: "Unknown NodeContent type")
        }
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
        case .string(let value):
            try container.encode("string", forKey: .type)
            try container.encode(value, forKey: .value)
        case .date(let value):
            try container.encode("date", forKey: .type)
            try container.encode(value, forKey: .value)
        case .number(let value):
            try container.encode("number", forKey: .type)
            try container.encode(value, forKey: .value)
        case .boolean(let value):
            try container.encode("boolean", forKey: .type)
            try container.encode(value, forKey: .value)
        }
    }
}

/// Protocol for graph nodes, enabling polymorphism for types like standard or toggleable nodes.
/// Conformers must provide core properties; defaults are available for common behaviors.
@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public protocol NodeProtocol: Identifiable, Equatable, Codable where ID == NodeID {
    
    /// Unique identifier for the node.
    var id: NodeID { get }
    
    /// Permanent label for the node (e.g., for display and accessibility).
    var label: Int { get }
    
    /// Current position in the graph canvas.
    var position: CGPoint { get set }
    
    /// Velocity vector for physics simulation.
    var velocity: CGPoint { get set }
    
    /// Radius for rendering and hit detection.
    var radius: CGFloat { get set }
    
    /// Expansion state for hierarchical nodes (e.g., true shows children).
    var isExpanded: Bool { get set }
    
    var children: [UUID] { get set }
    mutating func collapse()
    mutating func bulkCollapse()
    
    // Data payload for the node
    // Ordered list of data payloads for the node (replaces single optional content)
    var contents: [NodeContent] { get set }
    
    /// Mass for physics calculations (default: 1.0).
    var mass: CGFloat { get }
    
    /// Creates a copy with updated position and velocity.
    func with(position: CGPoint, velocity: CGPoint) -> Self
    
    /// Creates a copy with updated position, velocity, and optional new contents list.
    func with(position: CGPoint, velocity: CGPoint, contents: [NodeContent]) -> Self
    
    /// Renders the node as a SwiftUI view, customizable by zoom and selection.
    /// - Parameters:
    ///   - zoomScale: Current zoom level of the canvas.
    ///   - isSelected: Whether the node is selected (e.g., for border highlight).
    /// - Returns: A SwiftUI view representing the node.
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    func renderView(zoomScale: CGFloat, isSelected: Bool) -> AnyView
    
    /// Handles tap gestures, returning a mutated copy (immutable pattern).
    /// - Returns: Updated node after tap (e.g., toggled state).
    func handlingTap() -> Self
    
    /// Indicates if the node is visible in the graph.
    var isVisible: Bool { get }
    
    /// Configurable fill color for the node's roundel.
    var fillColor: Color { get }
    
    /// Determines if child nodes (via outgoing edges) should be hidden.
    /// - Returns: True if children should be hidden (e.g., collapsed toggle).
    func shouldHideChildren() -> Bool
    
    /// Draws the node in a GraphicsContext for efficient Canvas rendering.
    /// - Parameters:
    ///   - context: The GraphicsContext to draw into.
    ///   - position: Center position for drawing.
    ///   - zoomScale: Current zoom level.
    ///   - isSelected: Whether to draw selection highlights.
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    func draw(in context: GraphicsContext, at position: CGPoint, zoomScale: CGFloat, isSelected: Bool)
}

extension NodeProtocol {
    public var isVisible: Bool { true }  // Default visible
    
    public var fillColor: Color { .blue }  // Default fill
    
    public var mass: CGFloat { 1.0 }  // Default mass
    
    public func shouldHideChildren() -> Bool { false }  // Default: show children
    
    public mutating func collapse() {
        isExpanded = false
    }

    public mutating func bulkCollapse() {
        collapse()  // Full recursion handled in GraphModel
    }
    
    public func handlingTap() -> Self { self }  // Default: no-op
    
    public func with(position: CGPoint, velocity: CGPoint) -> Self {
        var newSelf = self
        newSelf.position = position
        newSelf.velocity = velocity
        return newSelf
    }
    
    public func with(position: CGPoint, velocity: CGPoint, contents: [NodeContent]) -> Self {
        var newSelf = self
        newSelf.position = position
        newSelf.velocity = velocity
        newSelf.contents = contents
        return newSelf
    }
    
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    public func renderView(zoomScale: CGFloat, isSelected: Bool) -> AnyView {
        AnyView(Circle().fill(fillColor).frame(width: radius * 2 * zoomScale, height: radius * 2 * zoomScale))
    }
    
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    public func draw(in context: GraphicsContext, at position: CGPoint, zoomScale: CGFloat, isSelected: Bool) {
        let scaledRadius = radius * zoomScale
        let path = CGPath(ellipseIn: CGRect(x: position.x - scaledRadius, y: position.y - scaledRadius, width: scaledRadius * 2, height: scaledRadius * 2), transform: nil)
        context.fill(Path(path), with: .color(fillColor))
        context.stroke(Path(path), with: .color(isSelected ? Color.green : Color.white), lineWidth: 2 * zoomScale)
        
        let textKey = "\(label)_\(zoomScale)"
        var labelResolved: GraphicsContext.ResolvedText?
        nodeCacheQueue.sync {
            if let cached = nodeTextCache[textKey] {
                labelResolved = cached
            } else {
                let text = Text("\(label)").font(.system(size: 12 * zoomScale)).foregroundColor(.white)
                let resolved = context.resolve(text)
                nodeTextCache[textKey] = resolved
                insertionOrder.append(textKey)
                if nodeTextCache.count > maxCacheSize {
                    let oldestKey = insertionOrder.removeFirst()
                    nodeTextCache.removeValue(forKey: oldestKey)
                }
                labelResolved = resolved
            }
        }
        context.draw(labelResolved!, at: position, anchor: .center)
        
        // NEW: Draw contents list vertically below node
        if !contents.isEmpty && zoomScale > 0.5 {  // Only if zoomed
            var yOffset = scaledRadius + 5 * zoomScale  // Start below node
            let contentFontSize = max(6.0, 8.0 * zoomScale)
            let maxItems = 3  // Limit for watchOS
            for content in contents.prefix(maxItems) {
                let contentText = Text(content.displayText).font(.system(size: contentFontSize)).foregroundColor(.gray)
                let resolved = context.resolve(contentText)
                let contentPosition = CGPoint(x: position.x, y: position.y + yOffset)
                context.draw(resolved, at: contentPosition, anchor: .center)
                yOffset += 10 * zoomScale  // Line spacing
            }
            if contents.count > maxItems {
                let moreText = Text("+\(contents.count - maxItems) more").font(.system(size: contentFontSize * 0.75)).foregroundColor(.gray)
                let resolved = context.resolve(moreText)
                context.draw(resolved, at: CGPoint(x: position.x, y: position.y + yOffset), anchor: .center)
            }
        }
    }
}

@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public struct AnyNode: NodeProtocol {
    // NEW: Add the static logger here (moved from protocol)
    private static let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "nodeprotocol")
    
    private var base: any NodeProtocol  // var for mutability
    
    public var contents: [NodeContent] {
        get { base.contents }
        set { base.contents = newValue }
    }
    
    public var unwrapped: any NodeProtocol { base }
    
    public var id: NodeID { base.id }
    public var label: Int { base.label }
    public var position: CGPoint {
        get { base.position }
        set { base.position = newValue }
    }
    public var velocity: CGPoint {
        get { base.velocity }
        set { base.velocity = newValue }
    }
    public var radius: CGFloat {
        get { base.radius }
        set { base.radius = newValue }
    }
    public var isExpanded: Bool {
        get { base.isExpanded }
        set { base.isExpanded = newValue }
    }
    
    public var children: [UUID] {
        get { base.children }
        set { base.children = newValue }
    }

    public mutating func collapse() {
        base.collapse()
    }

    public mutating func bulkCollapse() {
        base.bulkCollapse()
    }
    
    public var isVisible: Bool { base.isVisible }
    public var fillColor: Color { base.fillColor }
    public var mass: CGFloat { base.mass }
    
    public init(_ base: any NodeProtocol) {
        self.base = base
    }
    
    public func with(position: CGPoint, velocity: CGPoint) -> Self {
        var newBase = base
        newBase.position = position
        newBase.velocity = velocity
        return AnyNode(newBase)
    }
    
    public func with(position: CGPoint, velocity: CGPoint, contents: [NodeContent]) -> Self {
        var newBase = base
        newBase.position = position
        newBase.velocity = velocity
        newBase.contents = contents
        return AnyNode(newBase)
    }
    
    public func handlingTap() -> Self {
        AnyNode(base.handlingTap())
    }
    
    public func shouldHideChildren() -> Bool {
        base.shouldHideChildren()
    }
    
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    public func renderView(zoomScale: CGFloat, isSelected: Bool) -> AnyView {
        base.renderView(zoomScale: zoomScale, isSelected: isSelected)
    }
    
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    public func draw(in context: GraphicsContext, at position: CGPoint, zoomScale: CGFloat, isSelected: Bool) {
#if DEBUG
        Self.logger.debug("Drawing node \(label) at (\(position.x), \(position.y)), isSelected: \(isSelected), zoom: \(zoomScale)")
#endif
        base.draw(in: context, at: position, zoomScale: zoomScale, isSelected: isSelected)
    }
    
    public static func == (lhs: AnyNode, rhs: AnyNode) -> Bool {
        lhs.id == rhs.id && lhs.position == rhs.position && lhs.velocity == rhs.velocity &&
        lhs.isExpanded == rhs.isExpanded && lhs.contents == rhs.contents  // Updated for array
    }
    
    public init(from decoder: Decoder) throws {
        let wrapper = try NodeWrapper(from: decoder)
        self.base = wrapper.value
    }
    
    public func encode(to encoder: Encoder) throws {
        let wrapper: NodeWrapper
        if let node = base as? Node {
            wrapper = .node(node)
        } else if let toggleNode = base as? ToggleNode {
            wrapper = .toggleNode(toggleNode)
        } else {
            throw EncodingError.invalidValue(base, EncodingError.Context(codingPath: [], debugDescription: "Unsupported node type"))
        }
        try wrapper.encode(to: encoder)
    }
}
----------------------------------------------------------------------------------------------------
File: PersistenceManager.swift
Path: GraphEditorShared/Sources/GraphEditorShared/PersistenceManager.swift
Last modified: 2025-10-25 20:18:35

Contents:
// Sources/GraphEditorShared/PersistenceManager.swift

import Foundation
import os  // For Logger

@available(iOS 16.0, watchOS 6.0, *)
private let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "storage")

/// Error types for graph storage operations.
public enum GraphStorageError: Error {
    case encodingFailed(Error)
    case writingFailed(Error)
    case loadingFailed(Error)
    case decodingFailed(Error)
    case inconsistentFiles(String)  // Retained for potential future multi-file use
    case graphExists(String)  // New: For createNewGraph duplicates
    case graphNotFound(String)  // New: For load/delete misses
}

/// File-based JSON persistence conforming to GraphStorage.
@available(iOS 16.0, watchOS 6.0, *)
public class PersistenceManager: GraphStorage {
    private let directory: URL
    private let defaultGraphName = "default"
    
    public init(directoryName: String = "graphs") {
        let documents = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        self.directory = documents.appendingPathComponent(directoryName)
        createDirectoryIfNeeded()
    }
    
    private func createDirectoryIfNeeded() {
        do {
            try FileManager.default.createDirectory(at: directory, withIntermediateDirectories: true)
        } catch {
            logger.error("Failed to create directory: \(error.localizedDescription)")
        }
    }
    
    private func fileURL(for name: String) -> URL {
        directory.appendingPathComponent("graph-\(name).json")
    }
    
    private func viewStateKey(for name: String) -> String {
        "graphViewState_\(name)"
    }
    
    struct SavedState: Codable {
        var version: Int = 1
        let nodes: [NodeWrapper]
        let edges: [GraphEdge]
    }
    
    // MARK: - Default (Single-Graph) Methods (Unchanged Behavior)
    
    public func save(nodes: [any NodeProtocol], edges: [GraphEdge]) async throws {
        try await save(nodes: nodes, edges: edges, for: defaultGraphName)
    }
    
    public func load() async throws -> (nodes: [any NodeProtocol], edges: [GraphEdge]) {
        try await load(for: defaultGraphName)
    }
    
    public func clear() async throws {
        try await deleteGraph(name: defaultGraphName)
    }
    
    public func saveViewState(_ viewState: ViewState) async throws {
        try saveViewState(viewState, for: defaultGraphName)
    }
    
    public func loadViewState() async throws -> ViewState? {
        try loadViewState(for: defaultGraphName)
    }
    
    // MARK: - Multi-Graph Methods
    
    public func listGraphNames() async throws -> [String] {
        do {
            let contents = try FileManager.default.contentsOfDirectory(at: directory, includingPropertiesForKeys: nil)
            let names = contents
                .filter { $0.lastPathComponent.hasPrefix("graph-") && $0.pathExtension == "json" }
                .map { String($0.deletingPathExtension().lastPathComponent.dropFirst(6)) }  // Drop "graph-"
                .sorted()
            logger.debug("Listed \(names.count) graphs: \(names)")
            return names
        } catch {
            logger.error("Listing failed: \(error.localizedDescription)")
            throw GraphStorageError.loadingFailed(error)
        }
    }
    
    public func createNewGraph(name: String) async throws {
        let url = fileURL(for: name)
        if FileManager.default.fileExists(atPath: url.path) {
            logger.warning("Graph '\(name)' already exists")
            throw GraphStorageError.graphExists(name)
        }
        // Create empty graph
        let emptyNodes: [any NodeProtocol] = []
        let emptyEdges: [GraphEdge] = []
        try await save(nodes: emptyNodes, edges: emptyEdges, for: name)
        logger.debug("Created new graph: \(name)")
    }
    
    public func save(nodes: [any NodeProtocol], edges: [GraphEdge], for name: String) async throws {
        let wrapped = nodes.compactMap { node -> NodeWrapper? in
            if let plainNode = node as? Node { return .node(plainNode) } else if let toggleNode = node as? ToggleNode { return .toggleNode(toggleNode) } else {
                logger.error("Unsupported node type: \(String(describing: type(of: node))); skipping.")
                return nil  // Skip instead of fatalError
            }
        }
        let state = SavedState(nodes: wrapped, edges: edges)
        do {
            let data = try JSONEncoder().encode(state)
            try data.write(to: fileURL(for: name), options: .atomic)  // Ensures full overwrite
            logger.debug("Saved \(wrapped.count) nodes and \(edges.count) edges for graph '\(name)'")
        } catch let error as EncodingError {
            logger.error("Encoding failed for '\(name)': \(error.localizedDescription)")
            throw GraphStorageError.encodingFailed(error)
        } catch {
            logger.error("Writing failed for '\(name)': \(error.localizedDescription)")
            throw GraphStorageError.writingFailed(error)
        }
    }
    
    public func load(for name: String) async throws -> (nodes: [any NodeProtocol], edges: [GraphEdge]) {
        let url = fileURL(for: name)
        guard FileManager.default.fileExists(atPath: url.path) else {
            logger.debug("No saved file for '\(name)'; throwing not found")
            throw GraphStorageError.graphNotFound(name)
        }
        do {
            let data = try Data(contentsOf: url)
            let state = try JSONDecoder().decode(SavedState.self, from: data)
            if state.version != 1 {
                throw GraphStorageError.decodingFailed(NSError(domain: "Invalid version \(state.version) for '\(name)'", code: 0))
            }
            let loadedNodes = state.nodes.map { $0.value }
            logger.debug("Loaded \(loadedNodes.count) nodes and \(state.edges.count) edges for graph '\(name)'")
            return (loadedNodes, state.edges)
        } catch let error as DecodingError {
            logger.error("Decoding failed for '\(name)': \(error.localizedDescription)")
            throw GraphStorageError.decodingFailed(error)
        } catch {
            logger.error("Loading failed for '\(name)': \(error.localizedDescription)")
            throw GraphStorageError.loadingFailed(error)
        }
    }
    
    public func deleteGraph(name: String) async throws {
        let url = fileURL(for: name)
        if FileManager.default.fileExists(atPath: url.path) {
            try FileManager.default.removeItem(at: url)
            // Also clear associated view state
            UserDefaults.standard.removeObject(forKey: viewStateKey(for: name))
            UserDefaults.standard.synchronize()
            logger.debug("Deleted graph '\(name)'")
        } else {
            logger.warning("Graph '\(name)' not found for deletion")
            throw GraphStorageError.graphNotFound(name)
        }
    }
    
    // MARK: - View State (Per-Graph)
    
    public func saveViewState(_ viewState: ViewState, for name: String) throws {
        let data = try JSONEncoder().encode(viewState)
        UserDefaults.standard.set(data, forKey: viewStateKey(for: name))
        UserDefaults.standard.synchronize()  // Ensure immediate write
        logger.debug("Saved view state for '\(name)'")
    }
    
    public func loadViewState(for name: String) throws -> ViewState? {
        guard let data = UserDefaults.standard.data(forKey: viewStateKey(for: name)) else {
            logger.debug("No view state for '\(name)'")
            return nil
        }
        let decoded = try JSONDecoder().decode(ViewState.self, from: data)
        logger.debug("Loaded view state for '\(name)'")
        return decoded
    }
}
----------------------------------------------------------------------------------------------------
File: PhysicsEngine.swift
Path: GraphEditorShared/Sources/GraphEditorShared/PhysicsEngine.swift
Last modified: 2025-10-25 09:07:26

Contents:
//
//  PhysicsEngine.swift
//  GraphEditorShared
//
//  Created by handcart on 8/1/25.
//

import os
import SwiftUI
import Foundation
import CoreGraphics

@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public class PhysicsEngine {
    private static let logger = Logger.forCategory("physics")
    
    // NEW: Signposter for performance tracing
    #if DEBUG
    private static let signposter = OSSignposter(subsystem: "io.handcart.GraphEditor", category: "physics")
    #endif
    
    var simulationBounds: CGSize
    private var stepCount: Int = 0
    private let maxNodesForQuadtree = 200
    private let symmetricFactor: CGFloat = 0.5
    internal let repulsionCalculator: RepulsionCalculator
    private var dampingBoostSteps: Int = 0
    internal let attractionCalculator: AttractionCalculator
    internal let centeringCalculator: CenteringCalculator
    internal let positionUpdater: PositionUpdater
    public var useAsymmetricAttraction: Bool = false
    public var alpha: CGFloat = 1.0  // New: Cooling parameter
    public var usePreferredAngles: Bool = false  // NEW: Toggle for angular forces (default off)
        
        public init(simulationBounds: CGSize) {
            self.simulationBounds = simulationBounds
            self.repulsionCalculator = RepulsionCalculator(maxNodesForQuadtree: 200, simulationBounds: simulationBounds)
            self.attractionCalculator = AttractionCalculator(symmetricFactor: self.symmetricFactor, useAsymmetric: useAsymmetricAttraction, usePreferredAngles: usePreferredAngles)  // UPDATED: Pass flag
            self.centeringCalculator = CenteringCalculator(simulationBounds: simulationBounds)
            self.positionUpdater = PositionUpdater(simulationBounds: simulationBounds)
        }
    
    public func temporaryDampingBoost(steps: Int = 20) {
        dampingBoostSteps = steps
    }
     
    private var simulationSteps = 0
    
    public func resetSimulation() {
        simulationSteps = 0
        stepCount = 0
        alpha = 1.0  // New: Reset alpha
    }
    
    public var isPaused: Bool = false
    
    @discardableResult
    public func simulationStep(nodes: [any NodeProtocol], edges: [GraphEdge]) -> ([any NodeProtocol], Bool) {
        if isPaused || stepCount > Constants.Physics.maxSimulationSteps { return (nodes, false) }
        stepCount += 1
        
        #if DEBUG
        let stepState = Self.signposter.beginInterval("SimulationStep", "Step \(self.stepCount), Nodes: \(nodes.count), Edges: \(edges.count)")
        #endif
        
        let (forces, quadtree) = computeRepulsions(nodes: nodes)
        var updatedForces = applyAttractions(forces: forces, edges: edges, nodes: nodes)
        updatedForces = applyCentering(forces: updatedForces, nodes: nodes)
        updatedForces = scaleForcesByAlpha(forces: updatedForces)
        
        let (tempNodes, isActive) = updatePositions(nodes: nodes, forces: updatedForces, edges: edges, quadtree: quadtree)
        let updatedNodes = postProcessNodes(tempNodes: tempNodes, isActive: isActive)
        
        logVelocityIfNeeded(nodes: updatedNodes)
        
        #if DEBUG
        Self.signposter.endInterval("SimulationStep", stepState, "Active: \(isActive)")
        #endif
        
        return (updatedNodes, isActive)
    }
    
    private func computeRepulsions(nodes: [any NodeProtocol]) -> ([NodeID: CGPoint], Quadtree?) {
        #if DEBUG
        let repulsionState = Self.signposter.beginInterval("RepulsionCalculation")
        #endif
        let result = repulsionCalculator.computeRepulsions(nodes: nodes)
        #if DEBUG
        Self.signposter.endInterval("RepulsionCalculation", repulsionState)
        #endif
        return result
    }
    
    private func applyAttractions(forces: [NodeID: CGPoint], edges: [GraphEdge], nodes: [any NodeProtocol]) -> [NodeID: CGPoint] {
        #if DEBUG
        let attractionState = Self.signposter.beginInterval("AttractionCalculation")
        #endif
        let result = attractionCalculator.applyAttractions(forces: forces, edges: edges, nodes: nodes)
        #if DEBUG
        Self.signposter.endInterval("AttractionCalculation", attractionState)
        #endif
        return result
    }
    
    private func applyCentering(forces: [NodeID: CGPoint], nodes: [any NodeProtocol]) -> [NodeID: CGPoint] {
        #if DEBUG
        let centeringState = Self.signposter.beginInterval("CenteringCalculation")
        #endif
        let result = centeringCalculator.applyCentering(forces: forces, nodes: nodes)
        #if DEBUG
        Self.signposter.endInterval("CenteringCalculation", centeringState)
        #endif
        return result
    }
    
    private func scaleForcesByAlpha(forces: [NodeID: CGPoint]) -> [NodeID: CGPoint] {
        #if DEBUG
        let scalingState = Self.signposter.beginInterval("ForceScaling", "Alpha: \(self.alpha)")
        #endif
        var updatedForces = forces
        for id in updatedForces.keys {
            updatedForces[id]! *= alpha
        }
        #if DEBUG
        Self.signposter.endInterval("ForceScaling", scalingState)
        #endif
        return updatedForces
    }
    
    private func updatePositions(nodes: [any NodeProtocol], forces: [NodeID: CGPoint], edges: [GraphEdge], quadtree: Quadtree?) -> ([any NodeProtocol], Bool) {
        #if DEBUG
        let positionState = Self.signposter.beginInterval("PositionUpdate")
        #endif
        let result = positionUpdater.updatePositionsAndVelocities(nodes: nodes, forces: forces, edges: edges, quadtree: quadtree)
        #if DEBUG
        Self.signposter.endInterval("PositionUpdate", positionState)
        #endif
        return result
    }
    
    private func postProcessNodes(tempNodes: [any NodeProtocol], isActive: Bool) -> [any NodeProtocol] {
        let updatedNodes = tempNodes.map { node in
            var clamped = node
            if hypot(clamped.velocity.x, clamped.velocity.y) < 0.001 {
                clamped.velocity = .zero
            }
            return clamped
        }
        
        var resetNodes = isActive ? updatedNodes : updatedNodes.map { $0.with(position: $0.position, velocity: CGPoint.zero) }
        
        if dampingBoostSteps > 0 {
            #if DEBUG
            let dampingState = Self.signposter.beginInterval("DampingBoost", "Remaining steps: \(self.dampingBoostSteps)")
            #endif
            let extraDamping = Constants.Physics.damping * 1.2
            resetNodes = resetNodes.map { node in
                var boostedNode = node
                boostedNode.velocity *= extraDamping
                return boostedNode
            }
            dampingBoostSteps -= 1
            #if DEBUG
            Self.signposter.endInterval("DampingBoost", dampingState)
            #endif
        }
        
        return resetNodes
    }
    
    private func logVelocityIfNeeded(nodes: [any NodeProtocol]) {
        if stepCount % 10 == 0 {  // Reduced logging frequency
            let totalVel = nodes.reduce(0.0) { $0 + $1.velocity.magnitude }
            Self.logger.debugLog("Step \(stepCount): Total velocity = \(String(format: "%.2f", totalVel))")
            #if DEBUG
            Self.signposter.emitEvent("VelocityCheck", "Step \(self.stepCount): Total velocity = \(totalVel)")
            #endif
        }
    }
    
    // Add to PhysicsEngine class
    public func runSimulation(steps: Int, nodes: [any NodeProtocol], edges: [GraphEdge]) -> [any NodeProtocol] {
        #if DEBUG
        let runState = Self.signposter.beginInterval("RunSimulation", "Steps: \(steps), Nodes: \(nodes.count)")
        #endif
        var currentNodes = nodes
        for _ in 0..<steps {
            let (updatedNodes, isActive) = simulationStep(nodes: currentNodes, edges: edges)
            currentNodes = updatedNodes
            if !isActive { break }  // Early exit if stable
        }
        #if DEBUG
        Self.signposter.endInterval("RunSimulation", runState)
        #endif
        return currentNodes
    }
    
    public func boundingBox(nodes: [any NodeProtocol]) -> CGRect {
        #if DEBUG
        let state = Self.signposter.beginInterval("BoundingBoxCalculation", "Nodes: \(nodes.count)")
        defer { Self.signposter.endInterval("BoundingBoxCalculation", state) }
        #endif
        guard !nodes.isEmpty else { return .zero }
        var minX = nodes[0].position.x, minY = nodes[0].position.y
        var maxX = nodes[0].position.x, maxY = nodes[0].position.y
        for node in nodes {
            minX = min(minX, node.position.x - node.radius)
            minY = min(minY, node.position.y - node.radius)
            maxX = max(maxX, node.position.x + node.radius)
            maxY = max(maxY, node.position.y + node.radius)
        }
        return CGRect(x: minX, y: minY, width: maxX - minX, height: maxY - minY)
    }
    
    public func centerNodes(nodes: [any NodeProtocol], around center: CGPoint? = nil) -> [any NodeProtocol] {
        #if DEBUG
        let state = Self.signposter.beginInterval("CenterNodes", "Nodes: \(nodes.count)")
        defer { Self.signposter.endInterval("CenterNodes", state) }
        #endif
        guard !nodes.isEmpty else { return [] }
        let targetCenter = center ?? CGPoint(x: simulationBounds.width / 2, y: simulationBounds.height / 2)
        
        // Compute current centroid
        let totalX = nodes.reduce(0.0) { $0 + $1.position.x }
        let totalY = nodes.reduce(0.0) { $0 + $1.position.y }
        let centroid = CGPoint(x: totalX / CGFloat(nodes.count), y: totalY / CGFloat(nodes.count))
        
        // Create updated nodes with translation
        let deltaX = targetCenter.x - centroid.x
        let deltaY = targetCenter.y - centroid.y
        return nodes.map { node in
            let newPosition = CGPoint(x: node.position.x + deltaX, y: node.position.y + deltaY)
            return node.with(position: newPosition, velocity: node.velocity)
        }
    }
    
    public func queryNearby(position: CGPoint, radius: CGFloat, nodes: [any NodeProtocol]) -> [any NodeProtocol] {
        #if DEBUG
        let state = Self.signposter.beginInterval("QueryNearby", "Position: (\(position.x), \(position.y)), Radius: \(radius), Nodes: \(nodes.count)")
        defer { Self.signposter.endInterval("QueryNearby", state) }
        #endif
        guard !nodes.isEmpty else { return [] }
        let quadtree = repulsionCalculator.buildQuadtree(nodes: nodes)
        return quadtree.queryNearby(position: position, radius: radius)
    }
}
----------------------------------------------------------------------------------------------------
File: PositionUpdater.swift
Path: GraphEditorShared/Sources/GraphEditorShared/PositionUpdater.swift
Last modified: 2025-10-08 13:12:23

Contents:
//
//  PositionUpdater.swift
//  GraphEditorShared
//
//  Created by handcart on 8/12/25.
//

import Foundation
import CoreGraphics

struct PositionUpdater {
    let simulationBounds: CGSize

    private func clampedPositionAndBouncedVelocity(for tentativePosition: CGPoint, with tentativeVelocity: CGPoint) -> (CGPoint, CGPoint) {
        let oldPosition = tentativePosition
        var newPosition = tentativePosition
        newPosition.x = max(0, min(simulationBounds.width, newPosition.x))
        newPosition.y = max(0, min(simulationBounds.height, newPosition.y))
        var newVelocity = tentativeVelocity
        if newPosition.x != oldPosition.x {
            newVelocity.x = -newVelocity.x * 0.8
        }
        if newPosition.y != oldPosition.y {
            newVelocity.y = -newVelocity.y * 0.8
        }
        return (newPosition, newVelocity)
    }

    private func adjustPositionForCollisions(_ position: CGPoint, excluding nodeID: NodeID, using quadtree: Quadtree?, allNodes nodes: [any NodeProtocol]) -> CGPoint {
        let minDist: CGFloat = 35.0
        var newPosition = position
        if let quadTree = quadtree {
            let nearby = quadTree.queryNearby(position: newPosition, radius: minDist)
            for other in nearby where other.id != nodeID {
                let delta = newPosition - other.position
                let distance = hypot(delta.x, delta.y)
                if distance < minDist && distance > 0 {
                    newPosition += (delta / distance) * (minDist - distance) / 2
                }
            }
        } else {
            for other in nodes where other.id != nodeID {
                let delta = newPosition - other.position
                let distance = hypot(delta.x, delta.y)
                if distance < minDist && distance > 0 {
                    newPosition += (delta / distance) * (minDist - distance) / 2
                }
            }
        }
        return newPosition
    }

    private func buildParentMap(from edges: [GraphEdge]) -> [NodeID: [NodeID]] {
        var parentMap = [NodeID: [NodeID]]()
        for edge in edges {
            parentMap[edge.target, default: []].append(edge.from)
        }
        return parentMap
    }

    private func finalPositionAndVelocity(for nodeID: NodeID, tentative: (position: CGPoint, velocity: CGPoint), parentMap: [NodeID: [NodeID]], isExpandedMap: [NodeID: Bool], tentativeUpdates: [NodeID: (position: CGPoint, velocity: CGPoint)]) -> (CGPoint, CGPoint) {
        var newPosition = tentative.position
        var newVelocity = tentative.velocity
        if let parents = parentMap[nodeID], !parents.isEmpty {
            let collapsedParents = parents.filter { parentID in
                isExpandedMap[parentID] == false
            }
            if !collapsedParents.isEmpty {
                var avgPos = CGPoint.zero
                for parentID in collapsedParents {
                    avgPos += tentativeUpdates[parentID]!.position
                }
                avgPos /= CGFloat(collapsedParents.count)
                newPosition = avgPos
                newVelocity = .zero  // Override velocity for collapsed children
            }
        }
        return (newPosition, newVelocity)
    }

    func updatePositionsAndVelocities(nodes: [any NodeProtocol], forces: [NodeID: CGPoint], edges: [GraphEdge], quadtree: Quadtree?) -> ([any NodeProtocol], Bool) {
        let timeStep: CGFloat = Constants.Physics.timeStep  // Updated: Use constant
        var tentativeUpdates: [NodeID: (position: CGPoint, velocity: CGPoint)] = [:]
        var isActive = false

        for node in nodes {
            let force = forces[node.id] ?? .zero
            var newVelocity = node.velocity + force / node.mass * timeStep
            var newPosition = node.position + newVelocity * timeStep

            newVelocity *= Constants.Physics.damping  // Apply global damping

            let (clampedPosition, bouncedVelocity) = clampedPositionAndBouncedVelocity(for: newPosition, with: newVelocity)
            newPosition = clampedPosition
            newVelocity = bouncedVelocity

            newPosition = adjustPositionForCollisions(newPosition, excluding: node.id, using: quadtree, allNodes: nodes)

            if hypot(newVelocity.x, newVelocity.y) > 0.001 {
                isActive = true
            }

            tentativeUpdates[node.id] = (newPosition, newVelocity)
        }

        let parentMap = buildParentMap(from: edges)
        let isExpandedMap = nodes.reduce(into: [NodeID: Bool]()) { $0[$1.id] = $1.isExpanded }
        var updatedNodes: [any NodeProtocol] = []

        for node in nodes {
            let tentative = tentativeUpdates[node.id]!
            let (finalPosition, finalVelocity) = finalPositionAndVelocity(for: node.id, tentative: tentative, parentMap: parentMap, isExpandedMap: isExpandedMap, tentativeUpdates: tentativeUpdates)
            updatedNodes.append(node.with(position: finalPosition, velocity: finalVelocity))
        }

        return (updatedNodes, isActive)
    }
}
----------------------------------------------------------------------------------------------------
File: Protocols.swift
Path: GraphEditorShared/Sources/GraphEditorShared/Protocols.swift
Last modified: 2025-10-03 14:47:43

Contents:
//
//  Protocols.swift
//  GraphEditorShared
//
//  Created by handcart on 8/1/25.
//

// Sources/GraphEditorShared/Protocols.swift

import SwiftUI

@available(iOS 16.0, watchOS 6.0, *)
public struct ViewState: Codable {
    public var offset: CGPoint
    public var zoomScale: CGFloat
    public var selectedNodeID: UUID?
    public var selectedEdgeID: UUID?

    // Explicit initializer to fix "Extra arguments" error
    public init(offset: CGPoint, zoomScale: CGFloat, selectedNodeID: UUID? = nil, selectedEdgeID: UUID? = nil) {
        self.offset = offset
        self.zoomScale = zoomScale
        self.selectedNodeID = selectedNodeID
        self.selectedEdgeID = selectedEdgeID
    }

    // Custom Codable conformance to handle decoding/encoding
    enum CodingKeys: String, CodingKey {
        case offset
        case zoomScale
        case selectedNodeID
        case selectedEdgeID
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let offsetX = try container.decode(CGFloat.self, forKey: .offset)
        let offsetY = try container.decode(CGFloat.self, forKey: .offset)
        offset = CGPoint(x: offsetX, y: offsetY)  // Assuming offset is encoded as two values; adjust if encoded as dict/array
        zoomScale = try container.decode(CGFloat.self, forKey: .zoomScale)
        selectedNodeID = try container.decodeIfPresent(UUID.self, forKey: .selectedNodeID)
        selectedEdgeID = try container.decodeIfPresent(UUID.self, forKey: .selectedEdgeID)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(offset.x, forKey: .offset)  // Adjust encoding if needed
        try container.encode(offset.y, forKey: .offset)
        try container.encode(zoomScale, forKey: .zoomScale)
        try container.encodeIfPresent(selectedNodeID, forKey: .selectedNodeID)
        try container.encodeIfPresent(selectedEdgeID, forKey: .selectedEdgeID)
    }
}

@available(iOS 16.0, watchOS 6.0, *)
public protocol GraphStorage {
    /// Saves the graph nodes and edges, throwing on failure (e.g., encoding or writing errors).
    func save(nodes: [any NodeProtocol], edges: [GraphEdge]) async throws
    /// Loads the graph nodes and edges, throwing on failure (e.g., file not found or decoding errors).
    func load() async throws -> (nodes: [any NodeProtocol], edges: [GraphEdge])
    func clear() async throws  // Unchanged
    func saveViewState(_ viewState: ViewState) async throws
    func loadViewState() async throws -> ViewState?
    // Multi-graph methods (required to preserve functionality)
    func listGraphNames() async throws -> [String]
    func createNewGraph(name: String) async throws
    func save(nodes: [any NodeProtocol], edges: [GraphEdge], for name: String) async throws
    func load(for name: String) async throws -> (nodes: [any NodeProtocol], edges: [GraphEdge])
    func deleteGraph(name: String) async throws
    func saveViewState(_ viewState: ViewState, for name: String) throws
    func loadViewState(for name: String) throws -> ViewState?
}

@available(iOS 16.0, watchOS 6.0, *)
extension GraphStorage {
    func saveViewState(_ viewState: ViewState) throws {
        // Default: Do nothing (for storages that don't support view state)
    }
    
    func loadViewState() throws -> ViewState? {
        return nil  // Default: No state
    }
}
--------------------------------------------------
