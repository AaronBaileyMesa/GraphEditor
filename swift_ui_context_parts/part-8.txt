## Focused Project Concatenation
This file includes only UI, interactivity, model, and core logic files.
Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
Current date: 2025-11-04 20:55:39
Table of Contents:
1. GraphEditorWatch/Views/GraphUtilities.swift
2. GraphEditorWatch/Views/InnerView.swift
3. GraphEditorWatch/Views/MenuButton.swift
4. GraphEditorWatch/Views/MenuView.swift
5. GraphEditorWatch/Views/NodeMenuView.swift
6. GraphEditorWatch/Views/NodeView.swift
7. GraphEditorWatch/Views/ToggleNodeMenuView.swift
8. GraphEditorWatch/Views/UnifiedDatePicker.swift
9. GraphEditorWatch/Views/ViewSection.swift
10. GraphEditorWatchTests/AccessibilityTests.swift
11. GraphEditorWatchTests/CoordinateTransformerTests.swift
12. GraphEditorWatchTests/EditContentSheetTests.swift--------------------------------------------------
File: GraphUtilities.swift
Path: GraphEditorWatch/Views/GraphUtilities.swift
Last modified: 2025-10-15 15:26:26

Contents:
// GraphUtilities.swift
//  GraphEditor
//
//  Created by handcart on 9/19/25.
//
import SwiftUI
import GraphEditorShared
import CoreGraphics

struct ViewSizeKey: PreferenceKey {
    static var defaultValue: CGSize = .zero
    static func reduce(value: inout CGSize, nextValue: () -> CGSize) {
        value = nextValue()
    }
}

struct NodeWrapper: Equatable, Identifiable {
    let id: UUID?
    let node: (any NodeProtocol)?
    
    init(node: (any NodeProtocol)?) {
        self.node = node
        self.id = node?.id
    }
    
    static func == (lhs: NodeWrapper, rhs: NodeWrapper) -> Bool {
        lhs.id == rhs.id
    }
}

struct InnerViewConfig {
    let geo: GeometryProxy
    let viewModel: GraphViewModel
    let zoomScale: Binding<CGFloat>
    let offset: Binding<CGSize>
    let draggedNode: Binding<NodeWrapper>
    let dragOffset: Binding<CGPoint>
    let potentialEdgeTarget: Binding<NodeWrapper>
    let panStartOffset: Binding<CGSize?>
    let showMenu: Binding<Bool>
    let showOverlays: Binding<Bool>
    let maxZoom: CGFloat
    let crownPosition: Binding<Double>
    let updateZoomRangesHandler: (CGSize) -> Void
    let selectedNodeID: Binding<NodeID?>
    let selectedEdgeID: Binding<UUID?>
    let canvasFocus: FocusState<Bool>
    let onCenterGraph: () -> Void
    let isAddingEdge: Binding<Bool>
    let isSimulating: Binding<Bool>
    let saturation: Binding<Double>  // NEW: Add this binding
    
    init(
        geo: GeometryProxy,
        viewModel: GraphViewModel,
        zoomScale: Binding<CGFloat>,
        offset: Binding<CGSize>,
        draggedNode: Binding<NodeWrapper>,
        dragOffset: Binding<CGPoint>,
        potentialEdgeTarget: Binding<NodeWrapper>,
        panStartOffset: Binding<CGSize?>,
        showMenu: Binding<Bool>,
        showOverlays: Binding<Bool>,
        maxZoom: CGFloat,
        crownPosition: Binding<Double>,
        updateZoomRangesHandler: @escaping (CGSize) -> Void,
        selectedNodeID: Binding<NodeID?>,
        selectedEdgeID: Binding<UUID?>,
        canvasFocus: FocusState<Bool>,
        onCenterGraph: @escaping () -> Void,
        isAddingEdge: Binding<Bool>,
        isSimulating: Binding<Bool>,
        saturation: Binding<Double>  // NEW: Add this param
    ) {
        self.geo = geo
        self.viewModel = viewModel
        self.zoomScale = zoomScale
        self.offset = offset
        self.draggedNode = draggedNode
        self.dragOffset = dragOffset
        self.potentialEdgeTarget = potentialEdgeTarget
        self.panStartOffset = panStartOffset
        self.showMenu = showMenu
        self.showOverlays = showOverlays
        self.maxZoom = maxZoom
        self.crownPosition = crownPosition
        self.updateZoomRangesHandler = updateZoomRangesHandler
        self.selectedNodeID = selectedNodeID
        self.selectedEdgeID = selectedEdgeID
        self.canvasFocus = canvasFocus
        self.onCenterGraph = onCenterGraph
        self.isAddingEdge = isAddingEdge
        self.isSimulating = isSimulating
        self.saturation = saturation  // NEW
    }
}
----------------------------------------------------------------------------------------------------
File: InnerView.swift
Path: GraphEditorWatch/Views/InnerView.swift
Last modified: 2025-10-15 15:26:26

Contents:
//
//  InnerView.swift
//  GraphEditor
//
//  Created by handcart on 9/19/25.
//

// InnerView.swift

import SwiftUI
import GraphEditorShared

struct InnerView: View {
    let config: InnerViewConfig  // This now references the one from GraphUtilities.swift
    
    var body: some View {
        let draggedNodeBinding = Binding<(any NodeProtocol)?>(
            get: { config.draggedNode.wrappedValue.node },
            set: { config.draggedNode.wrappedValue = NodeWrapper(node: $0) }
        )
        let potentialEdgeTargetBinding = Binding<(any NodeProtocol)?>(
            get: { config.potentialEdgeTarget.wrappedValue.node },
            set: { config.potentialEdgeTarget.wrappedValue = NodeWrapper(node: $0) }
        )
        
        let canvasView = GraphCanvasView(
            viewModel: config.viewModel,
            zoomScale: config.zoomScale,
            offset: config.offset,
            draggedNode: draggedNodeBinding,
            dragOffset: config.dragOffset,
            potentialEdgeTarget: potentialEdgeTargetBinding,
            selectedNodeID: config.selectedNodeID,
            viewSize: config.geo.size,
            panStartOffset: config.panStartOffset,
            showMenu: config.showMenu,
            maxZoom: config.maxZoom,
            crownPosition: config.crownPosition,
            onUpdateZoomRanges: { config.updateZoomRangesHandler(config.geo.size) },
            selectedEdgeID: config.selectedEdgeID,
            showOverlays: config.showOverlays,
            isAddingEdge: config.isAddingEdge,
            isSimulating: config.isSimulating,
            saturation: config.saturation  // NEW: Pass the binding here
        )
            .accessibilityIdentifier("GraphCanvas")
            .focused(config.canvasFocus.projectedValue)
            .focusable()
        canvasView
    }
}
----------------------------------------------------------------------------------------------------
File: MenuButton.swift
Path: GraphEditorWatch/Views/MenuButton.swift
Last modified: 2025-10-24 07:54:16

Contents:
//
//  MenuButton.swift
//  GraphEditorWatch
//
//  Created by handcart on 2025-10-23.
//

import SwiftUI
import WatchKit

struct MenuButton<LabelContent: View>: View {
    let action: () -> Void
    let label: () -> LabelContent
    let accessibilityIdentifier: String?
    let role: ButtonRole?
    
    init(
        action: @escaping () -> Void,
        @ViewBuilder label: @escaping () -> LabelContent,
        accessibilityIdentifier: String? = nil,
        role: ButtonRole? = nil
    ) {
        self.action = action
        self.label = label
        self.accessibilityIdentifier = accessibilityIdentifier
        self.role = role
    }
    
    var body: some View {
        Button(role: role) {
            WKInterfaceDevice.current().play(.click)
            action()
        } label: {
            label()
        }
        .font(.caption)
        .labelStyle(.titleAndIcon)
        .accessibilityIdentifier(accessibilityIdentifier ?? "")
    }
}
----------------------------------------------------------------------------------------------------
File: MenuView.swift
Path: GraphEditorWatch/Views/MenuView.swift
Last modified: 2025-10-25 10:12:04

Contents:
//
//  MenuView.swift
//  GraphEditor
//
//  Created by handcart on 8/20/25.
//

import SwiftUI
import WatchKit
import GraphEditorShared
import os

struct MenuView: View {
    let viewModel: GraphViewModel
    let isSimulatingBinding: Binding<Bool>
    let onCenterGraph: () -> Void
    @Binding var showMenu: Bool
    @Binding var showOverlays: Bool
    @Binding var selectedNodeID: NodeID?
    @Binding var selectedEdgeID: UUID?
    
    @FocusState private var isMenuFocused: Bool
    @State private var isAddingEdge: Bool = false
    
    private static let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "menuview")
    
    var body: some View {
        if let id = selectedNodeID, selectedEdgeID == nil {
            if viewModel.model.nodes.first(where: { $0.id == id })?.unwrapped is ToggleNode {
                ToggleNodeMenuView(
                    viewModel: viewModel,
                    onDismiss: { showMenu = false },
                    selectedNodeID: $selectedNodeID,
                    isAddingEdge: $isAddingEdge
                )
            } else {            NodeMenuView(
                viewModel: viewModel,
                onDismiss: { showMenu = false },
                selectedNodeID: $selectedNodeID,
                isAddingEdge: $isAddingEdge
            )
            }
        }
        else if selectedEdgeID != nil {
            EdgeMenuView(
                viewModel: viewModel,
                isSimulatingBinding: isSimulatingBinding,
                onCenterGraph: onCenterGraph,
                showMenu: $showMenu,
                showOverlays: $showOverlays,
                selectedEdgeID: $selectedEdgeID,
                onDismiss: { showMenu = false }
            )
        } else {
            GraphMenuView(
                viewModel: viewModel,
                isSimulatingBinding: isSimulatingBinding,
                showMenu: $showMenu,
                showOverlays: $showOverlays,
                onDismiss: { showMenu = false }
            )
        }
    }
}
----------------------------------------------------------------------------------------------------
File: NodeMenuView.swift
Path: GraphEditorWatch/Views/NodeMenuView.swift
Last modified: 2025-11-04 10:48:57

Contents:
//
//  NodeMenuView.swift
//  GraphEditorWatch
//
//  Created by handcart on 2025-08-16
//

import SwiftUI
import WatchKit
import GraphEditorShared
import os  // For logging

struct NodeMenuView: View {
    let viewModel: GraphViewModel
    let onDismiss: () -> Void
    @Binding var selectedNodeID: NodeID?
    @Binding var isAddingEdge: Bool
    @State private var selectedEdgeType: GraphEditorShared.EdgeType = .association  // Use shared EdgeType
    @FocusState private var isMenuFocused: Bool
    
    private static let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "nodemenuview")
    
    private var nodeLabel: String {
        if let id = selectedNodeID, let node = viewModel.model.nodes.first(where: { $0.id == id }) {
            return "\(node.label)"
        }
        return ""
    }
    
    var isToggleNode: Bool {
        viewModel.isSelectedToggleNode
    }
    
    var body: some View {
        ScrollView {
            VStack(spacing: 8) {
                // Add Section: Side-by-side buttons with icons + text
                Text("Add").font(.subheadline.bold()).frame(maxWidth: .infinity, alignment: .leading).padding(.horizontal, 8)
                HStack(spacing: 8) {
                    addNodeButton
                    addToggleNodeButton
                }
                .padding(.horizontal, 8)
                
                if selectedNodeID != nil {
                    HStack(spacing: 8) {
                        addChildButton
                        addEdgeButton
                    }
                    .padding(.horizontal, 8)
                    
                    // Replaced Picker with buttons for edge type selection
                    HStack(spacing: 8) {
                        edgeTypeButton(type: .association)
                        edgeTypeButton(type: .hierarchy)
                    }
                    .padding(.horizontal, 8)
                }
                
                // Edit Section: Side-by-side buttons with icons + text (node-focused only)
                Text("Edit").font(.subheadline.bold()).frame(maxWidth: .infinity, alignment: .leading).padding(.horizontal, 8)
                HStack(spacing: 8) {
                    editContentsButton
                    deleteNodeButton
                }
                .padding(.horizontal, 8)
                
                if isToggleNode {
                    toggleExpandButton.padding(.horizontal, 8)  // Conditional for ToggleNode
                }
            }
            .padding(4)
        }
        .accessibilityIdentifier("nodeMenuGrid")
        .navigationTitle("Node \(nodeLabel)")  // Dynamic name in top-right
        .focused($isMenuFocused)
        .onAppear {
            isMenuFocused = true
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                isMenuFocused = true
            }
            Self.logger.debug("Node Menu appeared: selectedNodeID=\(selectedNodeID?.uuidString.prefix(8) ?? "nil")")
        }
        .onChange(of: isMenuFocused) { _, newValue in
            Self.logger.debug("Node Menu focus: \(newValue)")
            if !newValue {
                isMenuFocused = true
            }
        }
        .ignoresSafeArea(.keyboard)
    }
    
    // Edge type button (example; adjust if needed)
    private func edgeTypeButton(type: GraphEditorShared.EdgeType) -> some View {
        Button {
            selectedEdgeType = type
            Self.logger.debug("Selected \(type == .association ? "Association" : "Hierarchy") edge type")
        } label: {
            Text(type == .association ? "Assoc" : "Hier")
                .font(.caption)
                .padding(4)
                .background(selectedEdgeType == type ? Color.blue : Color.gray)
                .cornerRadius(4)
        }
        .accessibilityLabel("Select \(type == .association ? "Association" : "Hierarchy") edge type")
    }
    
    private var addNodeButton: some View {
        MenuButton(
            action: {
                Task { await viewModel.model.addNode(at: CGPoint.zero) }
                onDismiss()
            },
            label: {
                Label("Node", systemImage: "plus.circle")
            },
            accessibilityIdentifier: "addNodeButton"
        )
    }
    
    private var addToggleNodeButton: some View {
        MenuButton(
            action: {
                Task { await viewModel.model.addToggleNode(at: CGPoint.zero) }
                onDismiss()
            },
            label: {
                Label("Toggle", systemImage: "plus.circle.fill")
            },
            accessibilityIdentifier: "addToggleNodeButton"
        )
    }
    
    private var addChildButton: some View {
        MenuButton(
            action: {
                if let id = selectedNodeID {
                    Task { await viewModel.model.addPlainChild(to: id) }  // FIXED: Use new addPlainChild method
                }
                onDismiss()
            },
            label: {
                Label("Plain Child", systemImage: "plus.square")  // Updated label for clarity
            },
            accessibilityIdentifier: "addChildButton"
        )
    }
    
    private var addEdgeButton: some View {
        MenuButton(
            action: {
                viewModel.pendingEdgeType = selectedEdgeType
                isAddingEdge = true
                onDismiss()
            },
            label: {
                Label("Edge", systemImage: "arrow.right.circle")
            },
            accessibilityIdentifier: "addEdgeButton"
        )
        .disabled(selectedNodeID == nil)
    }
    
    private var editContentsButton: some View {
        NavigationLink(destination: EditContentSheet(
            selectedID: selectedNodeID ?? NodeID(),
            viewModel: viewModel,
            onSave: { newContents in
                if let id = selectedNodeID {
                    Task { await viewModel.model.updateNodeContents(withID: id, newContents: newContents) }
                }
            }
        )
            .environment(\.disableCanvasFocus, true)  // NEW: Set flag on destination
        ) {
            Label("Contents", systemImage: "pencil")
                .labelStyle(.titleAndIcon)
                .font(.caption)
        }
        .accessibilityIdentifier("editContentsButton")
    }
    
    private var toggleExpandButton: some View {
        MenuButton(
            action: {
                Task { await viewModel.toggleSelectedNode() }
                onDismiss()
            },
            label: {
                Label("Toggle", systemImage: "arrow.up.arrow.down")
            },
            accessibilityIdentifier: "toggleExpandCollapseButton"
        )
    }
    
    private var deleteNodeButton: some View {
        MenuButton(
            action: {
                if let id = selectedNodeID {
                    Task {
                        await viewModel.model.deleteNode(withID: id)
                        viewModel.setSelectedNode(nil)
                    }
                }
                onDismiss()
            },
            label: {
                Label("Delete", systemImage: "trash")
            },
            accessibilityIdentifier: "deleteNodeButton",
            role: .destructive
        )
    }
}
----------------------------------------------------------------------------------------------------
File: NodeView.swift
Path: GraphEditorWatch/Views/NodeView.swift
Last modified: 2025-09-16 11:24:30

Contents:
//
//  NodeView.swift
//  GraphEditor
//
//  Created by handcart on 8/13/25.
//

import SwiftUI
import GraphEditorShared

struct NodeView: View {
    let node: any NodeProtocol
    let isSelected: Bool
    let zoomScale: CGFloat
    
    var body: some View {
        ZStack {
            if isSelected {
                Circle()
                    .stroke(Color.yellow, lineWidth: 4 * zoomScale)
                    .frame(width: node.radius * 2 * zoomScale + 4 * zoomScale, height: node.radius * 2 * zoomScale + 4 * zoomScale)
            }
            Circle()
                .fill(node.fillColor)  // Or dynamic based on node type
                .frame(width: node.radius * 2 * zoomScale, height: node.radius * 2 * zoomScale)
            
            // Add icon/label as in ToggleNode.draw
            if let toggleNode = node as? ToggleNode {
                Text(toggleNode.isExpanded ? "-" : "+")
                    .foregroundColor(.white)
                    .font(.system(size: max(8.0, 12.0 * zoomScale), weight: .bold))
            }
            
            Text("\(node.label)")
                .foregroundColor(.white)
                .font(.system(size: max(8.0, 12.0 * zoomScale)))
                .offset(y: -(node.radius + 10) * zoomScale)  // Position above
        }
    }
}
----------------------------------------------------------------------------------------------------
File: ToggleNodeMenuView.swift
Path: GraphEditorWatch/Views/ToggleNodeMenuView.swift
Last modified: 2025-11-04 11:53:50

Contents:
//
//  ToggleNodeMenuView.swift
//  GraphEditor
//
//  Created by handcart on 10/25/25.
//

import SwiftUI
import WatchKit
import GraphEditorShared
import os  // For logging

struct ToggleNodeMenuView: View {
    let viewModel: GraphViewModel
    let onDismiss: () -> Void
    @Binding var selectedNodeID: NodeID?
    @Binding var isAddingEdge: Bool
    @State private var selectedEdgeType: EdgeType = .association  // From GraphTypes.swift
    @FocusState private var isMenuFocused: Bool
    @State private var showEditSheet = false  // NEW: Moved here to struct level
    
    private static let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "togglenodemenuview")
    
    private var nodeLabel: String {
        if let id = selectedNodeID, let node = viewModel.model.nodes.first(where: { $0.id == id }) {
            return "\(node.label)"
        }
        return ""
    }
    
    var body: some View {
        ScrollView {
            VStack(spacing: 8) {
                // Add Section (inherited from NodeMenuView, with extras)
                Text("Add").font(.subheadline.bold()).frame(maxWidth: .infinity, alignment: .leading).padding(.horizontal, 8)
                HStack(spacing: 8) {
                    addNodeButton
                    addToggleNodeButton
                }
                .padding(.horizontal, 8)
                
                if selectedNodeID != nil {
                    // Hierarchy-specific adds
                    HStack(spacing: 8) {
                        addPlainChildButton
                        addToggleChildButton
                    }
                    .padding(.horizontal, 8)
                    
                    HStack(spacing: 8) {
                        addEdgeButton
                        reorderChildrenButton  // Future: Reorder childOrder
                    }
                    .padding(.horizontal, 8)
                    
                    // Edge type buttons
                    HStack(spacing: 8) {
                        edgeTypeButton(type: .association)
                        edgeTypeButton(type: .hierarchy)
                    }
                    .padding(.horizontal, 8)
                }
                
                // Edit Section
                Text("Edit").font(.subheadline.bold()).frame(maxWidth: .infinity, alignment: .leading).padding(.horizontal, 8)
                HStack(spacing: 8) {
                    editContentsButton
                    deleteNodeButton  // Assuming this exists; from your truncated code
                }
                .padding(.horizontal, 8)
            }
        }
        .focused($isMenuFocused)
        .onAppear {
            isMenuFocused = true
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) { isMenuFocused = true }
        }
        .onChange(of: isMenuFocused) { _, newValue in
            if !newValue { isMenuFocused = true }
        }
    }
    
    // Edge type button (same as NodeMenuView)
    private func edgeTypeButton(type: EdgeType) -> some View {
        Button {
            selectedEdgeType = type
            Self.logger.debug("Selected \(type == .association ? "Association" : "Hierarchy") edge type")
        } label: {
            Text(type == .association ? "Assoc" : "Hier")
                .font(.caption)
                .padding(4)
                .background(selectedEdgeType == type ? Color.blue : Color.gray)
                .cornerRadius(4)
        }
        .accessibilityLabel("Select \(type == .association ? "Association" : "Hierarchy") edge type")
    }
    
    private var addNodeButton: some View {
        MenuButton(
            action: {
                Task { await viewModel.model.addNode(at: CGPoint.zero) }
                onDismiss()
            },
            label: {
                Label("Node", systemImage: "plus.circle")
            },
            accessibilityIdentifier: "addNodeButton"
        )
    }
    
    private var addToggleNodeButton: some View {
        MenuButton(
            action: {
                Task { await viewModel.model.addToggleNode(at: CGPoint.zero) }
                onDismiss()
            },
            label: {
                Label("Toggle", systemImage: "plus.circle.fill")
            },
            accessibilityIdentifier: "addToggleNodeButton"
        )
    }
    
    // New: Plain child (uses addPlainChild)
    private var addPlainChildButton: some View {
        MenuButton(
            action: {
                if let id = selectedNodeID {
                    Task { await viewModel.model.addPlainChild(to: id) }
                }
                onDismiss()
            },
            label: {
                Label("Plain Child", systemImage: "plus.square")
            },
            accessibilityIdentifier: "addPlainChildButton"
        )
    }
    
    // New: Toggle child (uses addToggleChild)
    private var addToggleChildButton: some View {
        MenuButton(
            action: {
                if let id = selectedNodeID {
                    Task { await viewModel.model.addToggleChild(to: id) }
                }
                onDismiss()
            },
            label: {
                Label("Toggle Child", systemImage: "plus.square.fill")
            },
            accessibilityIdentifier: "addToggleChildButton"
        )
    }
    
    private var addEdgeButton: some View {
        MenuButton(
            action: {
                viewModel.pendingEdgeType = selectedEdgeType
                isAddingEdge = true
                onDismiss()
            },
            label: {
                Label("Edge", systemImage: "arrow.right.circle")
            },
            accessibilityIdentifier: "addEdgeButton"
        )
        .disabled(selectedNodeID == nil)
    }
    
    // Placeholder for reordering (future: navigate to a list view)
    private var reorderChildrenButton: some View {
        MenuButton(
            action: {
                // TODO: Implement reordering (e.g., present a draggable list of child IDs)
                Self.logger.debug("Reorder children triggered for node \(nodeLabel)")
                onDismiss()
            },
            label: {
                Label("Reorder", systemImage: "arrow.up.and.down")
            },
            accessibilityIdentifier: "reorderChildrenButton"
        )
    }
    
    private var editContentsButton: some View {  // UPDATED: Now a simple return
            Button {
                WKInterfaceDevice.current().play(.click)  // Optional haptic
                showEditSheet = true
            } label: {
                Label("Contents", systemImage: "pencil")
                    .labelStyle(.titleAndIcon)
                    .font(.caption)
            }
            .accessibilityIdentifier("editContentsButton")
            .sheet(isPresented: $showEditSheet) {
                EditContentSheet(
                    selectedID: selectedNodeID ?? NodeID(),
                    viewModel: viewModel,
                    onSave: { newContents in
                        if let id = selectedNodeID {
                            Task { await viewModel.model.updateNodeContents(withID: id, newContents: newContents) }
                        }
                        showEditSheet = false  // Auto-dismiss on save
                    }
                )
                .environment(\.disableCanvasFocus, true)  // Keep for safety
            }
        }
    
    private var toggleExpandButton: some View {
        MenuButton(
            action: {
                Task { await viewModel.toggleSelectedNode() }
                onDismiss()
            },
            label: {
                Label("Toggle", systemImage: "arrow.up.arrow.down")
            },
            accessibilityIdentifier: "toggleExpandCollapseButton"
        )
    }
    
    private var deleteNodeButton: some View {
        MenuButton(
            action: {
                if let id = selectedNodeID {
                    Task {
                        await viewModel.model.deleteNode(withID: id)
                        viewModel.setSelectedNode(nil)
                    }
                }
                onDismiss()
            },
            label: {
                Label("Delete", systemImage: "trash")
            },
            accessibilityIdentifier: "deleteNodeButton",
            role: .destructive
        )
    }
}
----------------------------------------------------------------------------------------------------
File: UnifiedDatePicker.swift
Path: GraphEditorWatch/Views/UnifiedDatePicker.swift
Last modified: 2025-11-04 12:50:12

Contents:
//
//  UnifiedDatePicker.swift
//  GraphEditor
//
//  Created by handcart on 11/4/25.
//

import SwiftUI
import GraphEditorShared
@available(watchOS 10.0, *)

struct UnifiedDatePicker: View {
    @Binding var date: Date
    private let calendar = Calendar.current
    let initialComponent: DateComponent
    @State private var selectedComponent: DateComponent
    
    init(date: Binding<Date>, initialComponent: DateComponent = .month) {
        _date = date
        self.initialComponent = initialComponent
        _selectedComponent = State(initialValue: initialComponent)
    }
    
    enum DateComponent: String, CaseIterable {
        case year, month, day
    }
    
    var body: some View {
        TabView(selection: $selectedComponent) {  // Swipe or Crown to switch
            yearPicker.tag(DateComponent.year)
            monthPicker.tag(DateComponent.month)
            dayPicker.tag(DateComponent.day)
        }
        .tabViewStyle(.page)  // Enables swiping between components
        .frame(height: 100)  // Compact for watch
        .onChange(of: selectedComponent) { _ in
            WKInterfaceDevice.current().play(.click)  // Haptic feedback
        }
    }
    
    private var yearPicker: some View {
        Picker("Year", selection: Binding<Int>(
            get: { calendar.component(.year, from: date) },
            set: { newYear in updateDate(year: newYear) }
        )) {
            ForEach(1900...2100, id: \.self) { year in  // Reasonable range to reduce scrolling
                Text(String(year)).tag(year)
            }
        }
        .pickerStyle(.wheel)  // Crown-friendly
    }
    
    private var monthPicker: some View {
        Picker("Month", selection: Binding<Int>(
            get: { calendar.component(.month, from: date) },
            set: { newMonth in updateDate(month: newMonth) }
        )) {
            ForEach(1...12, id: \.self) { month in
                Text(DateFormatter().monthSymbols[month - 1]).tag(month)
            }
        }
        .pickerStyle(.wheel)
    }
    
    private var dayPicker: some View {
        let daysInMonth = calendar.range(of: .day, in: .month, for: date)?.count ?? 31
        return Picker("Day", selection: Binding<Int>(
            get: { calendar.component(.day, from: date) },
            set: { newDay in updateDate(day: newDay) }
        )) {
            ForEach(1...daysInMonth, id: \.self) { day in
                Text(String(day)).tag(day)
            }
        }
        .pickerStyle(.wheel)
    }
    
    private func updateDate(year: Int? = nil, month: Int? = nil, day: Int? = nil) {
        var components = calendar.dateComponents([.year, .month, .day], from: date)
        if let year = year { components.year = year }
        if let month = month { components.month = month }
        if let day = day { components.day = min(day, calendar.range(of: .day, in: .month, for: calendar.date(from: components)!)?.count ?? 31) }
        if let newDate = calendar.date(from: components) {
            date = newDate
        }
    }
}
----------------------------------------------------------------------------------------------------
File: ViewSection.swift
Path: GraphEditorWatch/Views/ViewSection.swift
Last modified: 2025-10-23 10:08:33

Contents:
//
//  ViewSection.swift
//  GraphEditor
//
//  Created by handcart on 10/5/25.
//

import SwiftUI
import WatchKit

struct ViewSection: View {
    @Binding var showOverlays: Bool
    let isSimulating: Binding<Bool>
    let onCenterGraph: () -> Void
    let onDismiss: () -> Void
    let onSimulationChange: (Bool) -> Void
    
    var body: some View {
        Group {
            customOverlaysToggle
            customSimulationToggle
            centerButton
        }
        .accessibilityElement(children: .combine)
        .accessibilityLabel("View section")
    }
    
    private var customOverlaysToggle: some View {
        HStack(spacing: 4) {
            Image(systemName: "eye")
                .font(.caption)
            Text("Overlays")
                .font(.caption)
                .minimumScaleFactor(0.8)
                .lineLimit(1)
            Spacer()
            Toggle("", isOn: $showOverlays)
                .labelsHidden()
        }
        .onChange(of: showOverlays) {
            WKInterfaceDevice.current().play(.click)
            onDismiss()
        }
        .gridCellColumns(2)
        .accessibilityLabel("Overlays toggle")
    }
    
    private var customSimulationToggle: some View {
        HStack(spacing: 4) {
            Image(systemName: "play")
                .font(.caption)
            Text("Simulate")
                .font(.caption)
                .minimumScaleFactor(0.8)
                .lineLimit(1)
            Spacer()
            Toggle("", isOn: isSimulating)
                .labelsHidden()
        }
        .onChange(of: isSimulating.wrappedValue) {_, newValue in
            WKInterfaceDevice.current().play(.click)
            onSimulationChange(newValue)
            onDismiss()
        }
        .accessibilityIdentifier("toggleSimulation")
        .gridCellColumns(2)
        .accessibilityLabel("Simulate toggle")
    }
    
    private var centerButton: some View {
        Button {
            WKInterfaceDevice.current().play(.click)
            onCenterGraph()
            onDismiss()
        } label: {
            Label("Center", systemImage: "dot.circle")
                .labelStyle(.titleAndIcon)
                .font(.caption)
        }
        .accessibilityIdentifier("centerGraphButton")
        .gridCellColumns(2)
    }
}
----------------------------------------------------------------------------------------------------
File: AccessibilityTests.swift
Path: GraphEditorWatchTests/AccessibilityTests.swift
Last modified: 2025-09-22 11:21:14

Contents:
//
//  AccessibilityTests.swift
//  GraphEditor
//
//  Created by handcart on 9/22/25.
//
import Testing
import Foundation
import CoreGraphics
@testable import GraphEditorWatch
@testable import GraphEditorShared
import XCTest
import SwiftUI

struct AccessibilityTests {
    private func mockPhysicsEngine() -> GraphEditorShared.PhysicsEngine {
        GraphEditorShared.PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
    }
    
    @Test func testGraphDescription() async throws {
        let storage = MockGraphStorage()
        storage.nodes = [Node(label: 0, position: .zero)]
        let model = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        await MainActor.run { model.nextNodeLabel = 1 }
        await model.addNode(at: .zero)
        await model.addNode(at: CGPoint(x: 10, y: 10))
        
        await MainActor.run { model.edges.append(GraphEdge(from: model.nodes[0].id, target: model.nodes[1].id)) }
        
        let descNoSelect = await MainActor.run { model.graphDescription(selectedID: nil, selectedEdgeID: nil) }
        #expect(descNoSelect == "Graph with 2 nodes and 1 directed edge. No node or edge selected.", "Correct desc without selection")
        
        let descWithSelect = await MainActor.run { model.graphDescription(selectedID: model.nodes[0].id, selectedEdgeID: nil) }
        #expect(descWithSelect == "Graph with 2 nodes and 1 directed edge. Node 1 selected, outgoing to: 2; incoming from: none.", "Correct desc with selection")
    }
}
----------------------------------------------------------------------------------------------------
File: CoordinateTransformerTests.swift
Path: GraphEditorWatchTests/CoordinateTransformerTests.swift
Last modified: 2025-10-08 15:23:57

Contents:
//
//  CoordinateTransformerTests.swift
//  GraphEditor
//
//  Created by handcart on 9/22/25.
//
import Testing
import Foundation
import CoreGraphics
@testable import GraphEditorWatch
@testable import GraphEditorShared
import XCTest
import SwiftUI

struct CoordinateTransformerTests {
    @Test func testCoordinateRoundTrip() {
        let viewSize = CGSize(width: 205, height: 251)
        let centroid = CGPoint(x: 150, y: 150)
        let modelPos = CGPoint(x: 167.78, y: 165.66)
        let zoom: CGFloat = 1.0
        let offset = CGSize.zero
        
        let screenPos = CoordinateTransformer.modelToScreen(modelPos, effectiveCentroid: centroid, zoomScale: zoom, offset: offset, viewSize: viewSize)
        let recoveredModel = CoordinateTransformer.screenToModel(screenPos, effectiveCentroid: centroid, zoomScale: zoom, offset: offset, viewSize: viewSize)
        
        #expect(approximatelyEqual(recoveredModel, modelPos, accuracy: 1e-3), "Round-trip should match original model position")
    }
    
    @Test func testCoordinateRoundTripWithZoomAndOffset() {
        let viewSize = CGSize(width: 205, height: 251)
        let centroid = CGPoint(x: 56.73, y: 161.10)
        let modelPos = CGPoint(x: -40.27, y: 52.60)
        let zoom: CGFloat = 1.0
        let offset = CGSize(width: 81, height: 111.5)
        
        let screenPos = CoordinateTransformer.modelToScreen(modelPos, effectiveCentroid: centroid, zoomScale: zoom, offset: offset, viewSize: viewSize)
        let recoveredModel = CoordinateTransformer.screenToModel(screenPos, effectiveCentroid: centroid, zoomScale: zoom, offset: offset, viewSize: viewSize)
        
        #expect(approximatelyEqual(recoveredModel, modelPos, accuracy: 1e-3), "Round-trip with zoom and offset should match")
    }
    
    public func approximatelyEqual(_ lhs: CGPoint, _ rhs: CGPoint, accuracy: CGFloat) -> Bool {
        hypot(lhs.x - rhs.x, lhs.y - rhs.y) < accuracy
    }
}
----------------------------------------------------------------------------------------------------
File: EditContentSheetTests.swift
Path: GraphEditorWatchTests/EditContentSheetTests.swift
Last modified: 2025-10-21 08:23:20

Contents:
//
//  EditContentSheetTests.swift
//  GraphEditor
//
//  Created by handcart on 9/25/25.
//
import Testing
import SwiftUI
@testable import GraphEditorWatch
@testable import GraphEditorShared

struct EditContentSheetTests {
    private func setupViewModel() async -> GraphViewModel {
        let storage = MockGraphStorage()
        let physicsEngine = PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
        let model = await GraphModel(storage: storage, physicsEngine: physicsEngine)
        return await GraphViewModel(model: model)
    }
    
    @MainActor @Test func testSaveStringContent() async {
        let viewModel = await setupViewModel()
        let nodeID = NodeID()
        var savedContent: [NodeContent]?
        let sheet = EditContentSheet(selectedID: nodeID, viewModel: viewModel) { content in
            savedContent = content
        }
        // Simulate input: Since @State is private, this is placeholder; use XCUITest for full simulation or expose states for testing
        // For example, assume manual set: sheet.selectedType = "String"; sheet.stringValue = "test"; then call onSave
        // Placeholder assertion (adapt based on actual simulation logic)
        _ = sheet  // Use to silence warning
        #expect(savedContent == nil, "Initially nil; add simulation to set [.string(\"test\")]")
    }
}
--------------------------------------------------
