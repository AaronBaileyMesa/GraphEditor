## Focused Project Concatenation
This file includes only UI, interactivity, model, and core logic files.
Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
Current date: 2025-08-26 08:59:51
Table of Contents:
1. GraphEditorWatch/Views/GraphGesturesModifier.swift
2. GraphEditorWatch/Views/MenuView.swift
3. GraphEditorWatch/Views/NodeView.swift
4. GraphEditorWatchTests/GraphEditorWatchTests.swift
5. GraphEditorWatchUITests/GraphEditorWatchUITests.swift--------------------------------------------------
File: GraphGesturesModifier.swift
Path: GraphEditorWatch/Views/GraphGesturesModifier.swift
Last modified: 2025-08-25 12:02:59

Contents:
//
//  GraphGesturesModifier.swift
//  GraphEditorWatch
//
//  Created by handcart on 2025-08-16

import SwiftUI
import WatchKit
import GraphEditorShared
import os.log  // Added for optimized logging

struct GraphGesturesModifier: ViewModifier {
    let viewModel: GraphViewModel
    @Binding var zoomScale: CGFloat
    @Binding var offset: CGSize
    @Binding var draggedNode: (any NodeProtocol)?
    @Binding var dragOffset: CGPoint
    @Binding var potentialEdgeTarget: (any NodeProtocol)?
    @Binding var selectedNodeID: NodeID?
    @Binding var selectedEdgeID: UUID?
    let viewSize: CGSize
    @Binding var panStartOffset: CGSize?
    @Binding var showMenu: Bool
    let maxZoom: CGFloat
    @Binding var crownPosition: Double
    let onUpdateZoomRanges: () -> Void
    
    @State private var dragStartNode: (any NodeProtocol)? = nil
    @State private var isMovingSelectedNode: Bool = false
    @State private var longPressTimer: Timer? = nil
    @State private var isLongPressTriggered: Bool = false
    
    private let dragStartThreshold: CGFloat = 5.0
    
    // Optimized logger
    private let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "gestures")
    
    private func hitTest(at modelPos: CGPoint, type: HitType) -> Any? {
        let modelHitRadius = Constants.App.hitScreenRadius / zoomScale * 2.0
        switch type {
        case .node:
            return viewModel.model.visibleNodes().first { distance($0.position, modelPos) < modelHitRadius }
        case .edge:
            return viewModel.model.visibleEdges().first { edge in
                guard let from = viewModel.model.nodes.first(where: { $0.id == edge.from }),
                      let to = viewModel.model.nodes.first(where: { $0.id == edge.to }) else {
                    return false
                }
                return pointToLineDistance(point: modelPos, from: from.position, to: to.position) < modelHitRadius
            }
        }
    }
    
    enum HitType { case node, edge }
    
    private func screenToModel(_ screenPos: CGPoint, zoomScale: CGFloat, offset: CGSize, viewSize: CGSize) -> CGPoint {
        let safeZoom = max(zoomScale, 0.1)  // Raise to 0.1 to avoid inf/large numbers
        let viewCenter = CGPoint(x: viewSize.width / 2, y: viewSize.height / 2)
        let panOffset = CGPoint(x: offset.width, y: offset.height)
        let effectiveCentroid = focalPointForCentering()
        
        let translated = screenPos - viewCenter - panOffset // Subtract negative offset = add positive, boosting to match nodes
        let unscaled = translated / safeZoom
        let modelPos = unscaled + effectiveCentroid
        
        #if DEBUG
        logger.debug("screenToModel calibrated: Screen \(String(describing: screenPos)) -> Model \(String(describing: modelPos)), Zoom \(safeZoom), Offset \(String(describing: panOffset)), Centroid \(String(describing: effectiveCentroid))")
        #endif
        
        return modelPos
    }
    
    private func focalPointForCentering() -> CGPoint {
        let visibleNodes = viewModel.model.visibleNodes()
        guard !visibleNodes.isEmpty else { return .zero }
        var effectiveCentroid = centroid(of: visibleNodes) ?? .zero  // Use free func to avoid conformance issue
        if let selectedID = selectedNodeID, let selected = visibleNodes.first(where: { $0.id == selectedID }) {
            effectiveCentroid = selected.position
        } else if let selectedEdgeID = selectedEdgeID, let edge = viewModel.model.edges.first(where: { $0.id == selectedEdgeID }),
                  let from = visibleNodes.first(where: { $0.id == edge.from }), let to = visibleNodes.first(where: { $0.id == edge.to }) {
            effectiveCentroid = (from.position + to.position) / 2
        }
        
        #if DEBUG
        logger.debug("Focal point calculated: \(String(describing: effectiveCentroid))")
        #endif
        
        return effectiveCentroid
    }
    
    func body(content: Content) -> some View {
        let dragGesture = DragGesture(minimumDistance: 0)
            .onChanged { value in
                #if DEBUG
                logger.debug("Gesture .onChanged triggered")
                logger.debug("Current zoomScale: \(zoomScale)")
                #endif
                
                if isLongPressTriggered { return }
                
                let screenHitRadius: CGFloat = Constants.App.hitScreenRadius
                let modelHitRadius = screenHitRadius / zoomScale

                let translationDistance = hypot(value.translation.width, value.translation.height)
                let touchPos = screenToModel(value.location, zoomScale: zoomScale, offset: offset, viewSize: viewSize)

                if dragStartNode == nil {
                    let startModelPos = screenToModel(value.startLocation, zoomScale: zoomScale, offset: offset, viewSize: viewSize)
                    if let hitNode = viewModel.model.nodes.first(where: { distance($0.position, startModelPos) < modelHitRadius }) {
                        dragStartNode = hitNode
                        isMovingSelectedNode = (hitNode.id == selectedNodeID)
                    }
                }

                if longPressTimer == nil {
                    //Do not reduce withTimeInterval
                    longPressTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: false) { _ in
                        self.showMenu = true
                        WKInterfaceDevice.current().play(.click)
                        self.isLongPressTriggered = true
                        self.longPressTimer = nil
                    }
                    #if DEBUG
                    logger.debug("Long-press timer started")
                    #endif
                }

                if translationDistance >= dragStartThreshold {
                    longPressTimer?.invalidate()
                    longPressTimer = nil
                    
                    if isMovingSelectedNode, let node = dragStartNode {
                        dragOffset = CGPoint(x: value.translation.width / zoomScale, y: value.translation.height / zoomScale)
                        draggedNode = node
                    } else {
                        if panStartOffset == nil {
                            panStartOffset = offset
                        }
                        offset = CGSize(width: panStartOffset!.width + value.translation.width,
                                        height: panStartOffset!.height + value.translation.height)
                    }
                    
                    potentialEdgeTarget = viewModel.model.nodes.first {
                        dragStartNode?.id != $0.id && distance($0.position, touchPos) < modelHitRadius
                    }
                }
                
                // Diagnostic logs (moved outside timer, gated and summarized)
                #if DEBUG
                let effectiveCentroid = focalPointForCentering()
                let translated = CGPoint(x: value.location.x - viewSize.width / 2 - offset.width, y: value.location.y - viewSize.height / 2 - offset.height)
                let unscaled = CGPoint(x: translated.x / zoomScale, y: translated.y / zoomScale)
                logger.debug("--- .onChanged Diagnostic ---")
                logger.debug("Effective Centroid: \(String(describing: effectiveCentroid))")
                logger.debug("Screen Pos: \(String(describing: value.location))")
                logger.debug("Translated: \(String(describing: translated))")
                logger.debug("Unscaled: \(String(describing: unscaled))")
                logger.debug("Model Pos (touchPos): \(String(describing: touchPos))")
                logger.debug("Visible Nodes Count: \(viewModel.model.visibleNodes().count)")  // Summarized instead of full list
                logger.debug("-----------------------------")
                #endif
            }
            .onEnded { value in
                #if DEBUG
                logger.debug("Gesture .onEnded triggered")
                #endif
                
                if isLongPressTriggered {
                    isLongPressTriggered = false
                    longPressTimer?.invalidate()
                    longPressTimer = nil
                    return
                }
                
                longPressTimer?.invalidate()
                longPressTimer = nil
                
                viewModel.resumeSimulation()
                
                let screenHitRadius: CGFloat = Constants.App.hitScreenRadius * 1.5
                let modelHitRadius = screenHitRadius / zoomScale

                let dragDistance = hypot(value.translation.width, value.translation.height)
                let tapModelPos = screenToModel(value.startLocation, zoomScale: zoomScale, offset: offset, viewSize: viewSize)
                
                if dragDistance < Constants.App.tapThreshold {
                    if let hitNode = viewModel.model.visibleNodes().first(where: { distance($0.position, tapModelPos) < modelHitRadius }) {
                        let updatedNode = hitNode.handlingTap()
                        viewModel.model.updateNode(updatedNode)
                        selectedNodeID = (selectedNodeID == hitNode.id) ? nil : hitNode.id
                        selectedEdgeID = nil
                        #if DEBUG
                        logger.debug("Tap detected at model position: \(String(describing: tapModelPos)). SelectedNodeID before: \(selectedNodeID?.uuidString ?? "nil"), SelectedEdgeID before: \(selectedEdgeID?.uuidString ?? "nil")")
                        #endif
                        WKInterfaceDevice.current().play(.click)
                    } else if let hitEdge = viewModel.model.visibleEdges().first(where: { edge in
                        if let from = viewModel.model.nodes.first(where: { $0.id == edge.from }),
                           let to = viewModel.model.nodes.first(where: { $0.id == edge.to }),
                           pointToLineDistance(point: tapModelPos, from: from.position, to: to.position) < modelHitRadius {
                            return true
                        }
                        return false
                    }) {
                        #if DEBUG
                        logger.debug("Edge hit detected with tightened radius.")
                        #endif
                        selectedEdgeID = (selectedEdgeID == hitEdge.id) ? nil : hitEdge.id
                        selectedNodeID = nil
                        WKInterfaceDevice.current().play(.click)
                    } else {
                        #if DEBUG
                        logger.debug("Background tap confirmed (no hit with tightened radius). Deselecting everything.")
                        #endif
                        selectedNodeID = nil
                        selectedEdgeID = nil
                    }
                    
                    #if DEBUG
                    logger.debug("SelectedNodeID after tap: \(selectedNodeID?.uuidString ?? "nil"), SelectedEdgeID after: \(selectedEdgeID?.uuidString ?? "nil")")
                    #endif
                    
                    // Diagnostic logs (gated and summarized)
                    #if DEBUG
                    let effectiveCentroid = focalPointForCentering()
                    let translated = CGPoint(x: value.startLocation.x - viewSize.width / 2 - offset.width, y: value.startLocation.y - viewSize.height / 2 - offset.height)
                    let unscaled = CGPoint(x: translated.x / zoomScale, y: translated.y / zoomScale)
                    logger.debug("--- Tap (.onEnded) Diagnostic ---")
                    logger.debug("Effective Centroid: \(String(describing: effectiveCentroid))")
                    logger.debug("Screen Pos: \(String(describing: value.startLocation))")
                    logger.debug("Translated: \(String(describing: translated))")
                    logger.debug("Unscaled: \(String(describing: unscaled))")
                    logger.debug("Model Pos (tapModelPos): \(String(describing: tapModelPos))")
                    logger.debug("Visible Nodes Count: \(viewModel.model.visibleNodes().count)")  // Summarized instead of full list
                    logger.debug("--------------------------------")
                    #endif
                } else {
                    viewModel.snapshot()
                    if let startNode = dragStartNode, let target = potentialEdgeTarget, target.id != startNode.id {
                        let newEdge = GraphEdge(from: startNode.id, to: target.id)
                        if !viewModel.model.hasCycle(adding: newEdge) &&
                           !viewModel.model.edges.contains(where: { $0.from == startNode.id && $0.to == target.id }) {
                            viewModel.model.edges.append(newEdge)
                            viewModel.model.startSimulation()
                            WKInterfaceDevice.current().play(.success)
                        }
                    } else if isMovingSelectedNode, let node = dragStartNode,
                              let index = viewModel.model.nodes.firstIndex(where: { $0.id == node.id }) {
                        var updatedNode = viewModel.model.nodes[index]
                        updatedNode.position.x += value.translation.width / zoomScale
                        updatedNode.position.y += value.translation.height / zoomScale
                        viewModel.model.nodes[index] = updatedNode
                        viewModel.model.startSimulation()
                        WKInterfaceDevice.current().play(.click)
                    }
                    viewModel.handleTap()
                }
                
                withAnimation(.spring(duration: 0.3, bounce: 0.2)) {
                    onUpdateZoomRanges()
                }
                
                dragStartNode = nil
                isMovingSelectedNode = false
                draggedNode = nil
                dragOffset = .zero
                potentialEdgeTarget = nil
                panStartOffset = nil
                onUpdateZoomRanges()
            }
        
        content
            .highPriorityGesture(dragGesture)  // New: Prioritize over system gestures on WatchOS
    }
    
    private func distance(_ p1: CGPoint, _ p2: CGPoint) -> CGFloat {
        hypot(p1.x - p2.x, p1.y - p2.y)
    }
    
    private func pointToLineDistance(point: CGPoint, from: CGPoint, to: CGPoint) -> CGFloat {
        let lineVec = to - from
        let pointVec = point - from
        let lineLen = hypot(lineVec.x, lineVec.y)
        if lineLen == 0 { return hypot(point.x - from.x, point.y - from.y) }
        let dot = pointVec.x * lineVec.x + pointVec.y * lineVec.y
        let denom = lineLen * lineLen
        let tUnclamped = dot / denom
        let t = max(0, min(1, tUnclamped))
        let projection = from + (lineVec * t)
        return hypot(point.x - projection.x, point.y - projection.y)
    }
}
----------------------------------------------------------------------------------------------------
File: MenuView.swift
Path: GraphEditorWatch/Views/MenuView.swift
Last modified: 2025-08-22 21:33:59

Contents:
//
//  MenuView.swift
//  GraphEditor
//
//  Created by handcart on 8/20/25.
//

import SwiftUI
import WatchKit
import GraphEditorShared

struct AddSection: View {
    let viewModel: GraphViewModel
    let selectedNodeID: NodeID?
    let onDismiss: () -> Void

    var body: some View {
        Section(header: Text("Add")) {
            Button("Add Node") {
                viewModel.addNode(at: .zero)
                onDismiss()
            }
            Button("Add Toggle Node") {
                viewModel.addToggleNode(at: .zero)
                onDismiss()
            }
            if let selectedID = selectedNodeID {
                Button("Add Child") {
                    viewModel.addChild(to: selectedID)
                    onDismiss()
                }
            }
        }
    }
}

struct EditSection: View {
    let viewModel: GraphViewModel
    let selectedNodeID: NodeID?
    let selectedEdgeID: UUID?
    let onDismiss: () -> Void

    var body: some View {
        Section(header: Text("Edit")) {
            if let selectedID = selectedNodeID {
                Button("Delete Node", role: .destructive) {
                    viewModel.deleteNode(withID: selectedID)
                    onDismiss()
                }
            }
            if let selectedEdgeID = selectedEdgeID,
               let selectedEdge = viewModel.model.edges.first(where: { $0.id == selectedEdgeID }) {
                let fromID = selectedEdge.from
                let toID = selectedEdge.to
                let isBi = viewModel.model.isBidirectionalBetween(fromID, toID)
                Button(isBi ? "Delete Both Edges" : "Delete Edge", role: .destructive) {
                    viewModel.snapshot()
                    if isBi {
                        let pair = viewModel.model.edgesBetween(fromID, toID)
                        viewModel.model.edges.removeAll { pair.contains($0) }
                    } else {
                        viewModel.model.edges.removeAll { $0.id == selectedEdgeID }
                    }
                    viewModel.model.startSimulation()
                    onDismiss()
                }
            }
            if viewModel.canUndo {
                Button("Undo") {
                    viewModel.undo()
                    onDismiss()
                }
            }
            if viewModel.canRedo {
                Button("Redo") {
                    viewModel.redo()
                    onDismiss()
                }
            }
        }
    }
}

struct ViewSection: View {
    @Binding var showOverlays: Bool
    @Binding var isSimulating: Bool  // Now a Binding for direct Toggle control
    let onCenterGraph: () -> Void
    let onDismiss: () -> Void
    let onSimulationChange: (Bool) -> Void  // New: Handles pause/resume logic

    var body: some View {
        Section(header: Text("View & Simulation")) {
            Toggle("Show Overlays", isOn: $showOverlays)
                .onChange(of: showOverlays) {
                    onDismiss()
                }

            Toggle("Run Simulation", isOn: $isSimulating)
                .onChange(of: isSimulating) { newValue in
                    onSimulationChange(newValue)
                    onDismiss()
                }
            Button("Center Graph") {
                onCenterGraph()
                onDismiss()
            }
        }
    }
}

struct GraphSection: View {
    let viewModel: GraphViewModel
    let onDismiss: () -> Void

    var body: some View {
        Section(header: Text("Graph")) {
            Button("Clear Graph", role: .destructive) {
                viewModel.clearGraph()
                onDismiss()
            }
        }
    }
}

struct MenuView: View {
    @ObservedObject var viewModel: GraphViewModel
    @Binding var showOverlays: Bool
    @Binding var showMenu: Bool
    let onCenterGraph: () -> Void
    @FocusState private var isMenuFocused: Bool  // New
    
    private var isSimulatingBinding: Binding<Bool> {
        Binding(
            get: { viewModel.model.isSimulating },
            set: { viewModel.model.isSimulating = $0 }
        )
    }
    
    var body: some View {
        List {
            if viewModel.selectedEdgeID == nil {
                AddSection(viewModel: viewModel, selectedNodeID: viewModel.selectedNodeID, onDismiss: { showMenu = false })
            }
            
            if viewModel.selectedNodeID != nil || viewModel.selectedEdgeID != nil || viewModel.canUndo || viewModel.canRedo {
                EditSection(viewModel: viewModel, selectedNodeID: viewModel.selectedNodeID, selectedEdgeID: viewModel.selectedEdgeID, onDismiss: { showMenu = false })
            }
            
            ViewSection(
                showOverlays: $showOverlays,
                isSimulating: isSimulatingBinding,
                onCenterGraph: onCenterGraph, onDismiss: { showMenu = false },
                onSimulationChange: { newValue in
                    viewModel.model.isSimulating = newValue
                    if newValue {
                        viewModel.model.startSimulation()
                    } else {
                        viewModel.model.stopSimulation()
                    }
                }
            )
            
            GraphSection(viewModel: viewModel, onDismiss: { showMenu = false })
        }
        .navigationTitle("Menu")
                    .focused($isMenuFocused)  // New: Bind focus to list
                    .onAppear {
                        isMenuFocused = true  // Force focus on appear
                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                            isMenuFocused = true  // Double-focus for reliability
                        }
                    }
                    .onChange(of: isMenuFocused) { newValue in
                        print("Menu focus: \(newValue)")  // Debug
                        if !newValue {
                            isMenuFocused = true  // Auto-recover
                        }
                    }
                    .ignoresSafeArea(.keyboard)
    }
}

#Preview {
    let mockViewModel = GraphViewModel(model: GraphModel(storage: PersistenceManager(), physicsEngine: PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))))
    ContentView(viewModel: mockViewModel)  // <-- If ContentView now takes viewModel, add it here too (see next fix)
}
----------------------------------------------------------------------------------------------------
File: NodeView.swift
Path: GraphEditorWatch/Views/NodeView.swift
Last modified: 2025-08-16 10:12:42

Contents:
//
//  NodeView.swift
//  GraphEditor
//
//  Created by handcart on 8/13/25.
//

import SwiftUI
import GraphEditorShared


struct NodeView: View {
    let node: any NodeProtocol
    let isSelected: Bool
    let zoomScale: CGFloat
    
    var body: some View {
        ZStack {
            if isSelected {
                Circle()
                    .stroke(Color.yellow, lineWidth: 4 * zoomScale)
                    .frame(width: node.radius * 2 * zoomScale + 4 * zoomScale, height: node.radius * 2 * zoomScale + 4 * zoomScale)
            }
            Circle()
                .fill(node.fillColor)  // Or dynamic based on node type
                .frame(width: node.radius * 2 * zoomScale, height: node.radius * 2 * zoomScale)
            
            // Add icon/label as in ToggleNode.draw
            if let toggleNode = node as? ToggleNode {
                Text(toggleNode.isExpanded ? "-" : "+")
                    .foregroundColor(.white)
                    .font(.system(size: max(8.0, 12.0 * zoomScale), weight: .bold))
            }
            
            Text("\(node.label)")
                .foregroundColor(.white)
                .font(.system(size: max(8.0, 12.0 * zoomScale)))
                .offset(y: -(node.radius + 10) * zoomScale)  // Position above
        }
    }
}
----------------------------------------------------------------------------------------------------
File: GraphEditorWatchTests.swift
Path: GraphEditorWatchTests/GraphEditorWatchTests.swift
Last modified: 2025-08-18 10:07:03

Contents:
import Testing
import Foundation
import CoreGraphics
@testable import GraphEditorWatch // Already present
@testable import GraphEditorShared // Changed to @testable for accessing internal members
import XCTest
import SwiftUI

class MockGraphStorage: GraphStorage {
    var nodes: [any NodeProtocol] = []
    var edges: [GraphEdge] = []
    
    func save(nodes: [any NodeProtocol], edges: [GraphEdge]) throws {
        self.nodes = nodes
        self.edges = edges
    }
    
    func load() throws -> (nodes: [any NodeProtocol], edges: [GraphEdge]) {
        (nodes, edges)
    }
    
    func clear() throws {
        nodes = []
        edges = []
    }
}

// Add this helper function at the top of the test file or in the test struct
func approximatelyEqual(_ lhs: CGPoint, _ rhs: CGPoint, accuracy: CGFloat) -> Bool {
    return hypot(lhs.x - rhs.x, lhs.y - rhs.y) < accuracy
}

struct GraphModelTests {
    private func mockPhysicsEngine() -> GraphEditorShared.PhysicsEngine {
        GraphEditorShared.PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300)) // Mock size for tests
    }
    
    @Test func testUndoRedoMixedOperations() {
        let storage = MockGraphStorage()
        let model = GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        let initialNodeCount = model.nodes.count // 3
        let initialEdgeCount = model.edges.count // 3
        
        model.snapshot() // Snapshot 1: initial
        
        // Specify node to delete (e.g., first in cycle removes 2 edges)
        let nodeToDelete = model.nodes[0].id // Explicit
        let connectedEdges = model.edges.filter { $0.from == nodeToDelete || $0.to == nodeToDelete }.count // 2 in triangle
        model.deleteNode(withID: nodeToDelete) // Now 2n, 1e
        model.snapshot() // Snapshot 2: after delete
        
        model.addNode(at: CGPoint.zero) // Now 3n, 1e — no snapshot
        
        #expect(model.nodes.count == initialNodeCount, "After add: count back to initial")
        #expect(model.edges.count == initialEdgeCount - connectedEdges, "Edges reduced by connected count")
        
        model.undo() // To Snapshot 2: after delete
        #expect(model.nodes.count == initialNodeCount - 1, "Undo reverts to post-delete")
        #expect(model.edges.count == initialEdgeCount - connectedEdges, "Edges match post-delete")
        
        model.undo() // To Snapshot 1: initial
        #expect(model.nodes.count == initialNodeCount, "Second undo restores initial")
        #expect(model.edges.count == initialEdgeCount, "Edges restored")
        
        model.redo() // To post-delete
        #expect(model.nodes.count == initialNodeCount - 1, "Redo applies delete")
        
        model.redo() // To post-add
        #expect(model.nodes.count == initialNodeCount, "Redo applies add")
    }
    @Test func testInitializationWithDefaults() {
        let storage = MockGraphStorage()
        let model = GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        #expect(model.nodes.count >= 3, "Should load default or saved nodes")
        #expect(model.edges.count >= 3, "Should load default edges")
    }
    
    @Test func testSnapshotAndUndo() {
        let storage = MockGraphStorage()
        let model = GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        let initialNodes = model.nodes
        model.snapshot()
        model.addNode(at: CGPoint.zero)
        #expect(model.nodes.count == initialNodes.count + 1, "Node added")
        model.undo()
        let restoredNodes = model.nodes
        let idsMatch = Set(restoredNodes.map { $0.id }) == Set(initialNodes.map { $0.id })
        let labelsMatch = Set(restoredNodes.map { $0.label }) == Set(initialNodes.map { $0.label })
        let positionsMatch = zip(restoredNodes.sorted(by: { $0.id.uuidString < $1.id.uuidString }), initialNodes.sorted(by: { $0.id.uuidString < $1.id.uuidString })).allSatisfy { approximatelyEqual($0.position, $1.position, accuracy: 1e-5) }
        #expect(idsMatch && labelsMatch && positionsMatch, "Undo restores state")
    }
    
    @Test func testDeleteNodeAndEdges() {
        let storage = MockGraphStorage()
        let model = GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        #expect(!model.nodes.isEmpty, "Assumes default nodes exist")
        let nodeID = model.nodes[0].id
        let initialEdgeCount = model.edges.count
        model.deleteNode(withID: nodeID)
        #expect(model.nodes.first { $0.id == nodeID } == nil, "Node deleted")
        #expect(model.edges.count < initialEdgeCount, "Edges reduced")
    }
    
    @Test func testSaveLoadRoundTrip() {
        let storage = MockGraphStorage()
        let model = GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        let originalNodeCount = model.nodes.count
        let originalEdges = model.edges
        // Modify and snapshot to trigger save
        model.addNode(at: CGPoint.zero)
        model.snapshot()
        // New instance to trigger load
        let newModel = GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        #expect(newModel.nodes.count == originalNodeCount + 1, "Loaded nodes include added one")
        #expect(newModel.edges == originalEdges, "Edges unchanged")
    }
    
    // New: Basic convergence test with tightened threshold
    // New: Basic convergence test with tightened threshold
    @Test(arguments: 1..<5) func testConvergencePropertyBased(seed: Int) throws {
        let model = GraphModel(storage: MockGraphStorage(), physicsEngine: mockPhysicsEngine())
        srand48(seed)  // Seed random for reproducibility
        //print(model.nodes.map { ($0.label, $0.position) })
        model.nodes = (0..<5).map { _ in
            Node(label: Int(drand48() * 10), position: CGPoint(x: CGFloat(drand48() * 300), y: CGFloat(drand48() * 300)))
        }
        model.edges = (0..<3).map { _ in
            GraphEdge(from: model.nodes[Int(drand48() * 5)].id, to: model.nodes[Int(drand48() * 5)].id)
        }
        
        model.startSimulation()
        // Manual loop for test with substeps
        for _ in 0..<Constants.Physics.maxSimulationSteps {
            var nodes = model.nodes
            var activeAccum = false  // Accumulator declared here (outside inner loop)
            for _ in 0..<20 {  // Increased substeps as suggested
                let (updatedNodes, stepActive) = model.physicsEngine.simulationStep(nodes: nodes, edges: model.edges)
                nodes = updatedNodes
                activeAccum = activeAccum || stepActive  // Update accumulator
                if !stepActive { break }  // Optional: Early break if inactive in a substep
            }
            model.nodes = nodes
            if !activeAccum { break }  // Now uses the accumulator (in scope)
        }
        
        let totalVel = model.nodes.reduce(0.0) { $0 + $1.velocity.magnitude }
        #expect(totalVel < 2.0 * CGFloat(model.nodes.count), "Velocities near zero for seed \(seed)")
    }
    // New/Fixed: Property-based convergence test with tightened threshold and proper parameterization
    @Test func testSimulationConvergence() {
        let tolerance: CGFloat = 0.05
        let model = GraphModel(storage: MockGraphStorage(), physicsEngine: mockPhysicsEngine())
        model.nodes = [
            Node(label: 1, position: CGPoint(x: 100, y: 100), velocity: CGPoint(x: 10, y: 10)),
            Node(label: 2, position: CGPoint(x: 200, y: 200), velocity: CGPoint(x: -10, y: -10))
        ]
        model.edges = [GraphEdge(from: model.nodes[0].id, to: model.nodes[1].id)]
        
        model.startSimulation()
        for _ in 0..<Constants.Physics.maxSimulationSteps {
            var nodes = model.nodes
            var activeAccum = false
            let subSteps = 20  // Increased as suggested
            for _ in 0..<subSteps {
                let edges = model.edges
                let (updatedNodes, stepActive) = model.physicsEngine.simulationStep(nodes: nodes, edges: edges)
                nodes = updatedNodes
                activeAccum = activeAccum || stepActive
                if !stepActive { break }  // Optional early break
            }
            model.nodes = nodes
            if !activeAccum { break }
        }
        
        #expect(model.nodes[0].velocity.magnitude < 1.2 + tolerance, "Node 1 velocity converges to near-zero")
        #expect(model.nodes[1].velocity.magnitude < 1.2 + tolerance, "Node 2 velocity converges to near-zero")
    }
}

struct GestureTests {
    @Test func testDragCreatesEdge() {
        let storage = MockGraphStorage()
        let physicsEngine = GraphEditorShared.PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
        let model = GraphModel(storage: storage, physicsEngine: physicsEngine)
        
        // Setup: Clear default nodes/edges if needed, but since test assumes empty edges after adding, adjust expectations.
        // Note: GraphModel init adds defaults if empty, so to match test intent, we'll clear them here for the test.
        model.nodes = []
        model.edges = []
        model.addNode(at: CGPoint(x: 0, y: 0))
        model.addNode(at: CGPoint(x: 50, y: 50))
        #expect(model.edges.isEmpty, "No edges initially")
        
        let viewModel = GraphViewModel(model: model)
        guard let node1 = model.nodes[0] as? Node else { fatalError("Expected Node") }
        guard let node2 = model.nodes[1] as? Node else { fatalError("Expected Node") }
        
        // Mock gesture properties instead of creating Value
        let mockTranslation = CGSize(width: 50, height: 50)
        
        // Simulate onEnded logic
        let draggedNode: (any NodeProtocol)? = node1
        let potentialEdgeTarget: (any NodeProtocol)? = node2
        let dragOffset: CGPoint = CGPoint(x: mockTranslation.width / 1.0, y: mockTranslation.height / 1.0)  // Assume zoomScale=1
        
        let dragDistance = hypot(mockTranslation.width, mockTranslation.height)
        if let node = draggedNode,
           let index = viewModel.model.nodes.firstIndex(where: { $0.id == node.id }) {
            viewModel.snapshot()
            if dragDistance < AppConstants.tapThreshold {
                // Tap logic (skipped)
            } else {
                // Drag logic
                if let target = potentialEdgeTarget, target.id != node.id {
                    // Break up complex predicate
                    let fromID = node.id
                    let toID = target.id
                    let edgeExists = viewModel.model.edges.contains { edge in
                        (edge.from == fromID && edge.to == toID) ||
                        (edge.from == toID && edge.to == fromID)
                    }
                    if !edgeExists {
                        viewModel.model.edges.append(GraphEdge(from: fromID, to: toID))
                        viewModel.model.startSimulation()
                    } else {
                        // Move logic (skipped, but update to use vars)
                        viewModel.model.nodes[index].position = CGPoint(x: viewModel.model.nodes[index].position.x + dragOffset.x, y: viewModel.model.nodes[index].position.y + dragOffset.y)
                        viewModel.model.startSimulation()
                    }
                }
            }
        }
        
        // Assert: Break up the expectation
        #expect(viewModel.model.edges.count == 1, "Edge created after simulated drag")
        let newEdge = viewModel.model.edges.first
        #expect(newEdge != nil, "New edge exists")
        if let newEdge = newEdge {
            #expect(newEdge.from == node1.id, "Edge from correct node")
            #expect(newEdge.to == node2.id, "Edge to correct node")
        }
    }
}

struct AccessibilityTests {
    private func mockPhysicsEngine() -> GraphEditorShared.PhysicsEngine {
        GraphEditorShared.PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
    }
    
    @Test func testGraphDescription() {
        let storage = MockGraphStorage()
        // Preload with dummy to avoid defaults and set nextNodeLabel to 1
        storage.nodes = [Node(label: 0, position: .zero)]
        let model = GraphModel(storage: storage, physicsEngine: mockPhysicsEngine(), nextNodeLabel: 1)
        model.nodes = []  // Clear for test setup
        model.edges = []
        
        model.nextNodeLabel = 1  // Reset for consistent labeling in test
        
        model.addNode(at: .zero)  // Label 1
        model.addNode(at: CGPoint(x: 10, y: 10))  // Label 2
        model.edges.append(GraphEdge(from: model.nodes[0].id, to: model.nodes[1].id))
        
        let descNoSelect = model.graphDescription(selectedID: nil, selectedEdgeID: nil)  // Add param
        #expect(descNoSelect == "Graph with 2 nodes and 1 directed edge. No node or edge selected.", "Correct desc without selection")  // Updated expectation
        
        let descWithSelect = model.graphDescription(selectedID: model.nodes[0].id, selectedEdgeID: nil)  // Add param
        #expect(descWithSelect == "Graph with 2 nodes and 1 directed edge. Node 1 selected, outgoing to: 2; incoming from: none.", "Correct desc with selection")  // Updated expectation
    }
}
----------------------------------------------------------------------------------------------------
File: GraphEditorWatchUITests.swift
Path: GraphEditorWatchUITests/GraphEditorWatchUITests.swift
Last modified: 2025-08-09 17:07:24

Contents:
//
//  GraphEditorWatchUITests.swift
//  GraphEditorWatchUITests
//
//  Created by handcart on 8/4/25.
//

import XCTest

final class GraphEditorWatchUITests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.

        // In UI tests it is usually best to stop immediately when a failure occurs.
        continueAfterFailure = false

        // In UI tests it’s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }
    
    func testLaunch() throws {
            let app = XCUIApplication()
            app.launch()
            
            // Basic assertion: Check if the app launches without crashing
            XCTAssertTrue(app.exists, "App should launch successfully")
        }
    
    func testDragToCreateEdge() throws {
        let app = XCUIApplication()
        app.launch()

        let canvas = app.otherElements["GraphCanvas"]  // Assumes accessibilityIdentifier set on GraphCanvasView
        XCTAssertTrue(canvas.waitForExistence(timeout: 5), "Graph canvas should appear")

        // Assume default nodes: Adjust start/end based on positions (e.g., node0 at (100,100), node1 at (200,200))
        let startPoint = CGVector(dx: 0.3, dy: 0.3)  // Near node0
        let endPoint = CGVector(dx: 0.6, dy: 0.6)    // Near node1

        let dragStart = canvas.coordinate(withNormalizedOffset: startPoint)
        let dragEnd = canvas.coordinate(withNormalizedOffset: endPoint)
        dragStart.press(forDuration: 0.1, thenDragTo: dragEnd)

        // Assert: Updated label reflects directed edge (e.g., "Graph with 3 nodes and 4 directed edges." and mentions direction)
        let updatedLabel = app.staticTexts["Graph with 3 nodes and 4 directed edges. No node selected."]  // Adjust based on post-drag (add "directed")
        XCTAssertTrue(updatedLabel.waitForExistence(timeout: 2), "Directed edge created, updating graph description")

        // Optional: Select the from-node and check description mentions "outgoing to" the to-node
        // Simulate tap on startPoint to select, then check label includes "outgoing to: <label>"
    }
    
    func testUndoAfterAddNode() throws {
            let app = XCUIApplication()
            app.launch()
            
            let canvas = app.otherElements["GraphCanvas"]  // Assume identifier set
            XCTAssertTrue(canvas.waitForExistence(timeout: 5))
            
            // Simulate add node: Assume menu button "Add Node" exists
            app.buttons["Show Menu"].tap()  // Or long press if using gestures
            app.buttons["Add Node"].tap()
            
            // Assert: Graph description updates (e.g., nodes increase)
            let updatedLabel = app.staticTexts["Graph with 4 nodes"]  // Adjust based on defaults +1
            XCTAssertTrue(updatedLabel.waitForExistence(timeout: 2), "Node added")
            
            // Undo via button
            app.buttons["Undo"].tap()  // Assume undo button in menu or UI
            let revertedLabel = app.staticTexts["Graph with 3 nodes"]  // Back to defaults
            XCTAssertTrue(revertedLabel.waitForExistence(timeout: 2), "Undo reverts add")
        }
        
        func testMenuDisplayAndAction() throws {
            let app = XCUIApplication()
            app.launch()
            
            let canvas = app.otherElements["GraphCanvas"]
            XCTAssertTrue(canvas.waitForExistence(timeout: 5))
            
            // Long press to show menu (if using sheet)
            canvas.coordinate(withNormalizedOffset: CGVector(dx: 0.5, dy: 0.5)).press(forDuration: 1.0)
            
            // Assert menu appears with buttons
            let addButton = app.buttons["Add Node"]
            XCTAssertTrue(addButton.waitForExistence(timeout: 2), "Menu shows with actions")
            
            addButton.tap()
            // Assert action effect (e.g., via label)
            let updatedLabel = app.staticTexts["Graph with 4 nodes"]
            XCTAssertTrue(updatedLabel.waitForExistence(timeout: 2), "Menu action adds node")
        }
    
    // New: Test for digital crown zooming (using proxy button; manual test crown in simulator)
    func testDigitalCrownZooming() throws {
        let app = XCUIApplication()
        app.launch()
        
        let canvas = app.otherElements["GraphCanvas"]  // Assume identifier set
        XCTAssertTrue(canvas.waitForExistence(timeout: 5))
        
        // Simulate crown via menu button (add "Zoom In" to menu if not present)
        app.buttons["Show Menu"].tap()
        app.buttons["Zoom In"].tap()  // Proxy for crown rotation; adjust if button named differently
        
        // Assert: Check if description or visible elements change (e.g., more details visible)
        let zoomedLabel = app.staticTexts["Graph with 3 nodes"]  // Adjust to match post-zoom (e.g., if zoom reveals more)
        XCTAssertTrue(zoomedLabel.waitForExistence(timeout: 2), "Zoom updates view")
    }
    
    
    @MainActor
    func testExample() throws {
        // UI tests must launch the application that they test.
        let app = XCUIApplication()
        app.launch()

        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    @MainActor
    func testLaunchPerformance() throws {
        // This measures how long it takes to launch your application.
        measure(metrics: [XCTApplicationLaunchMetric()]) {
            XCUIApplication().launch()
        }
    }
}
--------------------------------------------------
