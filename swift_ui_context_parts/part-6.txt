## Focused Project Concatenation
This file includes only UI, interactivity, model, and core logic files.
Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
Current date: 2025-10-02 11:37:11
Table of Contents:
1. GraphEditorWatchTests/EditContentSheetTests.swift
2. GraphEditorWatchTests/GestureTests.swift
3. GraphEditorWatchTests/GraphEditorWatchTests.swift
4. GraphEditorWatchTests/GraphGesturesModifierTests.swift
5. GraphEditorWatchTests/GraphModelTests.swift
6. GraphEditorWatchTests/MenuViewTests.swift
7. GraphEditorWatchUITests/GraphEditorWatchUITests.swift
8. GraphEditorWatchUITests/GraphEditorWatchUITestsLaunchTests.swift--------------------------------------------------
File: EditContentSheetTests.swift
Path: GraphEditorWatchTests/EditContentSheetTests.swift
Last modified: 2025-09-25 14:25:51

Contents:
//
//  EditContentSheetTests.swift
//  GraphEditor
//
//  Created by handcart on 9/25/25.
//
import Testing
import SwiftUI
@testable import GraphEditorWatch
@testable import GraphEditorShared

struct EditContentSheetTests {
    private func setupViewModel() async -> GraphViewModel {
        let storage = MockGraphStorage()
        let physicsEngine = PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
        let model = await GraphModel(storage: storage, physicsEngine: physicsEngine)
        return await GraphViewModel(model: model)
    }
    
    @Test func testSaveStringContent() async {
        let viewModel = await setupViewModel()
        let nodeID = NodeID()
        var savedContent: NodeContent?
        let sheet = EditContentSheet(selectedID: nodeID, viewModel: viewModel) { content in
            savedContent = content
        }
        // Simulate input: Since @State is private, this is placeholder; use XCUITest for full simulation or expose states for testing
        // For example, assume manual set: sheet.selectedType = "String"; sheet.stringValue = "test"; then call onSave
        // Placeholder assertion (adapt based on actual simulation logic)
        _ = sheet  // Use to silence warning
        #expect(savedContent == nil, "Initially nil; add simulation to set .string(\"test\")")
    }
}
----------------------------------------------------------------------------------------------------
File: GestureTests.swift
Path: GraphEditorWatchTests/GestureTests.swift
Last modified: 2025-09-28 19:03:45

Contents:
//
//  GestureTests.swift
//  GraphEditor
//
//  Created by handcart on 9/22/25.
//
import Testing
import Foundation
import CoreGraphics
@testable import GraphEditorWatch
@testable import GraphEditorShared
import XCTest
import SwiftUI

struct GestureTests {
    private func setupModel() async -> GraphModel {
        let storage = MockGraphStorage()
        let physicsEngine = GraphEditorShared.PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
        let model = await GraphModel(storage: storage, physicsEngine: physicsEngine)
        await MainActor.run { model.nodes = [] }
        await MainActor.run { model.edges = [] }
        await model.addNode(at: CGPoint(x: 0, y: 0))
        await model.addNode(at: CGPoint(x: 50, y: 50))
        return model
    }
    
    @Test func testDragCreatesEdge() async throws {
        let model = await setupModel()
        #expect((await model.edges).isEmpty, "No edges initially")
        
        let viewModel = await GraphViewModel(model: model)
        let draggedNode = await model.nodes[0]
        let potentialEdgeTarget = await model.nodes[1]
        let initialPosition = draggedNode.position
        
        let mockTranslation = CGSize(width: 50, height: 50)
        let dragOffset = CGPoint(x: mockTranslation.width / 1.0, y: mockTranslation.height / 1.0)
        let dragDistance = hypot(mockTranslation.width, mockTranslation.height)
        
        if let index = (await viewModel.model.nodes).firstIndex(where: { $0.id == draggedNode.id }) {
            await viewModel.model.snapshot()
            if dragDistance < AppConstants.tapThreshold {
                // Tap logic (skipped)
            } else {
                if potentialEdgeTarget.id != draggedNode.id {
                    let fromID = draggedNode.id
                    let toID = potentialEdgeTarget.id
                    let edgeExists = await MainActor.run {
                        let edges = viewModel.model.edges  // No await needed here if already on MainActor
                        let forwardMatch = edges.contains { $0.from == fromID && $0.target == toID }
                        let reverseMatch = edges.contains { $0.from == toID && $0.target == fromID }
                        return forwardMatch || reverseMatch
                    }
                    if !edgeExists {
                        await MainActor.run { viewModel.model.edges.append(GraphEdge(from: fromID, target: toID)) }
                        await viewModel.model.startSimulation()
                    } else {
                        await MainActor.run {
                            let currentPos = viewModel.model.nodes[index].position
                            viewModel.model.nodes[index] = viewModel.model.nodes[index].with(position: CGPoint(x: currentPos.x + dragOffset.x, y: currentPos.y + dragOffset.y), velocity: .zero)
                        }
                        await viewModel.model.startSimulation()
                    }
                }
            }
        }
        
        #expect((await viewModel.model.edges).count == 1, "Edge created after simulated drag")
        let newEdge = (await viewModel.model.edges).first!
        #expect(newEdge.from == draggedNode.id, "Edge from correct node")
        #expect(newEdge.target == potentialEdgeTarget.id, "Edge to correct node")
        #expect(approximatelyEqual((await model.nodes[0]).position, initialPosition, accuracy: 1e-5), "Position unchanged on create")
    }
    
    @Test func testShortDragAsTap() async throws {
        let model = await setupModel()
        #expect((await model.edges).isEmpty, "No edges initially")
        
        let viewModel = await GraphViewModel(model: model)
        let draggedNode = await model.nodes[0]
        let initialPosition = draggedNode.position
        let initialEdgeCount = (await model.edges).count
        
        let mockTranslation = CGSize(width: 1, height: 1)  // Small, < tapThreshold
        let dragDistance = hypot(mockTranslation.width, mockTranslation.height)
        
        if let index = (await viewModel.model.nodes).firstIndex(where: { $0.id == draggedNode.id }) {
            _ = index  // Silence unused warning
            await viewModel.model.snapshot()
            if dragDistance < AppConstants.tapThreshold {
                // Tap logic (skipped; assume no side effects for this test)
            } else {
                // Drag branch skipped due to small distance
            }
        }
        
        #expect((await model.edges).count == initialEdgeCount, "No edge created on short drag")
        #expect(approximatelyEqual((await model.nodes[0]).position, initialPosition, accuracy: 1e-5), "Position unchanged")
    }
    
    @Test func testDragMovesNodeIfEdgeExists() async throws {
        let model = await setupModel()
        let fromID = (await model.nodes[0]).id
        let toID = (await model.nodes[1]).id
        await MainActor.run { model.edges.append(GraphEdge(from: fromID, target: toID)) }
        #expect((await model.edges).count == 1, "Edge exists initially")
        
        let viewModel = await GraphViewModel(model: model)
        let draggedNode = await model.nodes[0]
        let potentialEdgeTarget = await model.nodes[1]
        let initialPosition = draggedNode.position
        
        let mockTranslation = CGSize(width: 50, height: 50)
        let dragOffset = CGPoint(x: mockTranslation.width / 1.0, y: mockTranslation.height / 1.0)
        let dragDistance = hypot(mockTranslation.width, mockTranslation.height)
        
        if let index = (await viewModel.model.nodes).firstIndex(where: { $0.id == draggedNode.id }) {
            await viewModel.model.snapshot()
            if dragDistance < AppConstants.tapThreshold {
                // Tap logic (skipped)
            } else {
                if potentialEdgeTarget.id != draggedNode.id {
                    let fromID = draggedNode.id
                    let toID = potentialEdgeTarget.id
                    let edgeExists = await MainActor.run {
                        let edges = viewModel.model.edges
                        let forwardMatch = edges.contains { $0.from == fromID && $0.target == toID }
                        let reverseMatch = edges.contains { $0.from == toID && $0.target == fromID }
                        return forwardMatch || reverseMatch
                    }
                    if !edgeExists {
                        await MainActor.run { viewModel.model.edges.append(GraphEdge(from: fromID, target: toID)) }
                        await viewModel.model.startSimulation()
                    } else {
                        await MainActor.run {
                            let currentPos = viewModel.model.nodes[index].position
                            viewModel.model.nodes[index] = viewModel.model.nodes[index].with(position: CGPoint(x: currentPos.x + dragOffset.x, y: currentPos.y + dragOffset.y), velocity: .zero)
                        }
                        // NEW: Check position immediately after move, before simulation
                        #expect(!approximatelyEqual((await model.nodes[0]).position, initialPosition, accuracy: 1e-5), "Position changed on move")
                        #expect(approximatelyEqual((await model.nodes[0]).position, initialPosition + dragOffset, accuracy: 1e-5), "Moved by offset")
                        await viewModel.model.startSimulation()  // Keep this if needed for side effects, but checks are now before it
                    }
                }
            }
        }
        
        #expect((await viewModel.model.edges).count == 1, "No new edge created")
        // OPTIONAL: If you want to verify post-simulation (e.g., position changed but not exactly by offset), add looser checks here
    }
}
----------------------------------------------------------------------------------------------------
File: GraphEditorWatchTests.swift
Path: GraphEditorWatchTests/GraphEditorWatchTests.swift
Last modified: 2025-09-23 11:52:21

Contents:
import Testing
import Foundation
import CoreGraphics
@testable import GraphEditorWatch
@testable import GraphEditorShared
import XCTest
import SwiftUI

class MockGraphStorage: GraphStorage {
    var nodes: [any NodeProtocol] = []
    var edges: [GraphEdge] = []
    var savedViewState: ViewState? 
    
    func save(nodes: [any NodeProtocol], edges: [GraphEdge]) throws {
        self.nodes = nodes
        self.edges = edges
    }
    
    func load() throws -> (nodes: [any NodeProtocol], edges: [GraphEdge]) {
        (nodes, edges)
    }
    
    func clear() throws {
        nodes = []
        edges = []
    }
    
    func saveViewState(_ viewState: ViewState) async throws {
            savedViewState = viewState
        }
        
        func loadViewState() async throws -> ViewState? {
            savedViewState
        }
}

func approximatelyEqual(_ lhs: CGPoint, _ rhs: CGPoint, accuracy: CGFloat) -> Bool {
    return hypot(lhs.x - rhs.x, lhs.y - rhs.y) < accuracy
}
----------------------------------------------------------------------------------------------------
File: GraphGesturesModifierTests.swift
Path: GraphEditorWatchTests/GraphGesturesModifierTests.swift
Last modified: 2025-09-30 11:37:51

Contents:
//
//  GraphGesturesModifierTests.swift
//  GraphEditorWatch
//
//  Created by handcart on 9/25/25.
//
import Testing
import SwiftUI
@testable import GraphEditorWatch
@testable import GraphEditorShared

struct GraphGesturesModifierTests {
    private func setupViewModel() async -> GraphViewModel {
        let storage = MockGraphStorage()
        let physicsEngine = PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
        let model = await GraphModel(storage: storage, physicsEngine: physicsEngine)
        return await GraphViewModel(model: model)
    }
    
    private func createModifier(viewModel: GraphViewModel,
                                selectedNodeID: Binding<NodeID?>,
                                selectedEdgeID: Binding<UUID?>) -> GraphGesturesModifier {
        GraphGesturesModifier(
            viewModel: viewModel,
            zoomScale: .constant(1.0),
            offset: .constant(.zero),
            draggedNode: .constant(nil),
            dragOffset: .constant(.zero),
            potentialEdgeTarget: .constant(nil),
            selectedNodeID: selectedNodeID,
            selectedEdgeID: selectedEdgeID,
            viewSize: CGSize(width: 300, height: 300),
            panStartOffset: .constant(nil),
            showMenu: .constant(false),
            maxZoom: 5.0,
            crownPosition: .constant(0.0),
            onUpdateZoomRanges: {},
            isAddingEdge: .constant(false)
        )
    }
    
    @MainActor @Test func testHitTestNodesInScreenSpace() async {
        let viewModel = await setupViewModel()
        _ = createModifier(viewModel: viewModel,
                                      selectedNodeID: .constant(nil),
                                      selectedEdgeID: .constant(nil))
        
        let nodes = [AnyNode(Node(label: 1, position: CGPoint(x: 100, y: 100)))]
        let context = GestureContext(zoomScale: 1.0, offset: CGSize.zero, viewSize: CGSize(width: 300, height: 300), effectiveCentroid: CGPoint.zero)
        // Compute screen pos: viewCenter (150,150) + zoom * (model - centroid) + offset = (150,150) + 1*(100-0,100-0) + (0,0) = (250,250)
        let screenTapPos = CGPoint(x: 250, y: 250)
        let hitContext = HitTestContext(zoomScale: context.zoomScale, offset: context.offset, viewSize: context.viewSize, effectiveCentroid: context.effectiveCentroid)
        let hitNode = HitTestHelper.closestNode(at: screenTapPos, visibleNodes: nodes, context: hitContext)
        #expect(hitNode != nil, "Should hit node within radius")
    }
    
    @Test func testPointToLineDistance() async {
        let viewModel = await setupViewModel()
        let modifier = createModifier(viewModel: viewModel,
                                      selectedNodeID: .constant(nil),
                                      selectedEdgeID: .constant(nil))
        let dist = await MainActor.run {
            modifier.pointToLineDistance(point: CGPoint(x: 0, y: 1), from: CGPoint.zero, endPoint: CGPoint(x: 2, y: 0))
        }
        #expect(dist == 1.0, "Perpendicular distance to line")
    }
    
    @Test func testHandleTap() async {
        let viewModel = await setupViewModel()
        var testSelectedNodeID: NodeID?
        var testSelectedEdgeID: UUID?
        let selectedNodeBinding = Binding<NodeID?>(
            get: { testSelectedNodeID },
            set: { testSelectedNodeID = $0 }
        )
        let selectedEdgeBinding = Binding<UUID?>(
            get: { testSelectedEdgeID },
            set: { testSelectedEdgeID = $0 }
        )
        let modifier = createModifier(viewModel: viewModel,
                                      selectedNodeID: selectedNodeBinding,
                                      selectedEdgeID: selectedEdgeBinding)
        let nodes = [AnyNode(Node(label: 1, position: CGPoint.zero))]
        let edges = [GraphEdge(from: nodes[0].id, target: nodes[0].id)]  // Self-edge for test
        let context = GestureContext(zoomScale: 1.0, offset: CGSize.zero, viewSize: CGSize(width: 300, height: 300), effectiveCentroid: CGPoint.zero)
        
        // Compute screen pos for model .zero: (150,150) + 1*(0-0,0-0) + (0,0) = (150,150)
        let screenTapPos = CGPoint(x: 150, y: 150)
        _ = await MainActor.run {
            modifier.handleTap(at: screenTapPos, visibleNodes: nodes, visibleEdges: edges, context: context)
        }
        // Assert on mocked bindings
        #expect(testSelectedNodeID != nil, "Node should be selected after tap")
        #expect(testSelectedEdgeID == nil, "No edge selected")
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModelTests.swift
Path: GraphEditorWatchTests/GraphModelTests.swift
Last modified: 2025-09-30 13:30:21

Contents:
//
//  GraphModelTests.swift
//  GraphEditor
//
//  Created by handcart on 9/22/25.
//
//
//  GraphModelTests.swift
//  GraphEditor
//
//  Created by handcart on 9/22/25.
//
import Testing
import Foundation
import CoreGraphics
@testable import GraphEditorWatch
@testable import GraphEditorShared
import XCTest
import SwiftUI

struct GraphModelTests {
    private func mockPhysicsEngine() -> GraphEditorShared.PhysicsEngine {
        GraphEditorShared.PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
    }
    
    private func setupDefaults(for storage: MockGraphStorage) throws {
        let node1 = AnyNode(Node(label: 1, position: CGPoint(x: 100, y: 100)))
        let node2 = AnyNode(Node(label: 2, position: CGPoint(x: 200, y: 200)))
        let node3 = AnyNode(Node(label: 3, position: CGPoint(x: 150, y: 150)))
        let edge1 = GraphEdge(from: node1.id, target: node2.id)
        let edge2 = GraphEdge(from: node2.id, target: node3.id)
        let edge3 = GraphEdge(from: node3.id, target: node1.id)
        try storage.save(nodes: [node1, node2, node3], edges: [edge1, edge2, edge3])
    }
    
    private func generateNodesAndEdges(seed: Int) async -> ([AnyNode], [GraphEdge]) {
        struct SeededRandomNumberGenerator: RandomNumberGenerator {
            private var state: UInt64
            init(seed: UInt64) {
                state = seed
            }
            mutating func next() -> UInt64 {
                state &+= 1442695040888963407
                state &*= 6364136223846793005
                return state
            }
        }
        var rng = SeededRandomNumberGenerator(seed: UInt64(seed))
        var nodesToAssign: [AnyNode] = []
        for _ in 0..<5 {
            let label = Int.random(in: 0..<10, using: &rng)
            let positionX = CGFloat.random(in: 0..<300, using: &rng)
            let positionY = CGFloat.random(in: 0..<300, using: &rng)
            nodesToAssign.append(AnyNode(Node(label: label, position: CGPoint(x: positionX, y: positionY))))
        }
        var edgesToAssign: [GraphEdge] = []
        for _ in 0..<3 {
            let fromIndex = Int.random(in: 0..<nodesToAssign.count, using: &rng)
            let targetIndex = Int.random(in: 0..<nodesToAssign.count, using: &rng)
            edgesToAssign.append(GraphEdge(from: nodesToAssign[fromIndex].id, target: nodesToAssign[targetIndex].id))
        }
        return (nodesToAssign, edgesToAssign)
    }
    
    private func runSimulation(on model: GraphModel, subStepsPerIteration: Int = 20) async {
        await model.startSimulation()
        for _ in 0..<Constants.Physics.maxSimulationSteps {
            var nodes = await model.nodes
            var activeAccum = false
            for _ in 0..<subStepsPerIteration {
                let currentNodes = nodes.map { $0.unwrapped }
                let physics = await model.physicsEngine
                let edges = await model.edges
                let (updatedNodes, stepActive) = physics.simulationStep(nodes: currentNodes, edges: edges)
                nodes = updatedNodes.map(AnyNode.init)
                activeAccum = activeAccum || stepActive
                if !stepActive { break }
            }
            let updatedNodesForMain = nodes
            await MainActor.run { model.nodes = updatedNodesForMain }
            if !activeAccum { break }
        }
    }
    
    @Test(arguments: 1..<5) func testConvergencePropertyBased(seed: Int) async throws {
        let storage = MockGraphStorage()
        let model = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        await model.load()
        let (nodesToAssign, edgesToAssign) = await generateNodesAndEdges(seed: seed)
        await MainActor.run {
            model.nodes = nodesToAssign
            model.edges = edgesToAssign
        }
        await runSimulation(on: model)
        let totalVel = (await model.nodes).reduce(0.0) { $0 + $1.velocity.magnitude }
        let nodeCount = await MainActor.run { model.nodes.count }
        #expect(totalVel < 2.0 * CGFloat(nodeCount), "Velocities near zero for seed \(seed)")
    }
    
    @Test func testSimulationConvergence() async {
        let tolerance: CGFloat = 0.05
        let storage = MockGraphStorage()
        let model = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        await model.load()
        await MainActor.run {
            model.nodes = [
                AnyNode(Node(label: 1, position: CGPoint(x: 100, y: 100), velocity: CGPoint(x: 10, y: 10))),
                AnyNode(Node(label: 2, position: CGPoint(x: 200, y: 200), velocity: CGPoint(x: -10, y: -10)))
            ]
            model.edges = [GraphEdge(from: model.nodes[0].id, target: model.nodes[1].id)]
        }
        await runSimulation(on: model)
        #expect((await model.nodes[0]).velocity.magnitude < 1.2 + tolerance, "Node 1 velocity converges to near-zero")
        #expect((await model.nodes[1]).velocity.magnitude < 1.2 + tolerance, "Node 2 velocity converges to near-zero")
    }
    
    @Test func testUndoRedoMixedOperations() async throws {
        let storage = MockGraphStorage()
        try setupDefaults(for: storage)
        let model = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        await model.load()
        await runSimulation(on: model)
        let initialNodeCount = await MainActor.run { model.nodes.count }
        let initialEdgeCount = await MainActor.run { model.edges.count }
        let initialNodes = await model.nodes
        try #require(!initialNodes.isEmpty, "Assumes initial nodes exist")
        await model.snapshot()
        let nodeToDelete = initialNodes[0].id
        let initialEdges = await model.edges
        let connectedEdges = initialEdges.filter { $0.from == nodeToDelete || $0.target == nodeToDelete }.count
        await model.deleteNode(withID: nodeToDelete)
        await runSimulation(on: model)
        await model.snapshot()
        await model.addNode(at: CGPoint.zero)
        await runSimulation(on: model)
        await model.snapshot()  // FIX: Commit post-add state
        #expect(await MainActor.run { model.nodes.count } == initialNodeCount, "After add: count back to initial")
        #expect(await MainActor.run { model.edges.count } == initialEdgeCount - connectedEdges, "Edges reduced by connected count")
        await model.undo() // To post-delete
        #expect(await MainActor.run { model.nodes.count } == initialNodeCount - 1, "Undo reverts to post-delete")
        #expect(await MainActor.run { model.edges.count } == initialEdgeCount - connectedEdges, "Edges match post-delete")
        await model.undo() // To initial
        #expect(await MainActor.run { model.nodes.count } == initialNodeCount, "Second undo restores initial")
        #expect(await MainActor.run { model.edges.count } == initialEdgeCount, "Edges restored")
        let restoredNodes = await model.nodes
        #expect(zip(restoredNodes.sorted(by: { $0.id.uuidString < $1.id.uuidString }), initialNodes.sorted(by: { $0.id.uuidString < $1.id.uuidString })).allSatisfy { approximatelyEqual($0.position, $1.position, accuracy: 1e-5) && approximatelyEqual($0.velocity, $1.velocity, accuracy: 1e-5) }, "Positions and velocities restored")
        await model.redo() // To post-delete
        #expect((await model.nodes).count == initialNodeCount - 1, "Redo applies delete")
        await model.redo() // To post-add
        #expect((await model.nodes).count == initialNodeCount, "Redo applies add")
    }
    
    @Test func testInitializationWithDefaults() async throws {
        let storage = MockGraphStorage()
        try setupDefaults(for: storage)
        let model = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        await model.load()
        #expect(await MainActor.run { model.nodes.count } >= 3, "Should load default or saved nodes")
        #expect(await MainActor.run { model.edges.count } >= 3, "Should load default edges")
    }
    
    @Test func testDeleteNodeAndEdges() async throws {
        let storage = MockGraphStorage()
        try setupDefaults(for: storage)
        let model = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        await model.load()
        let nodes = await model.nodes
        try #require(!nodes.isEmpty, "Assumes default nodes exist")
        let nodeToDelete = nodes[0].id
        let initialEdgeCount = await model.edges.count
        let connectedEdges = (await model.edges).filter { $0.from == nodeToDelete || $0.target == nodeToDelete }.count
        await model.deleteNode(withID: nodeToDelete)
        #expect(await MainActor.run { model.nodes.count } == nodes.count - 1, "Node deleted")
        #expect(await MainActor.run { model.edges.count } == initialEdgeCount - connectedEdges, "Connected edges deleted")
    }
    
    @Test func testSaveLoadRoundTrip() async throws {
        let storage = MockGraphStorage()
        try setupDefaults(for: storage)
        let model = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        await model.load()
        let originalNodeCount = await MainActor.run { model.nodes.count }
        let originalEdges = await model.edges
        await model.addNode(at: CGPoint.zero)
        await runSimulation(on: model)
        let postAddNodes = await model.nodes  // Capture after add and simulation
        await model.snapshot()  // Triggers save() with stabilized positions
        let newModel = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        await newModel.load()
        // Skip runSimulation(on: newModel) - loaded positions should match saved exactly; re-sim amplifies FP errors
        #expect(await MainActor.run { newModel.nodes.count } == originalNodeCount + 1, "Loaded nodes include added one")
        #expect(await newModel.edges == originalEdges, "Edges unchanged")
        let loadedNodes = (await newModel.nodes).sorted(by: { $0.id.uuidString < $1.id.uuidString })
        let expectedNodes = postAddNodes.sorted(by: { $0.id.uuidString < $1.id.uuidString })
        #expect(zip(loadedNodes, expectedNodes).allSatisfy {
            $0.label == $1.label && approximatelyEqual($0.position, $1.position, accuracy: 1e-2)  // Further relaxed for any JSON/FP rounding
        }, "Loaded nodes match expected")
    }
     
}
----------------------------------------------------------------------------------------------------
File: MenuViewTests.swift
Path: GraphEditorWatchTests/MenuViewTests.swift
Last modified: 2025-09-25 14:19:07

Contents:
//
//  MenuViewTests.swift
//  GraphEditor
//
//  Created by handcart on 9/25/25.
//
import Testing
import SwiftUI
@testable import GraphEditorWatch
@testable import GraphEditorShared

struct MenuViewTests {
    private func setupViewModel() async -> GraphViewModel {
        let storage = MockGraphStorage()
        let physicsEngine = PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
        let model = await GraphModel(storage: storage, physicsEngine: physicsEngine)
        return await GraphViewModel(model: model)
    }

    @Test func testEditSectionDeleteNode() async {
        let viewModel = await setupViewModel()
        let node = AnyNode(Node(label: 1, position: .zero))
        await MainActor.run { viewModel.model.nodes = [node] }
        _ = EditSection(viewModel: viewModel, selectedNodeID: node.id, selectedEdgeID: nil, onDismiss: {}, onEditNode: {})
        
        // Simulate button tap (manual test logic; for full UI test, use XCUITest)
        await viewModel.deleteNode(withID: node.id)
        #expect(await viewModel.model.nodes.isEmpty, "Node deleted")
    }
}
----------------------------------------------------------------------------------------------------
File: GraphEditorWatchUITests.swift
Path: GraphEditorWatchUITests/GraphEditorWatchUITests.swift
Last modified: 2025-10-02 11:33:23

Contents:
//
//  GraphEditorWatchUITests.swift
//  GraphEditorWatchUITests
//
//  Created by handcart on 8/4/25.
//

import XCTest

final class GraphEditorWatchUITests: XCTestCase {
    
    override func setUpWithError() throws {
        continueAfterFailure = false
    }
    
    override func tearDownWithError() throws {}
    
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()
        
        XCTAssertTrue(app.exists, "App should launch successfully")
    }
    
    func testDragToCreateEdge() throws {
        let app = XCUIApplication()
        app.launch()

        let canvas = app.otherElements["GraphCanvas"]
        XCTAssertTrue(canvas.waitForExistence(timeout: 5), "Graph canvas should appear")

        // Open menu and add two nodes
        let menuButton = app.buttons["Menu"]
        XCTAssertTrue(menuButton.waitForExistence(timeout: 5), "Menu button should appear")
        menuButton.tap()
        let addNodeButton = app.buttons["Add"]
        XCTAssertTrue(addNodeButton.waitForExistence(timeout: 5), "Add button should appear")
        addNodeButton.tap()
        sleep(2)
        menuButton.tap()
        addNodeButton.tap()
        sleep(2)

        // Pre-tap start to ensure hit/select
        let startPoint = canvas.coordinate(withNormalizedOffset: CGVector(dx: 0.5, dy: 0.4))  // Center-top
        startPoint.tap()
        let endPoint = canvas.coordinate(withNormalizedOffset: CGVector(dx: 0.5, dy: 0.6))  // Center-bottom
        startPoint.press(forDuration: 0.2, thenDragTo: endPoint)
        sleep(2)

        // Check updated label
        let expectedLabel = "Graph with 5 nodes and 4 edges. No node or edge selected."
        let predicate = NSPredicate(format: "label == %@", expectedLabel)
        let expectation = self.expectation(for: predicate, evaluatedWith: canvas)
        let result = XCTWaiter.wait(for: [expectation], timeout: 10.0)
        XCTAssert(result == .completed, "Directed edge created, updating graph description")
    }

    func testUndoAfterAddNode() throws {
        let app = XCUIApplication()
        app.launch()
        
        let canvas = app.otherElements["GraphCanvas"]
        XCTAssertTrue(canvas.waitForExistence(timeout: 5))
        
        // Open menu and add node
        let menuButton = app.buttons["Menu"]
        menuButton.tap()
        let addNodeButton = app.buttons["Add"]
        addNodeButton.tap()
        sleep(2)
        
        // Check added
        let addedLabel = "Graph with 4 nodes and 3 edges. No node or edge selected."
        let addedPredicate = NSPredicate(format: "label == %@", addedLabel)
        let addedExpectation = self.expectation(for: addedPredicate, evaluatedWith: canvas)
        let addedResult = XCTWaiter.wait(for: [addedExpectation], timeout: 10.0)
        XCTAssert(addedResult == .completed, "Node added")
        
        // Open menu and undo
        menuButton.tap()
        let undoButton = app.buttons["Undo"]
        XCTAssertTrue(undoButton.waitForExistence(timeout: 5), "Undo button should appear")
        undoButton.tap()
        sleep(2)
        
        // Check reverted
        let revertedLabel = "Graph with 3 nodes and 3 edges. No node or edge selected."
        let revertedPredicate = NSPredicate(format: "label == %@", revertedLabel)
        let revertedExpectation = self.expectation(for: revertedPredicate, evaluatedWith: canvas)
        let revertedResult = XCTWaiter.wait(for: [revertedExpectation], timeout: 10.0)
        XCTAssert(revertedResult == .completed, "Undo reverts add")
    }

    func testMenuDisplayAndAction() throws {
        let app = XCUIApplication()
        app.launch()
        
        let canvas = app.otherElements["GraphCanvas"]
        XCTAssertTrue(canvas.waitForExistence(timeout: 5))
        
        // Tap menu button
        let menuButton = app.buttons["Menu"]
        XCTAssertTrue(menuButton.waitForExistence(timeout: 5), "Menu button should appear")
        menuButton.tap()
        
        // Check add button in menu
        let addButton = app.buttons["Add"]
        XCTAssertTrue(addButton.waitForExistence(timeout: 5), "Menu shows with actions")
        
        addButton.tap()
        sleep(2)
        
        // Check updated label
        let updatedLabel = "Graph with 4 nodes and 3 edges. No node or edge selected."
        let predicate = NSPredicate(format: "label == %@", updatedLabel)
        let expectation = self.expectation(for: predicate, evaluatedWith: canvas)
        let result = XCTWaiter.wait(for: [expectation], timeout: 10.0)
        XCTAssert(result == .completed, "Menu action adds node")
    }

    func testDigitalCrownZooming() throws {
        let app = XCUIApplication()
        app.launch()
        
        let canvas = app.otherElements["GraphCanvas"]
        XCTAssertTrue(canvas.waitForExistence(timeout: 5))
        
        XCUIDevice.shared.rotateDigitalCrown(delta: 5.0, velocity: 1.0)  // Zoom in
        sleep(2)
        
        // Check label unchanged post-zoom
        let zoomedLabel = "Graph with 3 nodes and 3 edges. No node or edge selected."
        let predicate = NSPredicate(format: "label == %@", zoomedLabel)
        let expectation = self.expectation(for: predicate, evaluatedWith: canvas)
        let result = XCTWaiter.wait(for: [expectation], timeout: 10.0)
        XCTAssert(result == .completed, "Zoom updates view")
    }
    
    @MainActor
    func testExample() throws {
        let app = XCUIApplication()
        app.launch()
    }
    
    @MainActor
    func testLaunchPerformance() throws {
        measure(metrics: [XCTApplicationLaunchMetric()]) {
            XCUIApplication().launch()
        }
    }
}
----------------------------------------------------------------------------------------------------
File: GraphEditorWatchUITestsLaunchTests.swift
Path: GraphEditorWatchUITests/GraphEditorWatchUITestsLaunchTests.swift
Last modified: 2025-09-19 13:15:40

Contents:
//
//  GraphEditorWatchUITestsLaunchTests.swift
//  GraphEditorWatchUITests
//
//  Created by handcart on 8/4/25.
//

import XCTest

final class GraphEditorWatchUITestsLaunchTests: XCTestCase {

    override static var runsForEachTargetApplicationUIConfiguration: Bool {
        true
    }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    @MainActor
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        // Insert steps here to perform after app launch but before taking a screenshot,
        // such as logging into a test account or navigating somewhere in the app

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = "Launch Screen"
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}
--------------------------------------------------
