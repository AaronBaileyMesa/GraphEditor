## Focused Project Concatenation
This file includes only UI, interactivity, model, and core logic files.
Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
Current date: 2025-09-22 11:48:28
Table of Contents:
1. GraphEditorWatchTests/GestureTests.swift
2. GraphEditorWatchTests/GraphEditorWatchTests.swift
3. GraphEditorWatchTests/GraphModelTests.swift
4. GraphEditorWatchUITests/GraphEditorWatchUITests.swift
5. GraphEditorWatchUITests/GraphEditorWatchUITestsLaunchTests.swift--------------------------------------------------
File: GestureTests.swift
Path: GraphEditorWatchTests/GestureTests.swift
Last modified: 2025-09-22 11:21:14

Contents:
//
//  GestureTests.swift
//  GraphEditor
//
//  Created by handcart on 9/22/25.
//
import Testing
import Foundation
import CoreGraphics
@testable import GraphEditorWatch
@testable import GraphEditorShared
import XCTest
import SwiftUI

struct GestureTests {
    private func setupModel() async -> GraphModel {
        let storage = MockGraphStorage()
        let physicsEngine = GraphEditorShared.PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
        let model = await GraphModel(storage: storage, physicsEngine: physicsEngine)
        await MainActor.run { model.nodes = [] }
        await MainActor.run { model.edges = [] }
        await model.addNode(at: CGPoint(x: 0, y: 0))
        await model.addNode(at: CGPoint(x: 50, y: 50))
        return model
    }
    
    @Test func testDragCreatesEdge() async throws {
        let model = await setupModel()
        #expect((await model.edges).isEmpty, "No edges initially")
        
        let viewModel = await GraphViewModel(model: model)
        let draggedNode = await model.nodes[0]
        let potentialEdgeTarget = await model.nodes[1]
        let initialPosition = draggedNode.position
        
        let mockTranslation = CGSize(width: 50, height: 50)
        let dragOffset = CGPoint(x: mockTranslation.width / 1.0, y: mockTranslation.height / 1.0)
        let dragDistance = hypot(mockTranslation.width, mockTranslation.height)
        
        if let index = (await viewModel.model.nodes).firstIndex(where: { $0.id == draggedNode.id }) {
            await viewModel.model.snapshot()
            if dragDistance < AppConstants.tapThreshold {
                // Tap logic (skipped)
            } else {
                if potentialEdgeTarget.id != draggedNode.id {
                    let fromID = draggedNode.id
                    let toID = potentialEdgeTarget.id
                    let edgeExists = await MainActor.run {
                        let edges = viewModel.model.edges  // No await needed here if already on MainActor
                        let forwardMatch = edges.contains { $0.from == fromID && $0.target == toID }
                        let reverseMatch = edges.contains { $0.from == toID && $0.target == fromID }
                        return forwardMatch || reverseMatch
                    }
                    if !edgeExists {
                        await MainActor.run { viewModel.model.edges.append(GraphEdge(from: fromID, target: toID)) }
                        await viewModel.model.startSimulation()
                    } else {
                        await MainActor.run {
                            let currentPos = viewModel.model.nodes[index].position
                            viewModel.model.nodes[index] = viewModel.model.nodes[index].with(position: CGPoint(x: currentPos.x + dragOffset.x, y: currentPos.y + dragOffset.y), velocity: .zero)
                        }
                        await viewModel.model.startSimulation()
                    }
                }
            }
        }
        
        #expect((await viewModel.model.edges).count == 1, "Edge created after simulated drag")
        let newEdge = (await viewModel.model.edges).first!
        #expect(newEdge.from == draggedNode.id, "Edge from correct node")
        #expect(newEdge.target == potentialEdgeTarget.id, "Edge to correct node")
        #expect(approximatelyEqual((await model.nodes[0]).position, initialPosition, accuracy: 1e-5), "Position unchanged on create")
    }
    
    @Test func testShortDragAsTap() async throws {
        let model = await setupModel()
        #expect((await model.edges).isEmpty, "No edges initially")
        
        let viewModel = await GraphViewModel(model: model)
        let draggedNode = await model.nodes[0]
        let initialPosition = draggedNode.position
        let initialEdgeCount = (await model.edges).count
        
        let mockTranslation = CGSize(width: 1, height: 1)  // Small, < tapThreshold
        let dragDistance = hypot(mockTranslation.width, mockTranslation.height)
        
        if let index = (await viewModel.model.nodes).firstIndex(where: { $0.id == draggedNode.id }) {
            _ = index  // Silence unused warning
            await viewModel.model.snapshot()
            if dragDistance < AppConstants.tapThreshold {
                // Tap logic (skipped; assume no side effects for this test)
            } else {
                // Drag branch skipped due to small distance
            }
        }
        
        #expect((await model.edges).count == initialEdgeCount, "No edge created on short drag")
        #expect(approximatelyEqual((await model.nodes[0]).position, initialPosition, accuracy: 1e-5), "Position unchanged")
    }
    
    @Test func testDragMovesNodeIfEdgeExists() async throws {
        let model = await setupModel()
        let fromID = (await model.nodes[0]).id
        let toID = (await model.nodes[1]).id
        await MainActor.run { model.edges.append(GraphEdge(from: fromID, target: toID)) }
        #expect((await model.edges).count == 1, "Edge exists initially")
        
        let viewModel = await GraphViewModel(model: model)
        let draggedNode = await model.nodes[0]
        let potentialEdgeTarget = await model.nodes[1]
        let initialPosition = draggedNode.position
        
        let mockTranslation = CGSize(width: 50, height: 50)
        let dragOffset = CGPoint(x: mockTranslation.width / 1.0, y: mockTranslation.height / 1.0)
        let dragDistance = hypot(mockTranslation.width, mockTranslation.height)
        
        if let index = (await viewModel.model.nodes).firstIndex(where: { $0.id == draggedNode.id }) {
            await viewModel.model.snapshot()
            if dragDistance < AppConstants.tapThreshold {
                // Tap logic (skipped)
            } else {
                if potentialEdgeTarget.id != draggedNode.id {
                    let fromID = draggedNode.id
                    let toID = potentialEdgeTarget.id
                    let edgeExists = await MainActor.run {
                        let edges = viewModel.model.edges
                        let forwardMatch = edges.contains { $0.from == fromID && $0.target == toID }
                        let reverseMatch = edges.contains { $0.from == toID && $0.target == fromID }
                        return forwardMatch || reverseMatch
                    }
                    if !edgeExists {
                        await MainActor.run { viewModel.model.edges.append(GraphEdge(from: fromID, target: toID)) }
                        await viewModel.model.startSimulation()
                    } else {
                        await MainActor.run {
                            let currentPos = viewModel.model.nodes[index].position
                            viewModel.model.nodes[index] = viewModel.model.nodes[index].with(position: CGPoint(x: currentPos.x + dragOffset.x, y: currentPos.y + dragOffset.y), velocity: .zero)
                        }
                        await viewModel.model.startSimulation()
                    }
                }
            }
        }
        
        #expect((await viewModel.model.edges).count == 1, "No new edge created")
        #expect(!approximatelyEqual((await model.nodes[0]).position, initialPosition, accuracy: 1e-5), "Position changed on move")
        #expect(approximatelyEqual((await model.nodes[0]).position, initialPosition + dragOffset, accuracy: 1e-5), "Moved by offset")
    }
}
----------------------------------------------------------------------------------------------------
File: GraphEditorWatchTests.swift
Path: GraphEditorWatchTests/GraphEditorWatchTests.swift
Last modified: 2025-09-22 11:21:14

Contents:
import Testing
import Foundation
import CoreGraphics
@testable import GraphEditorWatch
@testable import GraphEditorShared
import XCTest
import SwiftUI

class MockGraphStorage: GraphStorage {
    var nodes: [any NodeProtocol] = []
    var edges: [GraphEdge] = []
    
    func save(nodes: [any NodeProtocol], edges: [GraphEdge]) throws {
        self.nodes = nodes
        self.edges = edges
    }
    
    func load() throws -> (nodes: [any NodeProtocol], edges: [GraphEdge]) {
        (nodes, edges)
    }
    
    func clear() throws {
        nodes = []
        edges = []
    }
}

func approximatelyEqual(_ lhs: CGPoint, _ rhs: CGPoint, accuracy: CGFloat) -> Bool {
    return hypot(lhs.x - rhs.x, lhs.y - rhs.y) < accuracy
}
----------------------------------------------------------------------------------------------------
File: GraphModelTests.swift
Path: GraphEditorWatchTests/GraphModelTests.swift
Last modified: 2025-09-22 11:44:09

Contents:
//
//  GraphModelTests.swift
//  GraphEditor
//
//  Created by handcart on 9/22/25.
//
//
//  GraphModelTests.swift
//  GraphEditor
//
//  Created by handcart on 9/22/25.
//
import Testing
import Foundation
import CoreGraphics
@testable import GraphEditorWatch
@testable import GraphEditorShared
import XCTest
import SwiftUI

struct GraphModelTests {
    private func mockPhysicsEngine() -> GraphEditorShared.PhysicsEngine {
        GraphEditorShared.PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
    }
    
    private func setupDefaults(for storage: MockGraphStorage) throws {
        let node1 = AnyNode(Node(label: 1, position: CGPoint(x: 100, y: 100)))
        let node2 = AnyNode(Node(label: 2, position: CGPoint(x: 200, y: 200)))
        let node3 = AnyNode(Node(label: 3, position: CGPoint(x: 150, y: 150)))
        let edge1 = GraphEdge(from: node1.id, target: node2.id)
        let edge2 = GraphEdge(from: node2.id, target: node3.id)
        let edge3 = GraphEdge(from: node3.id, target: node1.id)
        try storage.save(nodes: [node1, node2, node3], edges: [edge1, edge2, edge3])
    }
    
    private func generateNodesAndEdges(seed: Int) async -> ([AnyNode], [GraphEdge]) {
        struct SeededRandomNumberGenerator: RandomNumberGenerator {
            private var state: UInt64
            init(seed: UInt64) {
                state = seed
            }
            mutating func next() -> UInt64 {
                state &+= 1442695040888963407
                state &*= 6364136223846793005
                return state
            }
        }
        var rng = SeededRandomNumberGenerator(seed: UInt64(seed))
        var nodesToAssign: [AnyNode] = []
        for _ in 0..<5 {
            let label = Int.random(in: 0..<10, using: &rng)
            let positionX = CGFloat.random(in: 0..<300, using: &rng)
            let positionY = CGFloat.random(in: 0..<300, using: &rng)
            nodesToAssign.append(AnyNode(Node(label: label, position: CGPoint(x: positionX, y: positionY))))
        }
        var edgesToAssign: [GraphEdge] = []
        for _ in 0..<3 {
            let fromIndex = Int.random(in: 0..<nodesToAssign.count, using: &rng)
            let targetIndex = Int.random(in: 0..<nodesToAssign.count, using: &rng)
            edgesToAssign.append(GraphEdge(from: nodesToAssign[fromIndex].id, target: nodesToAssign[targetIndex].id))
        }
        return (nodesToAssign, edgesToAssign)
    }
    
    private func runSimulation(on model: GraphModel, subStepsPerIteration: Int = 20) async {
        await model.startSimulation()
        for _ in 0..<Constants.Physics.maxSimulationSteps {
            var nodes = await model.nodes
            var activeAccum = false
            for _ in 0..<subStepsPerIteration {
                let currentNodes = nodes.map { $0.unwrapped }
                let physics = await model.physicsEngine
                let edges = await model.edges
                let (updatedNodes, stepActive) = physics.simulationStep(nodes: currentNodes, edges: edges)
                nodes = updatedNodes.map(AnyNode.init)
                activeAccum = activeAccum || stepActive
                if !stepActive { break }
            }
            let updatedNodesForMain = nodes
            await MainActor.run { model.nodes = updatedNodesForMain }
            if !activeAccum { break }
        }
    }
    
    @Test(arguments: 1..<5) func testConvergencePropertyBased(seed: Int) async throws {
        let storage = MockGraphStorage()
        let model = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        await model.load()
        let (nodesToAssign, edgesToAssign) = await generateNodesAndEdges(seed: seed)
        await MainActor.run {
            model.nodes = nodesToAssign
            model.edges = edgesToAssign
        }
        await runSimulation(on: model)
        let totalVel = (await model.nodes).reduce(0.0) { $0 + $1.velocity.magnitude }
        let nodeCount = await MainActor.run { model.nodes.count }
        #expect(totalVel < 2.0 * CGFloat(nodeCount), "Velocities near zero for seed \(seed)")
    }
    
    @Test func testSimulationConvergence() async {
        let tolerance: CGFloat = 0.05
        let storage = MockGraphStorage()
        let model = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        await model.load()
        await MainActor.run {
            model.nodes = [
                AnyNode(Node(label: 1, position: CGPoint(x: 100, y: 100), velocity: CGPoint(x: 10, y: 10))),
                AnyNode(Node(label: 2, position: CGPoint(x: 200, y: 200), velocity: CGPoint(x: -10, y: -10)))
            ]
            model.edges = [GraphEdge(from: model.nodes[0].id, target: model.nodes[1].id)]
        }
        await runSimulation(on: model)
        #expect((await model.nodes[0]).velocity.magnitude < 1.2 + tolerance, "Node 1 velocity converges to near-zero")
        #expect((await model.nodes[1]).velocity.magnitude < 1.2 + tolerance, "Node 2 velocity converges to near-zero")
    }
    
    @Test func testUndoRedoMixedOperations() async throws {
        let storage = MockGraphStorage()
        try setupDefaults(for: storage)
        let model = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        await model.load()
        await runSimulation(on: model)
        let initialNodeCount = await MainActor.run { model.nodes.count }
        let initialEdgeCount = await MainActor.run { model.edges.count }
        let initialNodes = await model.nodes
        try #require(!initialNodes.isEmpty, "Assumes initial nodes exist")
        await model.snapshot()
        let nodeToDelete = initialNodes[0].id
        let initialEdges = await model.edges
        let connectedEdges = initialEdges.filter { $0.from == nodeToDelete || $0.target == nodeToDelete }.count
        await model.deleteNode(withID: nodeToDelete)
        await runSimulation(on: model)
        await model.snapshot()
        await model.addNode(at: CGPoint.zero)
        await runSimulation(on: model)
        #expect(await MainActor.run { model.nodes.count } == initialNodeCount, "After add: count back to initial")
        #expect(await MainActor.run { model.edges.count } == initialEdgeCount - connectedEdges, "Edges reduced by connected count")
        await model.undo() // To post-delete
        #expect(await MainActor.run { model.nodes.count } == initialNodeCount - 1, "Undo reverts to post-delete")
        #expect(await MainActor.run { model.edges.count } == initialEdgeCount - connectedEdges, "Edges match post-delete")
        await model.undo() // To initial
        #expect(await MainActor.run { model.nodes.count } == initialNodeCount, "Second undo restores initial")
        #expect(await MainActor.run { model.edges.count } == initialEdgeCount, "Edges restored")
        let restoredNodes = await model.nodes
        #expect(zip(restoredNodes.sorted(by: { $0.id.uuidString < $1.id.uuidString }), initialNodes.sorted(by: { $0.id.uuidString < $1.id.uuidString })).allSatisfy { approximatelyEqual($0.position, $1.position, accuracy: 1e-5) && approximatelyEqual($0.velocity, $1.velocity, accuracy: 1e-5) }, "Positions and velocities restored")
        await model.redo() // To post-delete
        #expect((await model.nodes).count == initialNodeCount - 1, "Redo applies delete")
        await model.redo() // To post-add
        #expect((await model.nodes).count == initialNodeCount, "Redo applies add")
    }
    
    @Test func testInitializationWithDefaults() async throws {
        let storage = MockGraphStorage()
        try setupDefaults(for: storage)
        let model = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        await model.load()
        #expect(await MainActor.run { model.nodes.count } >= 3, "Should load default or saved nodes")
        #expect(await MainActor.run { model.edges.count } >= 3, "Should load default edges")
    }
    
    @Test func testDeleteNodeAndEdges() async throws {
        let storage = MockGraphStorage()
        try setupDefaults(for: storage)
        let model = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        await model.load()
        let nodes = await model.nodes
        try #require(!nodes.isEmpty, "Assumes default nodes exist")
        let nodeToDelete = nodes[0].id
        let initialEdgeCount = await model.edges.count
        let connectedEdges = (await model.edges).filter { $0.from == nodeToDelete || $0.target == nodeToDelete }.count
        await model.deleteNode(withID: nodeToDelete)
        #expect(await MainActor.run { model.nodes.count } == nodes.count - 1, "Node deleted")
        #expect(await MainActor.run { model.edges.count } == initialEdgeCount - connectedEdges, "Connected edges deleted")
    }
    
    @Test func testSaveLoadRoundTrip() async throws {
        let storage = MockGraphStorage()
        try setupDefaults(for: storage)
        let model = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        await model.load()
        let originalNodeCount = await MainActor.run { model.nodes.count }
        let originalEdges = await model.edges
        let originalNodes = await model.nodes
        await model.addNode(at: CGPoint.zero)
        await model.snapshot()  // Triggers save()
        let newModel = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        await newModel.load()
        #expect(await MainActor.run { newModel.nodes.count } == originalNodeCount + 1, "Loaded nodes include added one")
        #expect(await newModel.edges == originalEdges, "Edges unchanged")
        let loadedNodes = (await newModel.nodes).sorted(by: { $0.id.uuidString < $1.id.uuidString })
        let expectedNodes = (originalNodes + [(await model.nodes).last!]).sorted(by: { $0.id.uuidString < $1.id.uuidString })
        #expect(zip(loadedNodes, expectedNodes).allSatisfy {
            $0.label == $1.label && approximatelyEqual($0.position, $1.position, accuracy: 1e-5)
        }, "Loaded nodes match expected")
    }
    
}
----------------------------------------------------------------------------------------------------
File: GraphEditorWatchUITests.swift
Path: GraphEditorWatchUITests/GraphEditorWatchUITests.swift
Last modified: 2025-09-16 11:24:30

Contents:
//
//  GraphEditorWatchUITests.swift
//  GraphEditorWatchUITests
//
//  Created by handcart on 8/4/25.
//

import XCTest

final class GraphEditorWatchUITests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.

        // In UI tests it is usually best to stop immediately when a failure occurs.
        continueAfterFailure = false

        // In UI tests itâ€™s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }
    
    func testLaunch() throws {
            let app = XCUIApplication()
            app.launch()
            
            // Basic assertion: Check if the app launches without crashing
            XCTAssertTrue(app.exists, "App should launch successfully")
        }
    
    func testDragToCreateEdge() throws {
        let app = XCUIApplication()
        app.launch()

        let canvas = app.otherElements["GraphCanvas"]  // Assumes accessibilityIdentifier set on GraphCanvasView
        XCTAssertTrue(canvas.waitForExistence(timeout: 5), "Graph canvas should appear")

        // Assume default nodes: Adjust start/end based on positions (e.g., node0 at (100,100), node1 at (200,200))
        let startPoint = CGVector(dx: 0.3, dy: 0.3)  // Near node0
        let endPoint = CGVector(dx: 0.6, dy: 0.6)    // Near node1

        let dragStart = canvas.coordinate(withNormalizedOffset: startPoint)
        let dragEnd = canvas.coordinate(withNormalizedOffset: endPoint)
        dragStart.press(forDuration: 0.1, thenDragTo: dragEnd)

        // Assert: Updated label reflects directed edge (e.g., "Graph with 3 nodes and 4 directed edges." and mentions direction)
        let updatedLabel = app.staticTexts["Graph with 3 nodes and 4 directed edges. No node selected."]  // Adjust based on post-drag (add "directed")
        XCTAssertTrue(updatedLabel.waitForExistence(timeout: 2), "Directed edge created, updating graph description")

        // Optional: Select the from-node and check description mentions "outgoing to" the to-node
        // Simulate tap on startPoint to select, then check label includes "outgoing to: <label>"
    }
    
    func testUndoAfterAddNode() throws {
            let app = XCUIApplication()
            app.launch()
            
            let canvas = app.otherElements["GraphCanvas"]  // Assume identifier set
            XCTAssertTrue(canvas.waitForExistence(timeout: 5))
            
            // Simulate add node: Assume menu button "Add Node" exists
            app.buttons["Show Menu"].tap()  // Or long press if using gestures
            app.buttons["Add Node"].tap()
            
            // Assert: Graph description updates (e.g., nodes increase)
            let updatedLabel = app.staticTexts["Graph with 4 nodes"]  // Adjust based on defaults +1
            XCTAssertTrue(updatedLabel.waitForExistence(timeout: 2), "Node added")
            
            // Undo via button
            app.buttons["Undo"].tap()  // Assume undo button in menu or UI
            let revertedLabel = app.staticTexts["Graph with 3 nodes"]  // Back to defaults
            XCTAssertTrue(revertedLabel.waitForExistence(timeout: 2), "Undo reverts add")
        }
        
        func testMenuDisplayAndAction() throws {
            let app = XCUIApplication()
            app.launch()
            
            let canvas = app.otherElements["GraphCanvas"]
            XCTAssertTrue(canvas.waitForExistence(timeout: 5))
            
            // Long press to show menu (if using sheet)
            canvas.coordinate(withNormalizedOffset: CGVector(dx: 0.5, dy: 0.5)).press(forDuration: 1.0)
            
            // Assert menu appears with buttons
            let addButton = app.buttons["Add Node"]
            XCTAssertTrue(addButton.waitForExistence(timeout: 2), "Menu shows with actions")
            
            addButton.tap()
            // Assert action effect (e.g., via label)
            let updatedLabel = app.staticTexts["Graph with 4 nodes"]
            XCTAssertTrue(updatedLabel.waitForExistence(timeout: 2), "Menu action adds node")
        }
    
    // New: Test for digital crown zooming (using proxy button; manual test crown in simulator)
    func testDigitalCrownZooming() throws {
        let app = XCUIApplication()
        app.launch()
        
        let canvas = app.otherElements["GraphCanvas"]  // Assume identifier set
        XCTAssertTrue(canvas.waitForExistence(timeout: 5))
        
        // Simulate crown via menu button (add "Zoom In" to menu if not present)
        app.buttons["Show Menu"].tap()
        app.buttons["Zoom In"].tap()  // Proxy for crown rotation; adjust if button named differently
        
        // Assert: Check if description or visible elements change (e.g., more details visible)
        let zoomedLabel = app.staticTexts["Graph with 3 nodes"]  // Adjust to match post-zoom (e.g., if zoom reveals more)
        XCTAssertTrue(zoomedLabel.waitForExistence(timeout: 2), "Zoom updates view")
    }
    
    @MainActor
    func testExample() throws {
        // UI tests must launch the application that they test.
        let app = XCUIApplication()
        app.launch()

        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    @MainActor
    func testLaunchPerformance() throws {
        // This measures how long it takes to launch your application.
        measure(metrics: [XCTApplicationLaunchMetric()]) {
            XCUIApplication().launch()
        }
    }
}
----------------------------------------------------------------------------------------------------
File: GraphEditorWatchUITestsLaunchTests.swift
Path: GraphEditorWatchUITests/GraphEditorWatchUITestsLaunchTests.swift
Last modified: 2025-09-19 13:15:40

Contents:
//
//  GraphEditorWatchUITestsLaunchTests.swift
//  GraphEditorWatchUITests
//
//  Created by handcart on 8/4/25.
//

import XCTest

final class GraphEditorWatchUITestsLaunchTests: XCTestCase {

    override static var runsForEachTargetApplicationUIConfiguration: Bool {
        true
    }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    @MainActor
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        // Insert steps here to perform after app launch but before taking a screenshot,
        // such as logging into a test account or navigating somewhere in the app

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = "Launch Screen"
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}
--------------------------------------------------
