## Focused Project Concatenation
This file includes only UI, interactivity, model, and core logic files.
Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
Current date: 2025-10-10 13:25:47
Table of Contents:
1. GraphEditorWatch/Views/GraphUtilities.swift
2. GraphEditorWatch/Views/InnerView.swift
3. GraphEditorWatch/Views/MenuView.swift
4. GraphEditorWatch/Views/NodeView.swift
5. GraphEditorWatch/Views/ViewSection.swift
6. GraphEditorWatchTests/AccessibilityTests.swift
7. GraphEditorWatchTests/CoordinateTransformerTests.swift
8. GraphEditorWatchTests/EditContentSheetTests.swift
9. GraphEditorWatchTests/GestureTests.swift
10. GraphEditorWatchTests/GraphEditorWatchTests.swift
11. GraphEditorWatchTests/GraphGesturesModifierTests.swift--------------------------------------------------
File: GraphUtilities.swift
Path: GraphEditorWatch/Views/GraphUtilities.swift
Last modified: 2025-09-19 14:46:52

Contents:
// GraphUtilities.swift
//  GraphEditor
//
//  Created by handcart on 9/19/25.
//
import SwiftUI
import GraphEditorShared
import CoreGraphics

struct ViewSizeKey: PreferenceKey {
    static var defaultValue: CGSize = .zero
    static func reduce(value: inout CGSize, nextValue: () -> CGSize) {
        value = nextValue()
    }
}

struct NodeWrapper: Equatable, Identifiable {
    let id: UUID?
    let node: (any NodeProtocol)?
    
    init(node: (any NodeProtocol)?) {
        self.node = node
        self.id = node?.id
    }
    
    static func == (lhs: NodeWrapper, rhs: NodeWrapper) -> Bool {
        lhs.id == rhs.id
    }
}

struct InnerViewConfig {
    let geo: GeometryProxy
    let viewModel: GraphViewModel
    let zoomScale: Binding<CGFloat>
    let offset: Binding<CGSize>
    let draggedNode: Binding<NodeWrapper>
    let dragOffset: Binding<CGPoint>
    let potentialEdgeTarget: Binding<NodeWrapper>
    let panStartOffset: Binding<CGSize?>
    let showMenu: Binding<Bool>
    let showOverlays: Binding<Bool>
    let maxZoom: CGFloat
    let crownPosition: Binding<Double>
    let updateZoomRangesHandler: (CGSize) -> Void
    let selectedNodeID: Binding<NodeID?>
    let selectedEdgeID: Binding<UUID?>
    let canvasFocus: FocusState<Bool>
    let onCenterGraph: () -> Void
    let isAddingEdge: Binding<Bool>
    let isSimulatingBinding: Binding<Bool>
    
    init(
        geo: GeometryProxy,
        viewModel: GraphViewModel,
        zoomScale: Binding<CGFloat>,
        offset: Binding<CGSize>,
        draggedNode: Binding<NodeWrapper>,
        dragOffset: Binding<CGPoint>,
        potentialEdgeTarget: Binding<NodeWrapper>,
        panStartOffset: Binding<CGSize?>,
        showMenu: Binding<Bool>,
        showOverlays: Binding<Bool>,
        maxZoom: CGFloat,
        crownPosition: Binding<Double>,
        updateZoomRangesHandler: @escaping (CGSize) -> Void,
        selectedNodeID: Binding<NodeID?>,
        selectedEdgeID: Binding<UUID?>,
        canvasFocus: FocusState<Bool>,
        onCenterGraph: @escaping () -> Void,
        isAddingEdge: Binding<Bool>,
        isSimulatingBinding: Binding<Bool>  // NEW: Add this param
    ) {
        self.geo = geo
        self.viewModel = viewModel
        self.zoomScale = zoomScale
        self.offset = offset
        self.draggedNode = draggedNode
        self.dragOffset = dragOffset
        self.potentialEdgeTarget = potentialEdgeTarget
        self.panStartOffset = panStartOffset
        self.showMenu = showMenu
        self.showOverlays = showOverlays
        self.maxZoom = maxZoom
        self.crownPosition = crownPosition
        self.updateZoomRangesHandler = updateZoomRangesHandler
        self.selectedNodeID = selectedNodeID
        self.selectedEdgeID = selectedEdgeID
        self.canvasFocus = canvasFocus
        self.onCenterGraph = onCenterGraph
        self.isAddingEdge = isAddingEdge
        self.isSimulatingBinding = isSimulatingBinding  // NEW: Assign it
    }
}
----------------------------------------------------------------------------------------------------
File: InnerView.swift
Path: GraphEditorWatch/Views/InnerView.swift
Last modified: 2025-09-19 14:46:52

Contents:
//
//  InnerView.swift
//  GraphEditor
//
//  Created by handcart on 9/19/25.
//

// InnerView.swift

import SwiftUI
import GraphEditorShared

struct InnerView: View {
    let config: InnerViewConfig
    
    var body: some View {
        let draggedNodeBinding = Binding<(any NodeProtocol)?>(
            get: { config.draggedNode.wrappedValue.node },
            set: { config.draggedNode.wrappedValue = NodeWrapper(node: $0) }
        )
        let potentialEdgeTargetBinding = Binding<(any NodeProtocol)?>(
            get: { config.potentialEdgeTarget.wrappedValue.node },
            set: { config.potentialEdgeTarget.wrappedValue = NodeWrapper(node: $0) }
        )
        
        let canvasView = GraphCanvasView(
            viewModel: config.viewModel,
            zoomScale: config.zoomScale,
            offset: config.offset,
            draggedNode: draggedNodeBinding,
            dragOffset: config.dragOffset,
            potentialEdgeTarget: potentialEdgeTargetBinding,
            selectedNodeID: config.selectedNodeID,
            viewSize: config.geo.size,
            panStartOffset: config.panStartOffset,
            showMenu: config.showMenu,
            maxZoom: config.maxZoom,
            crownPosition: config.crownPosition,
            onUpdateZoomRanges: { config.updateZoomRangesHandler(config.geo.size) },
            selectedEdgeID: config.selectedEdgeID,
            showOverlays: config.showOverlays,
            isAddingEdge: config.isAddingEdge
        )
            .accessibilityIdentifier("GraphCanvas")
            .focused(config.canvasFocus.projectedValue)
            .focusable()
        
        if config.showMenu.wrappedValue {
            MenuView(
                viewModel: config.viewModel,
                isSimulatingBinding: config.isSimulatingBinding,
                onCenterGraph: config.onCenterGraph,
                showMenu: config.showMenu,
                showOverlays: config.showOverlays,
                selectedNodeID: config.selectedNodeID,    // NEW: Pass binding
                selectedEdgeID: config.selectedEdgeID     // NEW: Pass binding
            )
            .navigationTitle("Menu")
        } else {
            canvasView
        }
    }
}
----------------------------------------------------------------------------------------------------
File: MenuView.swift
Path: GraphEditorWatch/Views/MenuView.swift
Last modified: 2025-10-06 20:24:41

Contents:
//
//  MenuView.swift
//  GraphEditor
//
//  Created by handcart on 8/20/25.
//

import SwiftUI
import WatchKit
import GraphEditorShared

struct MenuView: View {
    let viewModel: GraphViewModel
    let isSimulatingBinding: Binding<Bool>
    let onCenterGraph: () -> Void
    @Binding var showMenu: Bool
    @Binding var showOverlays: Bool
    @Binding var selectedNodeID: NodeID?    // NEW: @Binding for reactivity
    @Binding var selectedEdgeID: UUID?      // NEW: @Binding for reactivity
    
    @FocusState private var isMenuFocused: Bool
    @State private var showEditSheet: Bool = false
    @State private var isAddingEdge: Bool = false
    
    var body: some View {
        List {
            AddSection(
                viewModel: viewModel,
                selectedNodeID: selectedNodeID,  // NEW: Use binding.wrappedValue
                onDismiss: { showMenu = false },
                onAddEdge: { type in
                    viewModel.pendingEdgeType = type
                    isAddingEdge = true
                }
            )
            
            // NEW: Conditional EditSection to avoid empty header
            if selectedNodeID != nil || selectedEdgeID != nil {  // NEW: Use bindings
                EditSection(
                    viewModel: viewModel,
                    selectedNodeID: selectedNodeID,      // NEW: Pass binding.wrappedValue
                    selectedEdgeID: selectedEdgeID,      // NEW: Pass binding.wrappedValue
                    onDismiss: { showMenu = false },
                    onEditNode: { showEditSheet = true }
                )
            }
            
            ViewSection(
                showOverlays: $showOverlays,  // Now in scope
                isSimulating: isSimulatingBinding,
                onCenterGraph: onCenterGraph,
                onDismiss: { showMenu = false },  // Now in scope
                onSimulationChange: { newValue in
                    viewModel.model.isSimulating = newValue
                    if newValue {
                        Task { await viewModel.model.startSimulation() }
                    } else {
                        Task { await viewModel.model.stopSimulation() }
                    }
                }
            )
            
            GraphSection(viewModel: viewModel, onDismiss: { showMenu = false })  // Now in scope
        }
        .accessibilityIdentifier("menuList")
        .navigationTitle("Menu")
        .focused($isMenuFocused)  // New: Bind focus to list
        .onAppear {
            isMenuFocused = true
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                isMenuFocused = true
            }
            // NEW: Debug log for selections
            print("Menu appeared: selectedNodeID=\(selectedNodeID?.uuidString.prefix(8) ?? "nil"), selectedEdgeID=\(selectedEdgeID?.uuidString.prefix(8) ?? "nil")")
        }
        .onChange(of: isMenuFocused) { _, newValue in
            print("Menu focus: \(newValue)") // Debug (fixed typo)
            if !newValue {
                isMenuFocused = true // Auto-recover
            }
        }
        .ignoresSafeArea(.keyboard)
        .sheet(isPresented: $showEditSheet) {  // New: Local sheet for edit
            if let selectedID = viewModel.selectedNodeID {
                EditContentSheet(selectedID: selectedID, viewModel: viewModel, onSave: { newContent in
                    Task { await viewModel.model.updateNodeContent(withID: selectedID, newContent: newContent) }
                    showEditSheet = false
                })
            }
        }
        .onChange(of: isAddingEdge) { _, newValue in  // New: Handle add edge mode (if needed; or pass to parent)
            if newValue {
                // Optionally notify viewModel or handle here
            }
        }
    }
}

#Preview {
    @Previewable @State var mockSelectedNodeID: NodeID?
    @Previewable @State var mockSelectedEdgeID: UUID? = UUID()  // Simulate
    let mockViewModel = GraphViewModel(model: GraphModel(storage: PersistenceManager(), physicsEngine: PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))))
    mockViewModel.setSelectedEdge(UUID())  // Simulate edge selection for preview
    return MenuView(
        viewModel: mockViewModel,
        isSimulatingBinding: .constant(false),
        onCenterGraph: {},
        showMenu: .constant(true),
        showOverlays: .constant(false),
        selectedNodeID: $mockSelectedNodeID,  // NEW
        selectedEdgeID: $mockSelectedEdgeID   // NEW
    )
}
----------------------------------------------------------------------------------------------------
File: NodeView.swift
Path: GraphEditorWatch/Views/NodeView.swift
Last modified: 2025-09-16 11:24:30

Contents:
//
//  NodeView.swift
//  GraphEditor
//
//  Created by handcart on 8/13/25.
//

import SwiftUI
import GraphEditorShared

struct NodeView: View {
    let node: any NodeProtocol
    let isSelected: Bool
    let zoomScale: CGFloat
    
    var body: some View {
        ZStack {
            if isSelected {
                Circle()
                    .stroke(Color.yellow, lineWidth: 4 * zoomScale)
                    .frame(width: node.radius * 2 * zoomScale + 4 * zoomScale, height: node.radius * 2 * zoomScale + 4 * zoomScale)
            }
            Circle()
                .fill(node.fillColor)  // Or dynamic based on node type
                .frame(width: node.radius * 2 * zoomScale, height: node.radius * 2 * zoomScale)
            
            // Add icon/label as in ToggleNode.draw
            if let toggleNode = node as? ToggleNode {
                Text(toggleNode.isExpanded ? "-" : "+")
                    .foregroundColor(.white)
                    .font(.system(size: max(8.0, 12.0 * zoomScale), weight: .bold))
            }
            
            Text("\(node.label)")
                .foregroundColor(.white)
                .font(.system(size: max(8.0, 12.0 * zoomScale)))
                .offset(y: -(node.radius + 10) * zoomScale)  // Position above
        }
    }
}
----------------------------------------------------------------------------------------------------
File: ViewSection.swift
Path: GraphEditorWatch/Views/ViewSection.swift
Last modified: 2025-10-05 16:02:44

Contents:
//
//  ViewSection.swift
//  GraphEditor
//
//  Created by handcart on 10/5/25.
//

import SwiftUI

struct ViewSection: View {
    @Binding var showOverlays: Bool
    let isSimulating: Binding<Bool>
    let onCenterGraph: () -> Void
    let onDismiss: () -> Void
    let onSimulationChange: (Bool) -> Void
    
    var body: some View {
        Section(header: Text("View")) {
            Toggle("Show Overlays", isOn: $showOverlays)
                .onSubmit { /* No-op for toggle */ }
            
            Toggle("Run Simulation", isOn: isSimulating)
                .onChange(of: isSimulating.wrappedValue) { _, newValue in
                    onSimulationChange(newValue)
                }
                .onSubmit { /* No-op for toggle */ }
            
            Button("Center Graph") {
                onCenterGraph()
                onDismiss()
            }
            .onSubmit { onCenterGraph(); onDismiss() }
        }
        .accessibilityLabel("View section")  // NEW: Accessibility
    }
}
----------------------------------------------------------------------------------------------------
File: AccessibilityTests.swift
Path: GraphEditorWatchTests/AccessibilityTests.swift
Last modified: 2025-09-22 11:21:14

Contents:
//
//  AccessibilityTests.swift
//  GraphEditor
//
//  Created by handcart on 9/22/25.
//
import Testing
import Foundation
import CoreGraphics
@testable import GraphEditorWatch
@testable import GraphEditorShared
import XCTest
import SwiftUI

struct AccessibilityTests {
    private func mockPhysicsEngine() -> GraphEditorShared.PhysicsEngine {
        GraphEditorShared.PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
    }
    
    @Test func testGraphDescription() async throws {
        let storage = MockGraphStorage()
        storage.nodes = [Node(label: 0, position: .zero)]
        let model = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        await MainActor.run { model.nextNodeLabel = 1 }
        await model.addNode(at: .zero)
        await model.addNode(at: CGPoint(x: 10, y: 10))
        
        await MainActor.run { model.edges.append(GraphEdge(from: model.nodes[0].id, target: model.nodes[1].id)) }
        
        let descNoSelect = await MainActor.run { model.graphDescription(selectedID: nil, selectedEdgeID: nil) }
        #expect(descNoSelect == "Graph with 2 nodes and 1 directed edge. No node or edge selected.", "Correct desc without selection")
        
        let descWithSelect = await MainActor.run { model.graphDescription(selectedID: model.nodes[0].id, selectedEdgeID: nil) }
        #expect(descWithSelect == "Graph with 2 nodes and 1 directed edge. Node 1 selected, outgoing to: 2; incoming from: none.", "Correct desc with selection")
    }
}
----------------------------------------------------------------------------------------------------
File: CoordinateTransformerTests.swift
Path: GraphEditorWatchTests/CoordinateTransformerTests.swift
Last modified: 2025-10-08 15:23:57

Contents:
//
//  CoordinateTransformerTests.swift
//  GraphEditor
//
//  Created by handcart on 9/22/25.
//
import Testing
import Foundation
import CoreGraphics
@testable import GraphEditorWatch
@testable import GraphEditorShared
import XCTest
import SwiftUI

struct CoordinateTransformerTests {
    @Test func testCoordinateRoundTrip() {
        let viewSize = CGSize(width: 205, height: 251)
        let centroid = CGPoint(x: 150, y: 150)
        let modelPos = CGPoint(x: 167.78, y: 165.66)
        let zoom: CGFloat = 1.0
        let offset = CGSize.zero
        
        let screenPos = CoordinateTransformer.modelToScreen(modelPos, effectiveCentroid: centroid, zoomScale: zoom, offset: offset, viewSize: viewSize)
        let recoveredModel = CoordinateTransformer.screenToModel(screenPos, effectiveCentroid: centroid, zoomScale: zoom, offset: offset, viewSize: viewSize)
        
        #expect(approximatelyEqual(recoveredModel, modelPos, accuracy: 1e-3), "Round-trip should match original model position")
    }
    
    @Test func testCoordinateRoundTripWithZoomAndOffset() {
        let viewSize = CGSize(width: 205, height: 251)
        let centroid = CGPoint(x: 56.73, y: 161.10)
        let modelPos = CGPoint(x: -40.27, y: 52.60)
        let zoom: CGFloat = 1.0
        let offset = CGSize(width: 81, height: 111.5)
        
        let screenPos = CoordinateTransformer.modelToScreen(modelPos, effectiveCentroid: centroid, zoomScale: zoom, offset: offset, viewSize: viewSize)
        let recoveredModel = CoordinateTransformer.screenToModel(screenPos, effectiveCentroid: centroid, zoomScale: zoom, offset: offset, viewSize: viewSize)
        
        #expect(approximatelyEqual(recoveredModel, modelPos, accuracy: 1e-3), "Round-trip with zoom and offset should match")
    }
    
    public func approximatelyEqual(_ lhs: CGPoint, _ rhs: CGPoint, accuracy: CGFloat) -> Bool {
        hypot(lhs.x - rhs.x, lhs.y - rhs.y) < accuracy
    }
}
----------------------------------------------------------------------------------------------------
File: EditContentSheetTests.swift
Path: GraphEditorWatchTests/EditContentSheetTests.swift
Last modified: 2025-09-25 14:25:51

Contents:
//
//  EditContentSheetTests.swift
//  GraphEditor
//
//  Created by handcart on 9/25/25.
//
import Testing
import SwiftUI
@testable import GraphEditorWatch
@testable import GraphEditorShared

struct EditContentSheetTests {
    private func setupViewModel() async -> GraphViewModel {
        let storage = MockGraphStorage()
        let physicsEngine = PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
        let model = await GraphModel(storage: storage, physicsEngine: physicsEngine)
        return await GraphViewModel(model: model)
    }
    
    @Test func testSaveStringContent() async {
        let viewModel = await setupViewModel()
        let nodeID = NodeID()
        var savedContent: NodeContent?
        let sheet = EditContentSheet(selectedID: nodeID, viewModel: viewModel) { content in
            savedContent = content
        }
        // Simulate input: Since @State is private, this is placeholder; use XCUITest for full simulation or expose states for testing
        // For example, assume manual set: sheet.selectedType = "String"; sheet.stringValue = "test"; then call onSave
        // Placeholder assertion (adapt based on actual simulation logic)
        _ = sheet  // Use to silence warning
        #expect(savedContent == nil, "Initially nil; add simulation to set .string(\"test\")")
    }
}
----------------------------------------------------------------------------------------------------
File: GestureTests.swift
Path: GraphEditorWatchTests/GestureTests.swift
Last modified: 2025-10-10 13:16:11

Contents:
//
//  GestureTests.swift
//  GraphEditor
//
//  Created by handcart on 9/22/25.
//
import Testing
import Foundation
import CoreGraphics
@testable import GraphEditorWatch
@testable import GraphEditorShared
import XCTest
import SwiftUI

struct GestureTests {
    private func setupModel() async -> GraphModel {
        let storage = MockGraphStorage()
        let physicsEngine = GraphEditorShared.PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
        let model = await MainActor.run { GraphModel(storage: storage, physicsEngine: physicsEngine) }
        await MainActor.run { model.nodes = [] }
        await MainActor.run { model.edges = [] }
        await model.addNode(at: CGPoint(x: 0, y: 0))
        await model.addNode(at: CGPoint(x: 50, y: 50))
        await model.stopSimulation()  // Ensure no ongoing simulation
        return model
    }
    
    @Test func testDragCreatesEdge() async throws {
        let model = await setupModel()
        #expect((await model.edges).isEmpty, "No edges initially")
        
        // Ensure at least two nodes exist before indexing
        let currentCount = await model.nodes.count
        if currentCount < 2 {
            await model.addNode(at: .zero)
            await model.addNode(at: CGPoint(x: 100, y: 100))
            await model.startSimulation()
            await model.stopSimulation()
        }
        
        let viewModel = await MainActor.run { GraphViewModel(model: model) }
        let draggedNode = await model.nodes[0]
        let potentialEdgeTarget = await model.nodes[1]
        let initialPosition = draggedNode.position
        
        let mockTranslation = CGSize(width: 50, height: 50)
        let dragOffset = CGPoint(x: mockTranslation.width / 1.0, y: mockTranslation.height / 1.0)
        let initialPositionUpdated = CGPoint(x: initialPosition.x + dragOffset.x, y: initialPosition.y + dragOffset.y)  // NEW: Compute expected position if moved
        
        let dragDistance = hypot(mockTranslation.width, mockTranslation.height)
        
        if let index = (await viewModel.model.nodes).firstIndex(where: { $0.id == draggedNode.id }) {
            await viewModel.model.snapshot()
            if dragDistance < AppConstants.tapThreshold {
                // Tap logic (skipped)
            } else {
                if potentialEdgeTarget.id != draggedNode.id {
                    let fromID = draggedNode.id
                    let targetID = potentialEdgeTarget.id
                    let initialEdges = await MainActor.run { viewModel.model.edges }  // Capture initial for comparison on MainActor
                    let edgeExists = initialEdges.contains { $0.from == fromID && $0.target == targetID } ||
                                     initialEdges.contains { $0.from == targetID && $0.target == fromID }
                    if !edgeExists {
                        await MainActor.run { viewModel.model.edges.append(GraphEdge(from: fromID, target: targetID)) }
                    } else {
                        await MainActor.run {
                            viewModel.model.nodes[index] = viewModel.model.nodes[index].with(position: initialPositionUpdated, velocity: .zero)
                        }
                    }
                    await viewModel.model.startSimulation()
                    await viewModel.model.stopSimulation()  // Wait for completion
                }
            }
        }
        
        let finalEdgeCount = await MainActor.run { viewModel.model.edges.count }
        #expect(finalEdgeCount == 1, "Edge created after simulated drag")
        let newEdge = await MainActor.run { viewModel.model.edges.first! }
        #expect(newEdge.from == draggedNode.id, "Edge from correct node")
        #expect(newEdge.target == potentialEdgeTarget.id, "Edge to correct node")
        let node0PositionAfter = await MainActor.run { model.nodes[0].position }
        #expect(approximatelyEqual(node0PositionAfter, initialPosition, accuracy: 1e-5), "Position unchanged on edge create")  // Corrected expectation
    }
    @Test func testShortDragAsTap() async throws {
        let model = await setupModel()
        #expect((await model.edges).isEmpty, "No edges initially")
        
        let viewModel = await MainActor.run { GraphViewModel(model: model) }
        let draggedNode = await model.nodes[0]
        let initialPosition = draggedNode.position
        let initialEdgeCount = (await model.edges).count
        
        let mockTranslation = CGSize(width: 1, height: 1)  // Small, < tapThreshold
        let dragDistance = hypot(mockTranslation.width, mockTranslation.height)
        
        if let index = (await viewModel.model.nodes).firstIndex(where: { $0.id == draggedNode.id }) {
            _ = index  // Silence unused warning
            await viewModel.model.snapshot()
            if dragDistance < AppConstants.tapThreshold {
                // Tap logic (skipped; assume no side effects for this test)
            } else {
                // Drag branch skipped due to small distance
            }
        }
        
        let edgeCountAfter = await MainActor.run { model.edges.count }
        #expect(edgeCountAfter == initialEdgeCount, "No edge created on short drag")
        let node0PositionAfterTap = await MainActor.run { model.nodes[0].position }
        #expect(approximatelyEqual(node0PositionAfterTap, initialPosition, accuracy: 1e-5), "Position unchanged")
    }
    
    @Test func testDragMovesNodeIfEdgeExists() async throws {
        let model = await setupModel()
        
        // Ensure at least two nodes exist before indexing
        let currentCount = await model.nodes.count
        if currentCount < 2 {
            await model.addNode(at: .zero)
            await model.addNode(at: CGPoint(x: 100, y: 100))
            await model.startSimulation()
            await model.stopSimulation()
        }

        let fromID = (await model.nodes[0]).id
        let toID = (await model.nodes[1]).id
        await MainActor.run { model.edges.append(GraphEdge(from: fromID, target: toID)) }
        #expect((await model.edges).count == 1, "Edge exists initially")
        
        let viewModel = await MainActor.run { GraphViewModel(model: model) }
        let params = await prepareDragParameters(model: model)
        
        if let index = (await viewModel.model.nodes).firstIndex(where: { $0.id == params.draggedNode.id }) {
            await viewModel.model.snapshot()
            if params.dragDistance < AppConstants.tapThreshold {
                // Tap logic (skipped)
            } else {
                await performDragAction(viewModel: viewModel, draggedNode: params.draggedNode, potentialEdgeTarget: params.potentialEdgeTarget, dragOffset: params.dragOffset, index: index)
            }
        }
        
        let finalEdgeCount2 = await MainActor.run { viewModel.model.edges.count }
        #expect(finalEdgeCount2 == 1, "No new edge created")
        // OPTIONAL: If you want to verify post-simulation (e.g., position changed but not exactly by offset), add looser checks here
    }
    
    private struct DragParameters {
        let draggedNode: any NodeProtocol
        let potentialEdgeTarget: any NodeProtocol
        let initialPosition: CGPoint
        let mockTranslation: CGSize
        let dragOffset: CGPoint
        let dragDistance: CGFloat
    }
    
    private func prepareDragParameters(model: GraphModel) async -> DragParameters {
        let draggedNode = await model.nodes[0]
        let potentialEdgeTarget = await model.nodes[1]
        let initialPosition = draggedNode.position
        
        let mockTranslation = CGSize(width: 50, height: 50)
        let dragOffset = CGPoint(x: mockTranslation.width / 1.0, y: mockTranslation.height / 1.0)
        let dragDistance = hypot(mockTranslation.width, mockTranslation.height)
        
        return DragParameters(
            draggedNode: draggedNode,
            potentialEdgeTarget: potentialEdgeTarget,
            initialPosition: initialPosition,
            mockTranslation: mockTranslation,
            dragOffset: dragOffset,
            dragDistance: dragDistance
        )
    }
    
    private func performDragAction(viewModel: GraphViewModel, draggedNode: any NodeProtocol, potentialEdgeTarget: any NodeProtocol, dragOffset: CGPoint, index: Int) async {
        if potentialEdgeTarget.id != draggedNode.id {
            let fromID = draggedNode.id
            let toID = potentialEdgeTarget.id
            let edgeExists = await MainActor.run {
                let edges = viewModel.model.edges
                let forwardMatch = edges.contains { $0.from == fromID && $0.target == toID }
                let reverseMatch = edges.contains { $0.from == toID && $0.target == fromID }
                return forwardMatch || reverseMatch
            }
            if !edgeExists {
                await MainActor.run { viewModel.model.edges.append(GraphEdge(from: fromID, target: toID)) }
                await viewModel.model.startSimulation()
                await viewModel.model.stopSimulation()
            } else {
                await MainActor.run {
                    let currentPos = viewModel.model.nodes[index].position
                    viewModel.model.nodes[index] = viewModel.model.nodes[index].with(position: CGPoint(x: currentPos.x + dragOffset.x, y: currentPos.y + dragOffset.y), velocity: .zero)
                }
                let posAfterImmediateMove = await MainActor.run { viewModel.model.nodes[0].position }
                let initialPosition = draggedNode.position
                #expect(!approximatelyEqual(posAfterImmediateMove, initialPosition, accuracy: 1e-5), "Position changed on move")
                #expect(approximatelyEqual(posAfterImmediateMove, CGPoint(x: initialPosition.x + dragOffset.x, y: initialPosition.y + dragOffset.y), accuracy: 1e-5), "Moved by offset")
                await viewModel.model.startSimulation()  // Keep this if needed for side effects, but checks are now before it
                await viewModel.model.stopSimulation()
            }
        }
    }
    
    func approximatelyEqual(_ lhs: CGPoint, _ rhs: CGPoint, accuracy: CGFloat) -> Bool {
        return hypot(lhs.x - rhs.x, lhs.y - rhs.y) < accuracy
    }
}
----------------------------------------------------------------------------------------------------
File: GraphEditorWatchTests.swift
Path: GraphEditorWatchTests/GraphEditorWatchTests.swift
Last modified: 2025-10-09 08:04:41

Contents:
import Testing
import Foundation
import CoreGraphics
@testable import GraphEditorWatch
@testable import GraphEditorShared
import XCTest
import SwiftUI

class MockGraphStorage: GraphStorage {
    // In-memory single-graph (default) storage for convenience in tests
    var nodes: [any NodeProtocol] = []
    var edges: [GraphEdge] = []
    var savedViewState: ViewState?

    // In-memory multi-graph storage
    private var graphs: [String: (nodes: [any NodeProtocol], edges: [GraphEdge])] = [:]
    private var viewStates: [String: ViewState] = [:]
    private let defaultName = "default"

    // MARK: - Single-graph (default) methods
    func save(nodes: [any NodeProtocol], edges: [GraphEdge]) async throws {
        self.nodes = nodes
        self.edges = edges
        // Keep default graph in sync
        graphs[defaultName] = (nodes, edges)
    }

    func load() async throws -> (nodes: [any NodeProtocol], edges: [GraphEdge]) {
        return (nodes, edges)
    }

    func clear() async throws {
        nodes = []
        edges = []
        savedViewState = nil
        graphs[defaultName] = ([], [])
        viewStates.removeValue(forKey: defaultName)
    }

    func saveViewState(_ viewState: ViewState) async throws {
        savedViewState = viewState
        viewStates[defaultName] = viewState
    }

    func loadViewState() async throws -> ViewState? {
        return savedViewState
    }

    // MARK: - Multi-graph methods
    func listGraphNames() async throws -> [String] {
        var names = Set(graphs.keys)
        names.insert(defaultName)
        return Array(names).sorted()
    }

    func createNewGraph(name: String) async throws {
        if graphs[name] != nil {
            throw GraphStorageError.graphExists(name)
        }
        graphs[name] = ([], [])
        viewStates.removeValue(forKey: name)
    }

    func save(nodes: [any NodeProtocol], edges: [GraphEdge], for name: String) async throws {
        graphs[name] = (nodes, edges)
        if name == defaultName {
            self.nodes = nodes
            self.edges = edges
        }
    }

    func load(for name: String) async throws -> (nodes: [any NodeProtocol], edges: [GraphEdge]) {
        if name == defaultName {
            return (nodes, edges)
        }
        if let state = graphs[name] {
            return state
        }
        throw GraphStorageError.graphNotFound(name)
    }

    func deleteGraph(name: String) async throws {
        if name == defaultName {
            nodes = []
            edges = []
            savedViewState = nil
            graphs[defaultName] = ([], [])
            viewStates.removeValue(forKey: defaultName)
            return
        }
        guard graphs.removeValue(forKey: name) != nil else {
            throw GraphStorageError.graphNotFound(name)
        }
        viewStates.removeValue(forKey: name)
    }

    // MARK: - View state per graph (sync variants required by protocol)
    func saveViewState(_ viewState: ViewState, for name: String) throws {
        viewStates[name] = viewState
        if name == defaultName {
            savedViewState = viewState
        }
    }

    func loadViewState(for name: String) throws -> ViewState? {
        if name == defaultName {
            return savedViewState ?? viewStates[name]
        }
        return viewStates[name]
    }
}

@MainActor @Test func testUndoRedoRoundTrip() async {
    let storage = MockGraphStorage()
    let physicsEngine = PhysicsEngine(simulationBounds: CGSize(width: 500, height: 500))
    let model = GraphModel(storage: storage, physicsEngine: physicsEngine)
    try? await model.loadGraph()  // Explicit load to start empty
    let initialNode = AnyNode(Node(id: UUID(), label: 1, position: .zero))
    await model.snapshot()  // Pre-add initial (appends empty)
    model.nodes = [initialNode]  // "Add" initial
    let newNode = AnyNode(Node(id: UUID(), label: 2, position: .zero))
    await model.snapshot()  // Pre-add new (appends [initial])
    model.nodes.append(newNode)  // Add new
    await model.undo()  // Back to 1 node
    #expect(model.nodes.count == 1, "Undo removes node")
    #expect(model.nodes[0].id == initialNode.id, "Initial state restored")
    #expect(model.redoStack.count == 1, "Redo stack populated")
    await model.redo()  // Forward to 2 nodes
    #expect(model.nodes.count == 2, "Redo adds node")
    #expect(model.undoStack.count == 2, "Undo stack updated")
}
----------------------------------------------------------------------------------------------------
File: GraphGesturesModifierTests.swift
Path: GraphEditorWatchTests/GraphGesturesModifierTests.swift
Last modified: 2025-10-07 16:10:08

Contents:
//
//  GraphGesturesModifierTests.swift
//  GraphEditorWatch
//
//  Created by handcart on 9/25/25.
//
import Testing
import SwiftUI
@testable import GraphEditorWatch
@testable import GraphEditorShared

struct GraphGesturesModifierTests {
    private func setupViewModel() async -> GraphViewModel {
        let storage = MockGraphStorage()
        let physicsEngine = PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
        let model = await MainActor.run { GraphModel(storage: storage, physicsEngine: physicsEngine) }
        return await MainActor.run { GraphViewModel(model: model) }
    }
    
    private func createModifier(viewModel: GraphViewModel,
                                selectedNodeID: Binding<NodeID?>,
                                selectedEdgeID: Binding<UUID?>) -> GraphGesturesModifier {
        GraphGesturesModifier(
            viewModel: viewModel,
            zoomScale: .constant(1.0),
            offset: .constant(.zero),
            draggedNode: .constant(nil),
            dragOffset: .constant(.zero),
            potentialEdgeTarget: .constant(nil),
            selectedNodeID: selectedNodeID,
            selectedEdgeID: selectedEdgeID,
            viewSize: CGSize(width: 300, height: 300),
            panStartOffset: .constant(nil),
            showMenu: .constant(false),
            maxZoom: 5.0,
            crownPosition: .constant(0.0),
            onUpdateZoomRanges: {},
            isAddingEdge: .constant(false)
        )
    }
    
    @MainActor @Test func testHitTestNodesInScreenSpace() async {
        let viewModel = await setupViewModel()
        _ = createModifier(viewModel: viewModel,
                                      selectedNodeID: .constant(nil),
                                      selectedEdgeID: .constant(nil))
        
        let nodes = [AnyNode(Node(label: 1, position: CGPoint(x: 100, y: 100)))]
        let context = GestureContext(zoomScale: 1.0, offset: CGSize.zero, viewSize: CGSize(width: 300, height: 300), effectiveCentroid: CGPoint.zero)
        // Compute screen pos: viewCenter (150,150) + zoom * (model - centroid) + offset = (150,150) + 1*(100-0,100-0) + (0,0) = (250,250)
        let screenTapPos = CGPoint(x: 250, y: 250)
        let hitContext = HitTestContext(zoomScale: context.zoomScale, offset: context.offset, viewSize: context.viewSize, effectiveCentroid: context.effectiveCentroid)
        let hitNode = HitTestHelper.closestNode(at: screenTapPos, visibleNodes: nodes, context: hitContext)
        #expect(hitNode != nil, "Should hit node within radius")
    }
    
    @Test func testPointToLineDistance() async {
        let viewModel = await setupViewModel()
        let modifier = createModifier(viewModel: viewModel,
                                      selectedNodeID: .constant(nil),
                                      selectedEdgeID: .constant(nil))
        let dist = await MainActor.run {
            modifier.pointToLineDistance(point: CGPoint(x: 0, y: 1), from: CGPoint.zero, endPoint: CGPoint(x: 2, y: 0))
        }
        #expect(dist == 1.0, "Perpendicular distance to line")
    }
    
    @Test func testHandleTap() async {
        let viewModel = await setupViewModel()
        var testSelectedNodeID: NodeID?
        var testSelectedEdgeID: UUID?
        let selectedNodeBinding = Binding<NodeID?>(
            get: { testSelectedNodeID },
            set: { testSelectedNodeID = $0 }
        )
        let selectedEdgeBinding = Binding<UUID?>(
            get: { testSelectedEdgeID },
            set: { testSelectedEdgeID = $0 }
        )
        let modifier = createModifier(viewModel: viewModel,
                                      selectedNodeID: selectedNodeBinding,
                                      selectedEdgeID: selectedEdgeBinding)
        let nodes = [AnyNode(Node(label: 1, position: CGPoint.zero))]
        let edges = [GraphEdge(from: nodes[0].id, target: nodes[0].id)]  // Self-edge for test
        let context = GestureContext(zoomScale: 1.0, offset: CGSize.zero, viewSize: CGSize(width: 300, height: 300), effectiveCentroid: CGPoint.zero)
        
        // Compute screen pos for model .zero: (150,150) + 1*(0-0,0-0) + (0,0) = (150,150)
        let screenTapPos = CGPoint(x: 150, y: 150)
        _ = await MainActor.run {
            modifier.handleTap(at: screenTapPos, visibleNodes: nodes, visibleEdges: edges, context: context)
        }
        // Assert on mocked bindings
        #expect(testSelectedNodeID != nil, "Node should be selected after tap")
        #expect(testSelectedEdgeID == nil, "No edge selected")
    }
}
--------------------------------------------------
