## Focused Project Concatenation
This file includes only UI, interactivity, model, and core logic files.
Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
Current date: 2025-10-17 17:38:36
Table of Contents:
1. GraphEditorWatchTests/GraphGesturesModifierTests.swift
2. GraphEditorWatchTests/GraphModelTests.swift
3. GraphEditorWatchTests/MenuViewTests.swift
4. GraphEditorWatchUITests/GraphEditorWatchUITests.swift
5. GraphEditorWatchUITests/GraphEditorWatchUITestsLaunchTests.swift--------------------------------------------------
File: GraphGesturesModifierTests.swift
Path: GraphEditorWatchTests/GraphGesturesModifierTests.swift
Last modified: 2025-10-17 07:44:45

Contents:
//
//  GraphGesturesModifierTests.swift
//  GraphEditorWatch
//
//  Created by handcart on 9/25/25.
//
import Testing
import SwiftUI
@testable import GraphEditorWatch
@testable import GraphEditorShared

struct GraphGesturesModifierTests {
    private func setupViewModel() async -> GraphViewModel {
        let storage = MockGraphStorage()
        let physicsEngine = PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
        let model = await MainActor.run { GraphModel(storage: storage, physicsEngine: physicsEngine) }
        return await MainActor.run { GraphViewModel(model: model) }
    }
    
    private func createModifier(viewModel: GraphViewModel,
                                selectedNodeID: Binding<NodeID?>,
                                selectedEdgeID: Binding<UUID?>) -> GraphGesturesModifier {
        GraphGesturesModifier(
            viewModel: viewModel,
            zoomScale: .constant(1.0),
            offset: .constant(.zero),
            draggedNode: .constant(nil),
            dragOffset: .constant(.zero),
            potentialEdgeTarget: .constant(nil),
            selectedNodeID: selectedNodeID,
            selectedEdgeID: selectedEdgeID,
            viewSize: CGSize(width: 300, height: 300),
            panStartOffset: .constant(nil),
            showMenu: .constant(false),
            maxZoom: 5.0,
            crownPosition: .constant(0.0),
            onUpdateZoomRanges: {},
            isAddingEdge: .constant(false),
            isSimulating: .constant(true),
            saturation: .constant(1.0)  // Add this line
        )
    }
    
    @MainActor @Test func testHitTestNodesInScreenSpace() async {
        let viewModel = await setupViewModel()
        _ = createModifier(viewModel: viewModel,
                                      selectedNodeID: .constant(nil),
                                      selectedEdgeID: .constant(nil))
        
        let nodes = [AnyNode(Node(label: 1, position: CGPoint(x: 100, y: 100)))]
        let context = GestureContext(zoomScale: 1.0, offset: CGSize.zero, viewSize: CGSize(width: 300, height: 300), effectiveCentroid: CGPoint.zero)
        // Compute screen pos: viewCenter (150,150) + zoom * (model - centroid) + offset = (150,150) + 1*(100-0,100-0) + (0,0) = (250,250)
        let screenTapPos = CGPoint(x: 250, y: 250)
        let hitContext = HitTestContext(zoomScale: context.zoomScale, offset: context.offset, viewSize: context.viewSize, effectiveCentroid: context.effectiveCentroid)
        let hitNode = HitTestHelper.closestNode(at: screenTapPos, visibleNodes: nodes, context: hitContext)
        #expect(hitNode != nil, "Should hit node within radius")
    }
    
    @Test func testPointToLineDistance() async {
        let viewModel = await setupViewModel()
        let modifier = createModifier(viewModel: viewModel,
                                      selectedNodeID: .constant(nil),
                                      selectedEdgeID: .constant(nil))
        let dist = await MainActor.run {
            modifier.pointToLineDistance(point: CGPoint(x: 0, y: 1), from: CGPoint.zero, endPoint: CGPoint(x: 2, y: 0))
        }
        #expect(dist == 1.0, "Perpendicular distance to line")
    }
    
    @Test func testHandleTap() async {
        let viewModel = await setupViewModel()
        var testSelectedNodeID: NodeID?
        var testSelectedEdgeID: UUID?
        let selectedNodeBinding = Binding<NodeID?>(
            get: { testSelectedNodeID },
            set: { testSelectedNodeID = $0 }
        )
        let selectedEdgeBinding = Binding<UUID?>(
            get: { testSelectedEdgeID },
            set: { testSelectedEdgeID = $0 }
        )
        let modifier = createModifier(viewModel: viewModel,
                                      selectedNodeID: selectedNodeBinding,
                                      selectedEdgeID: selectedEdgeBinding)
        let nodes = [AnyNode(Node(label: 1, position: CGPoint.zero))]
        let edges = [GraphEdge(from: nodes[0].id, target: nodes[0].id)]  // Self-edge for test
        let context = GestureContext(zoomScale: 1.0, offset: CGSize.zero, viewSize: CGSize(width: 300, height: 300), effectiveCentroid: CGPoint.zero)
        
        // Compute screen pos for model .zero: (150,150) + 1*(0-0,0-0) + (0,0) = (150,150)
        let screenTapPos = CGPoint(x: 150, y: 150)
        _ = await MainActor.run {
            modifier.handleTap(at: screenTapPos, visibleNodes: nodes, visibleEdges: edges, context: context)
        }
        // Assert on mocked bindings
        #expect(testSelectedNodeID != nil, "Node should be selected after tap")
        #expect(testSelectedEdgeID == nil, "No edge selected")
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModelTests.swift
Path: GraphEditorWatchTests/GraphModelTests.swift
Last modified: 2025-10-09 08:09:11

Contents:
//
//  GraphModelTests.swift
//  GraphEditor
//
//  Created by handcart on 9/22/25.
//

import Testing
import Foundation
import CoreGraphics
@testable import GraphEditorWatch
@testable import GraphEditorShared
import XCTest
import SwiftUI

struct GraphModelTests {
    private func mockPhysicsEngine() -> GraphEditorShared.PhysicsEngine {
        GraphEditorShared.PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
    }
    
    private func setupDefaults(for storage: MockGraphStorage) async throws {
        let node1 = AnyNode(Node(label: 1, position: CGPoint(x: 100, y: 100)))
        let node2 = AnyNode(Node(label: 2, position: CGPoint(x: 200, y: 200)))
        let node3 = AnyNode(Node(label: 3, position: CGPoint(x: 150, y: 150)))
        let edge1 = GraphEdge(from: node1.id, target: node2.id)
        let edge2 = GraphEdge(from: node2.id, target: node3.id)
        let edge3 = GraphEdge(from: node3.id, target: node1.id)
        try await storage.save(nodes: [node1, node2, node3], edges: [edge1, edge2, edge3])
    }
    
    private func generateNodesAndEdges(seed: Int) async -> ([AnyNode], [GraphEdge]) {
        struct SeededRandomNumberGenerator: RandomNumberGenerator {
            private var state: UInt64
            init(seed: UInt64) {
                state = seed
            }
            mutating func next() -> UInt64 {
                state &+= 1442695040888963407
                state &*= 6364136223846793005
                return state
            }
        }
        var rng = SeededRandomNumberGenerator(seed: UInt64(seed))
        var nodesToAssign: [AnyNode] = []
        for _ in 0..<5 {
            let label = Int.random(in: 0..<10, using: &rng)
            let positionX = CGFloat.random(in: 0..<300, using: &rng)
            let positionY = CGFloat.random(in: 0..<300, using: &rng)
            nodesToAssign.append(AnyNode(Node(label: label, position: CGPoint(x: positionX, y: positionY))))
        }
        var edgesToAssign: [GraphEdge] = []
        for _ in 0..<3 {
            let fromIndex = Int.random(in: 0..<nodesToAssign.count, using: &rng)
            let targetIndex = Int.random(in: 0..<nodesToAssign.count, using: &rng)
            edgesToAssign.append(GraphEdge(from: nodesToAssign[fromIndex].id, target: nodesToAssign[targetIndex].id))
        }
        return (nodesToAssign, edgesToAssign)
    }
    
    private func runSimulation(on model: GraphModel) async {
        let physics = await MainActor.run { model.physicsEngine }
        physics.resetSimulation()
        let maxSteps = Constants.Physics.maxSimulationSteps
        for _ in 0..<maxSteps {
            let nodes = await model.nodes.map { $0.unwrapped }
            let edges = await model.edges
            let (updatedNodes, isActive) = physics.simulationStep(nodes: nodes, edges: edges)
            await MainActor.run { model.nodes = updatedNodes.map(AnyNode.init) }
            physics.alpha *= (1 - Constants.Physics.alphaDecay)
            if !isActive { break }
        }
    }
    
    @Test(arguments: 1..<5) func testConvergencePropertyBased(seed: Int) async throws {
        let storage = MockGraphStorage()
        let model = await MainActor.run { GraphModel(storage: storage, physicsEngine: mockPhysicsEngine()) }
        await model.load()
        let (nodesToAssign, edgesToAssign) = await generateNodesAndEdges(seed: seed)
        await MainActor.run {
            model.nodes = nodesToAssign
            model.edges = edgesToAssign
        }
        await runSimulation(on: model)
        let totalVel = (await model.nodes).reduce(0.0) { $0 + hypot($1.velocity.x, $1.velocity.y) }
        #expect(totalVel < 4.0, "Simulation converged to low velocity for seed \(seed)")
    }
    
    @MainActor @Test func testUndoRedoMixedOperations() async throws {
        let storage = MockGraphStorage()
        let model = GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        await model.load()
        await model.addNode(at: CGPoint.zero)
        await runSimulation(on: model)
        await model.snapshot()  // Explicit snapshot after initial simulation to capture positions
        let initialNodes = model.nodes
        let initialNodeCount = initialNodes.count
        let initialEdgeCount = model.edges.count
        let nodeToDelete = initialNodes[0].id
        let connectedEdges = model.edges.filter { $0.from == nodeToDelete || $0.target == nodeToDelete }.count
        await model.snapshot()  // Explicit before delete
        await model.deleteNode(withID: nodeToDelete)
        await runSimulation(on: model)
        await model.addNode(at: CGPoint(x: 50, y: 50))
        await runSimulation(on: model)
        await model.undo(resume: false)
        #expect(model.nodes.count == initialNodeCount - 1, "Undo reverts to post-delete")
        #expect(model.edges.count == initialEdgeCount - connectedEdges, "Edges match post-delete")
        await model.undo(resume: false)
        #expect(model.nodes.count == initialNodeCount, "Second undo restores initial")
        #expect(model.edges.count == initialEdgeCount, "Edges restored")
        let restoredNodes = model.nodes
        #expect(zip(restoredNodes.sorted(by: { $0.id.uuidString < $1.id.uuidString }), initialNodes.sorted(by: { $0.id.uuidString < $1.id.uuidString })).allSatisfy { approximatelyEqual($0.position, $1.position, accuracy: 1e-5) && approximatelyEqual($0.velocity, $1.velocity, accuracy: 1e-5) }, "Positions and velocities restored")
        await model.redo(resume: false)
        #expect(model.nodes.count == initialNodeCount - 1, "Redo applies delete")
        await model.redo(resume: false)
        #expect(model.nodes.count == initialNodeCount, "Redo applies add")
    }
    
    @Test func testInitializationWithDefaults() async throws {
        let storage = MockGraphStorage()
        try await setupDefaults(for: storage)
        let model = await MainActor.run { GraphModel(storage: storage, physicsEngine: mockPhysicsEngine()) }
        await model.load()
        #expect(await MainActor.run { model.nodes.count } >= 3, "Should load default or saved nodes")
        #expect(await MainActor.run { model.edges.count } >= 3, "Should load default edges")
    }
    
    @Test func testDeleteNodeAndEdges() async throws {
        let storage = MockGraphStorage()
        try await setupDefaults(for: storage)
        let model = await MainActor.run { GraphModel(storage: storage, physicsEngine: mockPhysicsEngine()) }
        await model.load()
        let nodes = await model.nodes
        try #require(!nodes.isEmpty, "Assumes default nodes exist")
        let nodeToDelete = nodes[0].id
        let initialEdgeCount = await model.edges.count
        let connectedEdges = (await model.edges).filter { $0.from == nodeToDelete || $0.target == nodeToDelete }.count
        await model.deleteNode(withID: nodeToDelete)
        #expect(await MainActor.run { model.nodes.count } == nodes.count - 1, "Node deleted")
        #expect(await MainActor.run { model.edges.count } == initialEdgeCount - connectedEdges, "Connected edges deleted")
    }
    
    @Test func testSaveLoadRoundTrip() async throws {
        let storage = MockGraphStorage()
        try await setupDefaults(for: storage)
        let model = await MainActor.run { GraphModel(storage: storage, physicsEngine: mockPhysicsEngine()) }
        await model.load()
        let originalNodeCount = await MainActor.run { model.nodes.count }
        let originalEdges = await model.edges
        await model.addNode(at: CGPoint.zero)
        await runSimulation(on: model)
        let postAddNodes = await model.nodes  // Capture after add and simulation
        await model.snapshot()  // Triggers save() with stabilized positions
        let newModel = await MainActor.run { GraphModel(storage: storage, physicsEngine: mockPhysicsEngine()) }
        await newModel.load()
        // Skip runSimulation(on: newModel) - loaded positions should match saved exactly; re-sim amplifies FP errors
        #expect(await MainActor.run { newModel.nodes.count } == originalNodeCount + 1, "Loaded nodes include added one")
        #expect(await newModel.edges == originalEdges, "Edges unchanged")
        let loadedNodes = (await newModel.nodes).sorted(by: { $0.id.uuidString < $1.id.uuidString })
        let expectedNodes = postAddNodes.sorted(by: { $0.id.uuidString < $1.id.uuidString })
        #expect(zip(loadedNodes, expectedNodes).allSatisfy {
            $0.label == $1.label && approximatelyEqual($0.position, $1.position, accuracy: 1e-2)  // Further relaxed for any JSON/FP rounding
        }, "Loaded nodes match expected")
    }
    
    @MainActor @Test func testUndoRedoRoundTrip() async {
        let storage = MockGraphStorage()
        let physicsEngine = PhysicsEngine(simulationBounds: CGSize(width: 500, height: 500))
        let model = GraphModel(storage: storage, physicsEngine: physicsEngine)
        try? await model.loadGraph()  // Explicit load to start empty
        let initialNode = AnyNode(Node(id: UUID(), label: 1, position: .zero))
        await model.snapshot()  // Pre-add initial (appends empty)
        model.nodes = [initialNode]  // "Add" initial
        let newNode = AnyNode(Node(id: UUID(), label: 2, position: .zero))
        await model.snapshot()  // Pre-add new (appends [initial])
        model.nodes.append(newNode)  // Add new
        await model.undo()  // Back to 1 node
        #expect(model.nodes.count == 1, "Undo removes node")
        #expect(model.nodes[0].id == initialNode.id, "Initial state restored")
        #expect(model.redoStack.count == 1, "Redo stack populated")
        await model.redo()  // Forward to 2 nodes
        #expect(model.nodes.count == 2, "Redo adds node")
        #expect(model.undoStack.count == 2, "Undo stack updated")
    }
    
    internal func approximatelyEqual(_ lhs: CGPoint, _ rhs: CGPoint, accuracy: CGFloat) -> Bool {
        hypot(lhs.x - rhs.x, lhs.y - rhs.y) < accuracy
    }
}
----------------------------------------------------------------------------------------------------
File: MenuViewTests.swift
Path: GraphEditorWatchTests/MenuViewTests.swift
Last modified: 2025-09-25 14:19:07

Contents:
//
//  MenuViewTests.swift
//  GraphEditor
//
//  Created by handcart on 9/25/25.
//
import Testing
import SwiftUI
@testable import GraphEditorWatch
@testable import GraphEditorShared

struct MenuViewTests {
    private func setupViewModel() async -> GraphViewModel {
        let storage = MockGraphStorage()
        let physicsEngine = PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
        let model = await GraphModel(storage: storage, physicsEngine: physicsEngine)
        return await GraphViewModel(model: model)
    }

    @Test func testEditSectionDeleteNode() async {
        let viewModel = await setupViewModel()
        let node = AnyNode(Node(label: 1, position: .zero))
        await MainActor.run { viewModel.model.nodes = [node] }
        _ = EditSection(viewModel: viewModel, selectedNodeID: node.id, selectedEdgeID: nil, onDismiss: {}, onEditNode: {})
        
        // Simulate button tap (manual test logic; for full UI test, use XCUITest)
        await viewModel.deleteNode(withID: node.id)
        #expect(await viewModel.model.nodes.isEmpty, "Node deleted")
    }
}
----------------------------------------------------------------------------------------------------
File: GraphEditorWatchUITests.swift
Path: GraphEditorWatchUITests/GraphEditorWatchUITests.swift
Last modified: 2025-10-17 16:23:50

Contents:
//
//  GraphEditorWatchUITests.swift
//  GraphEditorWatchUITests
//
//  Created by handcart on 8/4/25.
//

import XCTest

extension XCUIApplication {
    func waitForElement(_ element: XCUIElement, timeout: TimeInterval = 5.0, file: StaticString = #file, line: UInt = #line) {
        XCTAssertTrue(element.waitForExistence(timeout: timeout), "Element did not appear: \(element)", file: file, line: line)
    }
}

extension XCTestCase {
    func waitUntilElementHasFocus(element: XCUIElement, timeout: TimeInterval = 5.0, file: StaticString = #file, line: UInt = #line) {
        let expectation = expectation(description: "waiting for element \(element) to have focus")
        let timer = Timer(timeInterval: 0.5, repeats: true) { timer in
            if element.value(forKey: "hasKeyboardFocus") as? Bool ?? false {
                expectation.fulfill()
                timer.invalidate()
            }
        }
        RunLoop.current.add(timer, forMode: .common)
        wait(for: [expectation], timeout: timeout)
    }
}

final class GraphEditorWatchUITests: XCTestCase {
    override func setUpWithError() throws {
        continueAfterFailure = false
        let app = XCUIApplication()
        app.terminate()
        app.launch()
        Thread.sleep(forTimeInterval: 2.0)  // Settle time
        
        print("Post-launch hierarchy: \(app.debugDescription)")
        
        let canvas = app.buttons["GraphCanvas"]
        XCTAssertTrue(canvas.waitForExistence(timeout: 10), "Graph canvas should appear on launch")
        
        // Deselect any selected items by tapping center multiple times (to ensure no selection for full menu)
        let centerCoord = canvas.coordinate(withNormalizedOffset: CGVector(dx: 0.5, dy: 0.5))
        centerCoord.tap()
        Thread.sleep(forTimeInterval: 0.5)
        centerCoord.tap()
        Thread.sleep(forTimeInterval: 0.5)
        
        // Pan once with negative offsets (drag left/up to move graph right/down)
        let endCoordRight = centerCoord.withOffset(CGVector(dx: -1000, dy: 0))
        centerCoord.press(forDuration: 0.1, thenDragTo: endCoordRight)
        Thread.sleep(forTimeInterval: 0.3)
        let endCoordDown = centerCoord.withOffset(CGVector(dx: 0, dy: -1000))
        centerCoord.press(forDuration: 0.1, thenDragTo: endCoordDown)
        Thread.sleep(forTimeInterval: 0.3)
        
        // Retry long press up to 2x, with pre-tap for focus and 5s duration
        let menuList = app.scrollViews["menuList"]
        var menuOpened = false
        let cornerCoord = canvas.coordinate(withNormalizedOffset: CGVector(dx: 0.5, dy: 0.5))  // Center
        for attempt in 1...2 {
            print("Attempt \(attempt) to open menu via long press in setUp")
            cornerCoord.tap()  // Pre-tap for focus
            Thread.sleep(forTimeInterval: 0.3)
            cornerCoord.press(forDuration: 5.0)
            Thread.sleep(forTimeInterval: 2.0)  // Increased post-press sleep
            
            print("Canvas label after long press (attempt \(attempt)): \(canvas.label)")
            print("Post-long press hierarchy (attempt \(attempt)): \(app.debugDescription)")
            
            let attachment = XCTAttachment(screenshot: app.screenshot())
            attachment.name = "Post-long-press-setUp-attempt-\(attempt)"
            attachment.lifetime = .keepAlways
            add(attachment)
            
            if menuList.waitForExistence(timeout: 5.0) {
                menuOpened = true
                break
            }
            // Tap to dismiss if stuck
            centerCoord.tap()
            Thread.sleep(forTimeInterval: 0.5)
        }
        XCTAssertTrue(menuOpened, "Menu list should appear after long press (after retries) in setUp")
        
        // Dismiss any unexpected sheets (use firstMatch for multiple matches)
        let closeButton = app.buttons["close-sheet"].firstMatch
        if closeButton.waitForExistence(timeout: 2.0) {
            closeButton.tap()
            Thread.sleep(forTimeInterval: 0.5)
        }
        
        let newGraphButton = app.buttons["newGraphButton"]
        scrollUntilVisible(element: newGraphButton, in: menuList, maxAttempts: 20)
        XCTAssertTrue(newGraphButton.waitForExistence(timeout: 5), "New Graph button should appear after menu open")
        newGraphButton.tap()
        Thread.sleep(forTimeInterval: 1.0)
        print("Post-newGraph tap hierarchy: \(app.debugDescription)")
        
        let newGraphNameField = app.textFields["newGraphNameTextField"]
        XCTAssertTrue(newGraphNameField.waitForExistence(timeout: 3), "New Graph Name field should appear")
        newGraphNameField.tap()
        waitUntilElementHasFocus(element: newGraphNameField, timeout: 3)
        newGraphNameField.typeText("TestGraph")
        Thread.sleep(forTimeInterval: 0.5)
        
        let createButton = app.buttons["createButton"]
        XCTAssertTrue(createButton.waitForExistence(timeout: 3), "Create button should appear")
        createButton.tap()
        Thread.sleep(forTimeInterval: 1.0)
        
        print("Post-create hierarchy: \(app.debugDescription)")
        
        // Verify reset with waiter
        let emptyLabel = "Graph with 0 nodes and 0 edges. No node or edge selected."
        let emptyPredicate = NSPredicate(format: "label == %@", emptyLabel)
        let emptyExpectation = expectation(for: emptyPredicate, evaluatedWith: canvas)
        let emptyResult = XCTWaiter.wait(for: [emptyExpectation], timeout: 5.0)
        XCTAssert(emptyResult == .completed, "Graph should be empty after reset in setUp")
        
        app.terminate()  // Ensure clean state
    }
    
    // Helper to scroll until visible/hittable (swipeUp and swipeDown alternately)
    private func scrollUntilVisible(element: XCUIElement, in container: XCUIElement, maxAttempts: Int = 20) {
        var attempts = 0
        while !element.isHittable && attempts < maxAttempts {
            if attempts % 2 == 0 {
                container.swipeUp()
            } else {
                container.swipeDown()
            }
            Thread.sleep(forTimeInterval: 0.5)
            attempts += 1
        }
        XCTAssertLessThan(attempts, maxAttempts, "Failed to make element visible after \(maxAttempts) attempts")
    }
    
    func testMenuDisplayAndAction() throws {
        let app = XCUIApplication()
        let canvas = app.buttons["GraphCanvas"]
        XCTAssertTrue(canvas.waitForExistence(timeout: 5), "Graph canvas should appear after reset")
        
        let emptyLabel = "Graph with 0 nodes and 0 edges. No node or edge selected."
        XCTAssertEqual(canvas.label, emptyLabel, "Graph should start empty")
        
        // Pan once
        let centerCoord = canvas.coordinate(withNormalizedOffset: CGVector(dx: 0.5, dy: 0.5))
        let endCoordRight = centerCoord.withOffset(CGVector(dx: -1000, dy: 0))
        centerCoord.press(forDuration: 0.1, thenDragTo: endCoordRight)
        Thread.sleep(forTimeInterval: 0.3)
        let endCoordDown = centerCoord.withOffset(CGVector(dx: 0, dy: -1000))
        centerCoord.press(forDuration: 0.1, thenDragTo: endCoordDown)
        Thread.sleep(forTimeInterval: 0.3)
        
        // Long press with 2 retries, pre-tap, 5s duration
        let menuList = app.scrollViews["menuList"]
        var menuOpened = false
        let cornerCoord = canvas.coordinate(withNormalizedOffset: CGVector(dx: 0.5, dy: 0.5))  // Center
        for attempt in 1...2 {
            print("Attempt \(attempt) to open menu for testMenuDisplayAndAction")
            cornerCoord.tap()  // Pre-tap
            Thread.sleep(forTimeInterval: 0.3)
            cornerCoord.press(forDuration: 5.0)
            Thread.sleep(forTimeInterval: 2.0)  // Increased post-press sleep
            
            print("Canvas label after long press (attempt \(attempt)): \(canvas.label)")
            print("Post-long press hierarchy (attempt \(attempt)): \(app.debugDescription)")
            
            let attachment = XCTAttachment(screenshot: app.screenshot())
            attachment.name = "Post-long-press-testMenu-attempt-\(attempt)"
            attachment.lifetime = .keepAlways
            add(attachment)
            
            if menuList.waitForExistence(timeout: 5.0) {
                menuOpened = true
                break
            }
            // Tap to dismiss if stuck
            centerCoord.tap()
            Thread.sleep(forTimeInterval: 0.5)
        }
        XCTAssertTrue(menuOpened, "Menu list should appear after long press")
        
        let addNodeButton = app.buttons["addNodeButton"]
        scrollUntilVisible(element: addNodeButton, in: menuList, maxAttempts: 20)
        XCTAssertTrue(addNodeButton.waitForExistence(timeout: 3), "Add Node button should appear")
        addNodeButton.tap()
        Thread.sleep(forTimeInterval: 0.5)
        
        // Check updated label
        let updatedLabel = "Graph with 1 node and 0 edges. No node or edge selected."
        let predicate = NSPredicate(format: "label == %@", updatedLabel)
        let expectation = self.expectation(for: predicate, evaluatedWith: canvas)
        let result = XCTWaiter.wait(for: [expectation], timeout: 5.0)
        XCTAssert(result == .completed, "Menu action adds node")
    }
    
    func testUndoAfterAddNode() throws {
        let app = XCUIApplication()
        let canvas = app.buttons["GraphCanvas"]
        XCTAssertTrue(canvas.waitForExistence(timeout: 5), "Graph canvas should appear after reset")
        
        // Verify empty
        let emptyLabel = "Graph with 0 nodes and 0 edges. No node or edge selected."
        let emptyPredicate = NSPredicate(format: "label == %@", emptyLabel)
        let emptyExpectation = self.expectation(for: emptyPredicate, evaluatedWith: canvas)
        let emptyResult = XCTWaiter.wait(for: [emptyExpectation], timeout: 5.0)
        XCTAssert(emptyResult == .completed, "Graph reset to empty")
        
        // Pan once
        let centerCoord = canvas.coordinate(withNormalizedOffset: CGVector(dx: 0.5, dy: 0.5))
        let endCoordRight = centerCoord.withOffset(CGVector(dx: -1000, dy: 0))
        centerCoord.press(forDuration: 0.1, thenDragTo: endCoordRight)
        Thread.sleep(forTimeInterval: 0.3)
        let endCoordDown = centerCoord.withOffset(CGVector(dx: 0, dy: -1000))
        centerCoord.press(forDuration: 0.1, thenDragTo: endCoordDown)
        Thread.sleep(forTimeInterval: 0.3)
        
        // Long press to open menu and add node (2 retries, pre-tap, 5s duration)
        let menuList = app.scrollViews["menuList"]
        var menuOpened = false
        let cornerCoord = canvas.coordinate(withNormalizedOffset: CGVector(dx: 0.5, dy: 0.5))  // Center
        for attempt in 1...2 {
            print("Attempt \(attempt) to open menu for add node")
            cornerCoord.tap()  // Pre-tap
            Thread.sleep(forTimeInterval: 0.3)
            cornerCoord.press(forDuration: 5.0)
            Thread.sleep(forTimeInterval: 2.0)  // Increased post-press sleep
            
            print("Canvas label after long press (attempt \(attempt)): \(canvas.label)")
            print("Post-long press hierarchy (attempt \(attempt)): \(app.debugDescription)")
            
            let attachment = XCTAttachment(screenshot: app.screenshot())
            attachment.name = "Post-long-press-addNode-attempt-\(attempt)"
            attachment.lifetime = .keepAlways
            add(attachment)
            
            if menuList.waitForExistence(timeout: 5.0) {
                menuOpened = true
                break
            }
            // Tap to dismiss if stuck
            centerCoord.tap()
            Thread.sleep(forTimeInterval: 0.5)
        }
        XCTAssertTrue(menuOpened, "Menu list should appear after long press for add")
        
        let addNodeButton = app.buttons["addNodeButton"]
        scrollUntilVisible(element: addNodeButton, in: menuList, maxAttempts: 20)
        addNodeButton.tap()
        Thread.sleep(forTimeInterval: 0.5)
        
        // Check added
        let addedLabel = "Graph with 1 node and 0 edges. No node or edge selected."
        let addedPredicate = NSPredicate(format: "label == %@", addedLabel)
        let addedExpectation = self.expectation(for: addedPredicate, evaluatedWith: canvas)
        let addedResult = XCTWaiter.wait(for: [addedExpectation], timeout: 5.0)
        XCTAssert(addedResult == .completed, "Node added")
        
        // Pan again for second long press (once)
        let endCoordRight2 = centerCoord.withOffset(CGVector(dx: -1000, dy: 0))
        centerCoord.press(forDuration: 0.1, thenDragTo: endCoordRight2)
        Thread.sleep(forTimeInterval: 0.3)
        let endCoordDown2 = centerCoord.withOffset(CGVector(dx: 0, dy: -1000))
        centerCoord.press(forDuration: 0.1, thenDragTo: endCoordDown2)
        Thread.sleep(forTimeInterval: 0.3)
        
        // Second long press (2 retries, pre-tap, 5s duration)
        menuOpened = false
        for attempt in 1...2 {
            print("Attempt \(attempt) to open menu for undo")
            cornerCoord.tap()  // Pre-tap
            Thread.sleep(forTimeInterval: 0.3)
            cornerCoord.press(forDuration: 5.0)
            Thread.sleep(forTimeInterval: 2.0)  // Increased post-press sleep
            
            print("Canvas label after second long press (attempt \(attempt)): \(canvas.label)")
            print("Post-second long press hierarchy (attempt \(attempt)): \(app.debugDescription)")
            
            let attachment = XCTAttachment(screenshot: app.screenshot())
            attachment.name = "Post-long-press-undo-attempt-\(attempt)"
            attachment.lifetime = .keepAlways
            add(attachment)
            
            if menuList.waitForExistence(timeout: 5.0) {
                menuOpened = true
                break
            }
            // Tap to dismiss if stuck
            centerCoord.tap()
            Thread.sleep(forTimeInterval: 0.5)
        }
        XCTAssertTrue(menuOpened, "Menu list should appear after second long press")
        
        let undoButton = app.buttons["undoButton"]
        scrollUntilVisible(element: undoButton, in: menuList, maxAttempts: 20)
        XCTAssertTrue(undoButton.waitForExistence(timeout: 3), "Undo button should appear")
        undoButton.tap()
        Thread.sleep(forTimeInterval: 0.5)
        
        // Check reverted
        let revertedLabel = "Graph with 0 nodes and 0 edges. No node or edge selected."
        let revertedPredicate = NSPredicate(format: "label == %@", revertedLabel)
        let revertedExpectation = self.expectation(for: revertedPredicate, evaluatedWith: canvas)
        let revertedResult = XCTWaiter.wait(for: [revertedExpectation], timeout: 5.0)
        XCTAssert(revertedResult == .completed, "Undo reverts add")
    }
}
----------------------------------------------------------------------------------------------------
File: GraphEditorWatchUITestsLaunchTests.swift
Path: GraphEditorWatchUITests/GraphEditorWatchUITestsLaunchTests.swift
Last modified: 2025-09-19 13:15:40

Contents:
//
//  GraphEditorWatchUITestsLaunchTests.swift
//  GraphEditorWatchUITests
//
//  Created by handcart on 8/4/25.
//

import XCTest

final class GraphEditorWatchUITestsLaunchTests: XCTestCase {

    override static var runsForEachTargetApplicationUIConfiguration: Bool {
        true
    }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    @MainActor
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        // Insert steps here to perform after app launch but before taking a screenshot,
        // such as logging into a test account or navigating somewhere in the app

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = "Launch Screen"
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}
--------------------------------------------------
