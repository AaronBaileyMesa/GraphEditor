## Focused Project Concatenation
This file includes only UI, interactivity, model, and core logic files.
Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
Current date: 2025-09-06 13:07:53
Table of Contents:
1. GraphEditorWatchTests/GraphEditorWatchTests.swift
2. GraphEditorWatchUITests/GraphEditorWatchUITests.swift
3. GraphEditorWatchUITests/GraphEditorWatchUITestsLaunchTests.swift--------------------------------------------------
File: GraphEditorWatchTests.swift
Path: GraphEditorWatchTests/GraphEditorWatchTests.swift
Last modified: 2025-09-02 13:15:09

Contents:
import Testing
import Foundation
import CoreGraphics
@testable import GraphEditorWatch // Already present
@testable import GraphEditorShared // Changed to @testable for accessing internal members
import XCTest
import SwiftUI

class MockGraphStorage: GraphStorage {
    var nodes: [any NodeProtocol] = []
    var edges: [GraphEdge] = []
    
    func save(nodes: [any NodeProtocol], edges: [GraphEdge]) throws {
        self.nodes = nodes
        self.edges = edges
    }
    
    func load() throws -> (nodes: [any NodeProtocol], edges: [GraphEdge]) {
        (nodes, edges)
    }
    
    func clear() throws {
        nodes = []
        edges = []
    }
}

// Add this helper function at the top of the test file or in the test struct
func approximatelyEqual(_ lhs: CGPoint, _ rhs: CGPoint, accuracy: CGFloat) -> Bool {
    return hypot(lhs.x - rhs.x, lhs.y - rhs.y) < accuracy
}

struct GraphModelTests {
    private func mockPhysicsEngine() -> GraphEditorShared.PhysicsEngine {
        GraphEditorShared.PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300)) // Mock size for tests
    }
    
    @Test func testUndoRedoMixedOperations() async throws {
        let storage = MockGraphStorage()
        let model = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        let initialNodeCount = await MainActor.run { model.nodes.count }
        let initialEdgeCount = await MainActor.run { model.edges.count }
        
        // Specify node to delete (e.g., first in cycle removes 2 edges)
        let nodeToDelete = await MainActor.run { model.nodes[0].id }
        let connectedEdges = await MainActor.run { model.edges.filter { $0.from == nodeToDelete || $0.to == nodeToDelete }.count }
        await model.deleteNode(withID: nodeToDelete) // Now 2n, 1e
        
        await model.addNode(at: CGPoint.zero) // Now 3n, 1e — no *manual* snapshot (internal one handles)
        
        #expect(await MainActor.run { model.nodes.count } == initialNodeCount, "After add: count back to initial")
        #expect(await MainActor.run { model.edges.count } == initialEdgeCount - connectedEdges, "Edges reduced by connected count")
        
        await model.undo() // To post-delete
        #expect(await MainActor.run { model.nodes.count } == initialNodeCount - 1, "Undo reverts to post-delete")
        #expect(await MainActor.run { model.edges.count } == initialEdgeCount - connectedEdges, "Edges match post-delete")
        
        await model.undo() // To initial
        #expect(await MainActor.run { model.nodes.count } == initialNodeCount, "Second undo restores initial")
        #expect(await MainActor.run { model.edges.count } == initialEdgeCount, "Edges restored")
        
        await model.redo() // To post-delete
        #expect(await model.nodes.count == initialNodeCount - 1, "Redo applies delete")
        
        await model.redo() // To post-add
        #expect(await model.nodes.count == initialNodeCount, "Redo applies add")
    }
    
    @Test func testInitializationWithDefaults() async throws {
        let storage = MockGraphStorage()
        let model = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        #expect(await model.nodes.count >= 3, "Should load default or saved nodes")
        #expect(await model.edges.count >= 3, "Should load default edges")
    }
    
    @Test func testSnapshotAndUndo() async throws {
        let storage = MockGraphStorage()
        let model = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        let initialNodes = await model.nodes
        await model.snapshot()
        await model.addNode(at: CGPoint.zero)
        #expect(await model.nodes.count == initialNodes.count + 1, "Node added")
        await model.undo()
        let restoredNodes = await model.nodes
        let idsMatch = Set(restoredNodes.map { $0.id }) == Set(initialNodes.map { $0.id })
        let labelsMatch = Set(restoredNodes.map { $0.label }) == Set(initialNodes.map { $0.label })
        let positionsMatch = zip(restoredNodes.sorted(by: { $0.id.uuidString < $1.id.uuidString }), initialNodes.sorted(by: { $0.id.uuidString < $1.id.uuidString })).allSatisfy { approximatelyEqual($0.position, $1.position, accuracy: 1e-5) }
        #expect(idsMatch && labelsMatch && positionsMatch, "Undo restores state")
    }
    
    @Test func testDeleteNodeAndEdges() async throws {
        let storage = MockGraphStorage()
        let model = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        #expect(await !model.nodes.isEmpty, "Assumes default nodes exist")
        let nodeID = await model.nodes[0].id
        let initialEdgeCount = await model.edges.count
        await model.deleteNode(withID: nodeID)
        #expect(await model.nodes.first { $0.id == nodeID } == nil, "Node deleted")
        #expect(await model.edges.count < initialEdgeCount, "Edges reduced")
    }
    
    @Test func testSaveLoadRoundTrip() async throws {
        let storage = MockGraphStorage()
        let model = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        let originalNodeCount = await model.nodes.count
        let originalEdges = await model.edges
        // Modify and snapshot to trigger save
        await model.addNode(at: CGPoint.zero)
        await model.snapshot()
        // New instance to trigger load
        let newModel = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        #expect(await newModel.nodes.count == originalNodeCount + 1, "Loaded nodes include added one")
        #expect(await newModel.edges == originalEdges, "Edges unchanged")
    }
      
    
    
    /*
    // New: Basic convergence test with tightened threshold
    // New: Basic convergence test with tightened threshold
    @Test(arguments: 1..<5) func testConvergencePropertyBased(seed: Int) throws {
        let model = GraphModel(storage: MockGraphStorage(), physicsEngine: mockPhysicsEngine())
        srand48(seed)  // Seed random for reproducibility
        //print(model.nodes.map { ($0.label, $0.position) })
        model.nodes = (0..<5).map { _ in
            Node(label: Int(drand48() * 10), position: CGPoint(x: CGFloat(drand48() * 300), y: CGFloat(drand48() * 300)))
        }
        model.edges = (0..<3).map { _ in
            GraphEdge(from: model.nodes[Int(drand48() * 5)].id, to: model.nodes[Int(drand48() * 5)].id)
        }
        
        model.startSimulation()
        // Manual loop for test with substeps
        for _ in 0..<Constants.Physics.maxSimulationSteps {
            var nodes = model.nodes
            var activeAccum = false  // Accumulator declared here (outside inner loop)
            for _ in 0..<20 {  // Increased substeps as suggested
                let (updatedNodes, stepActive) = model.physicsEngine.simulationStep(nodes: nodes, edges: model.edges)
                nodes = updatedNodes
                activeAccum = activeAccum || stepActive  // Update accumulator
                if !stepActive { break }  // Optional: Early break if inactive in a substep
            }
            model.nodes = nodes
            if !activeAccum { break }  // Now uses the accumulator (in scope)
        }
        
        let totalVel = model.nodes.reduce(0.0) { $0 + $1.velocity.magnitude }
        #expect(totalVel < 2.0 * CGFloat(model.nodes.count), "Velocities near zero for seed \(seed)")
    }
    // New/Fixed: Property-based convergence test with tightened threshold and proper parameterization
    @Test func testSimulationConvergence() {
        let tolerance: CGFloat = 0.05
        let model = GraphModel(storage: MockGraphStorage(), physicsEngine: mockPhysicsEngine())
        model.nodes = [
            Node(label: 1, position: CGPoint(x: 100, y: 100), velocity: CGPoint(x: 10, y: 10)),
            Node(label: 2, position: CGPoint(x: 200, y: 200), velocity: CGPoint(x: -10, y: -10))
        ]
        model.edges = [GraphEdge(from: model.nodes[0].id, to: model.nodes[1].id)]
        
        model.startSimulation()
        for _ in 0..<Constants.Physics.maxSimulationSteps {
            var nodes = model.nodes
            var activeAccum = false
            let subSteps = 20  // Increased as suggested
            for _ in 0..<subSteps {
                let edges = model.edges
                let (updatedNodes, stepActive) = model.physicsEngine.simulationStep(nodes: nodes, edges: edges)
                nodes = updatedNodes
                activeAccum = activeAccum || stepActive
                if !stepActive { break }  // Optional early break
            }
            model.nodes = nodes
            if !activeAccum { break }
        }
        
        #expect(model.nodes[0].velocity.magnitude < 1.2 + tolerance, "Node 1 velocity converges to near-zero")
        #expect(model.nodes[1].velocity.magnitude < 1.2 + tolerance, "Node 2 velocity converges to near-zero")
    }
     */
}

struct CoordinateTransformerTests {
    @Test func testCoordinateRoundTrip() {
        let viewSize = CGSize(width: 205, height: 251)  // Apple Watch Ultra 2 points
        let centroid = CGPoint(x: 150, y: 150)
        let modelPos = CGPoint(x: 167.78, y: 165.66)  // From your log
        let zoom: CGFloat = 1.0
        let offset = CGSize.zero
        
        let screenPos = CoordinateTransformer.modelToScreen(modelPos, effectiveCentroid: centroid, zoomScale: zoom, offset: offset, viewSize: viewSize)
        let recoveredModel = CoordinateTransformer.screenToModel(screenPos, effectiveCentroid: centroid, zoomScale: zoom, offset: offset, viewSize: viewSize)
        
        #expect(approximatelyEqual(recoveredModel, modelPos, accuracy: 1e-3), "Round-trip should match original model position")
    }
    
    @Test func testCoordinateRoundTripWithZoomAndOffset() {
        let viewSize = CGSize(width: 205, height: 251)
        let centroid = CGPoint(x: 56.73, y: 161.10)  // From your log
        let modelPos = CGPoint(x: -40.27, y: 52.60)
        let zoom: CGFloat = 1.0
        let offset = CGSize(width: 81, height: 111.5)
        
        let screenPos = CoordinateTransformer.modelToScreen(modelPos, effectiveCentroid: centroid, zoomScale: zoom, offset: offset, viewSize: viewSize)
        let recoveredModel = CoordinateTransformer.screenToModel(screenPos, effectiveCentroid: centroid, zoomScale: zoom, offset: offset, viewSize: viewSize)
        
        #expect(approximatelyEqual(recoveredModel, modelPos, accuracy: 1e-3), "Round-trip with zoom and offset should match")
    }
}

    
struct GestureTests {
    @Test func testDragCreatesEdge() async throws {
        let storage = MockGraphStorage()
        let physicsEngine = GraphEditorShared.PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
        let model = await GraphModel(storage: storage, physicsEngine: physicsEngine)
        
        // Setup: Clear default nodes/edges if needed, but since test assumes empty edges after adding, adjust expectations.
        // Note: GraphModel init adds defaults if empty, so to match test intent, we'll clear them here for the test.
        await MainActor.run { model.nodes = [] }
        await MainActor.run { model.edges = [] }
        await model.addNode(at: CGPoint(x: 0, y: 0))
        await model.addNode(at: CGPoint(x: 50, y: 50))
        #expect(await model.edges.isEmpty, "No edges initially")
        
        let viewModel = await GraphViewModel(model: model)
        let draggedNode: (any NodeProtocol)? = await model.nodes[0]
        let potentialEdgeTarget: (any NodeProtocol)? = await model.nodes[1]
        
        // Mock gesture properties instead of creating Value
        let mockTranslation = CGSize(width: 50, height: 50)
        let dragOffset: CGPoint = CGPoint(x: mockTranslation.width / 1.0, y: mockTranslation.height / 1.0)  // Assume zoomScale=1
        
        let dragDistance = hypot(mockTranslation.width, mockTranslation.height)
        if let node = draggedNode,
           let index = await viewModel.model.nodes.firstIndex(where: { $0.id == node.id }) {
            await viewModel.snapshot()
            if dragDistance < AppConstants.tapThreshold {
                // Tap logic (skipped)
            } else {
                // Drag logic
                if let target = potentialEdgeTarget, target.id != node.id {
                    // Break up complex predicate
                    let fromID = node.id
                    let toID = target.id
                    let edgeExists = await MainActor.run {
                        viewModel.model.edges.contains { edge in
                            (edge.from == fromID && edge.to == toID) ||
                            (edge.from == toID && edge.to == fromID)
                        }
                    }
                    if !edgeExists {
                        await MainActor.run { viewModel.model.edges.append(GraphEdge(from: fromID, to: toID)) }
                        await viewModel.model.startSimulation()
                    } else {
                        // Move logic (skipped, but update to use vars)
                        await MainActor.run { viewModel.model.nodes[index].position = CGPoint(x: viewModel.model.nodes[index].position.x + dragOffset.x, y: viewModel.model.nodes[index].position.y + dragOffset.y) }
                        await viewModel.model.startSimulation()
                    }
                }
            }
        }
        
        await #expect(viewModel.model.edges.count == 1, "Edge created after simulated drag")
        let newEdge = await viewModel.model.edges.first
        #expect(newEdge != nil, "New edge exists")
        if let newEdge = newEdge {
            #expect(newEdge.from == draggedNode?.id, "Edge from correct node")
            #expect(newEdge.to == potentialEdgeTarget?.id, "Edge to correct node")
        }
    }
}

struct AccessibilityTests {
    private func mockPhysicsEngine() -> GraphEditorShared.PhysicsEngine {
        GraphEditorShared.PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
    }
    
    @Test func testGraphDescription() async throws {
        let storage = MockGraphStorage()
        // Preload with dummy to avoid defaults and set nextNodeLabel to 1
        storage.nodes = [Node(label: 0, position: .zero)]
        let model = await GraphModel(storage: storage, physicsEngine: mockPhysicsEngine(), nextNodeLabel: 1)
                await MainActor.run { model.nodes = [] }
                await MainActor.run { model.edges = [] }
        
                await MainActor.run { model.nextNodeLabel = 1 }
        
                await model.addNode(at: .zero)
                await model.addNode(at: CGPoint(x: 10, y: 10))
        
                await MainActor.run { model.edges.append(GraphEdge(from: model.nodes[0].id, to: model.nodes[1].id)) }  // Or await model.addEdge(...) if added
        
                let descNoSelect = await MainActor.run { model.graphDescription(selectedID: nil, selectedEdgeID: nil) }
        #expect(descNoSelect == "Graph with 2 nodes and 1 directed edge. No node or edge selected.", "Correct desc without selection")
        
                let descWithSelect = await MainActor.run { model.graphDescription(selectedID: model.nodes[0].id, selectedEdgeID: nil) }
        #expect(descWithSelect == "Graph with 2 nodes and 1 directed edge. Node 1 selected, outgoing to: 2; incoming from: none.", "Correct desc with selection")
    }
}
----------------------------------------------------------------------------------------------------
File: GraphEditorWatchUITests.swift
Path: GraphEditorWatchUITests/GraphEditorWatchUITests.swift
Last modified: 2025-08-09 17:07:24

Contents:
//
//  GraphEditorWatchUITests.swift
//  GraphEditorWatchUITests
//
//  Created by handcart on 8/4/25.
//

import XCTest

final class GraphEditorWatchUITests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.

        // In UI tests it is usually best to stop immediately when a failure occurs.
        continueAfterFailure = false

        // In UI tests it’s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }
    
    func testLaunch() throws {
            let app = XCUIApplication()
            app.launch()
            
            // Basic assertion: Check if the app launches without crashing
            XCTAssertTrue(app.exists, "App should launch successfully")
        }
    
    func testDragToCreateEdge() throws {
        let app = XCUIApplication()
        app.launch()

        let canvas = app.otherElements["GraphCanvas"]  // Assumes accessibilityIdentifier set on GraphCanvasView
        XCTAssertTrue(canvas.waitForExistence(timeout: 5), "Graph canvas should appear")

        // Assume default nodes: Adjust start/end based on positions (e.g., node0 at (100,100), node1 at (200,200))
        let startPoint = CGVector(dx: 0.3, dy: 0.3)  // Near node0
        let endPoint = CGVector(dx: 0.6, dy: 0.6)    // Near node1

        let dragStart = canvas.coordinate(withNormalizedOffset: startPoint)
        let dragEnd = canvas.coordinate(withNormalizedOffset: endPoint)
        dragStart.press(forDuration: 0.1, thenDragTo: dragEnd)

        // Assert: Updated label reflects directed edge (e.g., "Graph with 3 nodes and 4 directed edges." and mentions direction)
        let updatedLabel = app.staticTexts["Graph with 3 nodes and 4 directed edges. No node selected."]  // Adjust based on post-drag (add "directed")
        XCTAssertTrue(updatedLabel.waitForExistence(timeout: 2), "Directed edge created, updating graph description")

        // Optional: Select the from-node and check description mentions "outgoing to" the to-node
        // Simulate tap on startPoint to select, then check label includes "outgoing to: <label>"
    }
    
    func testUndoAfterAddNode() throws {
            let app = XCUIApplication()
            app.launch()
            
            let canvas = app.otherElements["GraphCanvas"]  // Assume identifier set
            XCTAssertTrue(canvas.waitForExistence(timeout: 5))
            
            // Simulate add node: Assume menu button "Add Node" exists
            app.buttons["Show Menu"].tap()  // Or long press if using gestures
            app.buttons["Add Node"].tap()
            
            // Assert: Graph description updates (e.g., nodes increase)
            let updatedLabel = app.staticTexts["Graph with 4 nodes"]  // Adjust based on defaults +1
            XCTAssertTrue(updatedLabel.waitForExistence(timeout: 2), "Node added")
            
            // Undo via button
            app.buttons["Undo"].tap()  // Assume undo button in menu or UI
            let revertedLabel = app.staticTexts["Graph with 3 nodes"]  // Back to defaults
            XCTAssertTrue(revertedLabel.waitForExistence(timeout: 2), "Undo reverts add")
        }
        
        func testMenuDisplayAndAction() throws {
            let app = XCUIApplication()
            app.launch()
            
            let canvas = app.otherElements["GraphCanvas"]
            XCTAssertTrue(canvas.waitForExistence(timeout: 5))
            
            // Long press to show menu (if using sheet)
            canvas.coordinate(withNormalizedOffset: CGVector(dx: 0.5, dy: 0.5)).press(forDuration: 1.0)
            
            // Assert menu appears with buttons
            let addButton = app.buttons["Add Node"]
            XCTAssertTrue(addButton.waitForExistence(timeout: 2), "Menu shows with actions")
            
            addButton.tap()
            // Assert action effect (e.g., via label)
            let updatedLabel = app.staticTexts["Graph with 4 nodes"]
            XCTAssertTrue(updatedLabel.waitForExistence(timeout: 2), "Menu action adds node")
        }
    
    // New: Test for digital crown zooming (using proxy button; manual test crown in simulator)
    func testDigitalCrownZooming() throws {
        let app = XCUIApplication()
        app.launch()
        
        let canvas = app.otherElements["GraphCanvas"]  // Assume identifier set
        XCTAssertTrue(canvas.waitForExistence(timeout: 5))
        
        // Simulate crown via menu button (add "Zoom In" to menu if not present)
        app.buttons["Show Menu"].tap()
        app.buttons["Zoom In"].tap()  // Proxy for crown rotation; adjust if button named differently
        
        // Assert: Check if description or visible elements change (e.g., more details visible)
        let zoomedLabel = app.staticTexts["Graph with 3 nodes"]  // Adjust to match post-zoom (e.g., if zoom reveals more)
        XCTAssertTrue(zoomedLabel.waitForExistence(timeout: 2), "Zoom updates view")
    }
    
    
    @MainActor
    func testExample() throws {
        // UI tests must launch the application that they test.
        let app = XCUIApplication()
        app.launch()

        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    @MainActor
    func testLaunchPerformance() throws {
        // This measures how long it takes to launch your application.
        measure(metrics: [XCTApplicationLaunchMetric()]) {
            XCUIApplication().launch()
        }
    }
}
----------------------------------------------------------------------------------------------------
File: GraphEditorWatchUITestsLaunchTests.swift
Path: GraphEditorWatchUITests/GraphEditorWatchUITestsLaunchTests.swift
Last modified: 2025-08-04 15:45:24

Contents:
//
//  GraphEditorWatchUITestsLaunchTests.swift
//  GraphEditorWatchUITests
//
//  Created by handcart on 8/4/25.
//

import XCTest

final class GraphEditorWatchUITestsLaunchTests: XCTestCase {

    override class var runsForEachTargetApplicationUIConfiguration: Bool {
        true
    }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    @MainActor
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        // Insert steps here to perform after app launch but before taking a screenshot,
        // such as logging into a test account or navigating somewhere in the app

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = "Launch Screen"
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}
--------------------------------------------------
