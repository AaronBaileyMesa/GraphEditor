## Focused Project Concatenation
This file includes only UI, interactivity, model, and core logic files.
Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
Current date: 2025-09-26 08:21:14
Table of Contents:
1. GraphEditorShared/Sources/GraphEditorShared/AttractionCalculator.swift
2. GraphEditorShared/Sources/GraphEditorShared/CenteringCalculator.swift
3. GraphEditorShared/Sources/GraphEditorShared/Constants.swift
4. GraphEditorShared/Sources/GraphEditorShared/CoordinateTransformer.swift
5. GraphEditorShared/Sources/GraphEditorShared/GraphModel.swift
6. GraphEditorShared/Sources/GraphEditorShared/GraphModel+EdgesNodes.swift
7. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Helpers.swift
8. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Simulation.swift
9. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Storage.swift
10. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Undo.swift
11. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Visibility.swift
12. GraphEditorShared/Sources/GraphEditorShared/GraphSimulator.swift--------------------------------------------------
File: AttractionCalculator.swift
Path: GraphEditorShared/Sources/GraphEditorShared/AttractionCalculator.swift
Last modified: 2025-09-19 13:45:29

Contents:
//
//  AttractionCalculator.swift
//  GraphEditorShared
//
//  Created by handcart on 8/12/25.
//

import Foundation  // For hypot, CGFloat, etc.
import CoreGraphics  // For CGPoint, CGVector (used internally)

@available(iOS 16.0, watchOS 9.0, *)
struct AttractionCalculator {
    let symmetricFactor: CGFloat
    let useAsymmetric: Bool  // New: Controls full asymmetry for hierarchy edges

    init(symmetricFactor: CGFloat, useAsymmetric: Bool = false) {  // Default false to preserve existing behavior
        self.symmetricFactor = symmetricFactor
        self.useAsymmetric = useAsymmetric
    }

    func applyAttractions(forces: [NodeID: CGPoint], edges: [GraphEdge], nodes: [any NodeProtocol]) -> [NodeID: CGPoint] {
        var updatedForces = forces
        for edge in edges {
            guard let fromNode = nodes.first(where: { $0.id == edge.from }),
                  let toNode = nodes.first(where: { $0.id == edge.target }) else { continue }
            let deltaX = toNode.position.x - fromNode.position.x
            let deltaY = toNode.position.y - fromNode.position.y
            let dist = max(hypot(deltaX, deltaY), Constants.Physics.distanceEpsilon)
            let forceMagnitude = Constants.Physics.stiffness * (dist - Constants.Physics.idealLength)
            let forceDirectionX = deltaX / dist
            let forceDirectionY = deltaY / dist
            let forceX = forceDirectionX * forceMagnitude
            let forceY = forceDirectionY * forceMagnitude
            
            let symForceX = forceX * self.symmetricFactor
            let symForceY = forceY * self.symmetricFactor
            
            let currentForceFrom = updatedForces[fromNode.id] ?? CGPoint.zero
            let currentForceTo = updatedForces[toNode.id] ?? CGPoint.zero
            
            let isHierarchy = edge.type == .hierarchy
            if isHierarchy && self.useAsymmetric {
                // Full asymmetric: Strong pull 'to' toward 'from'; minimal back-pull on 'from' (test-friendly)
                let asymmetricFactor: CGFloat = 2.0  // Stronger pull for 'to'; tune if needed
                let toForceX = -forceX * asymmetricFactor  // Pull 'to' left/up toward 'from'
                let toForceY = -forceY * asymmetricFactor
                let fromBackPullX = forceX * 0.1  // Minimal back-pull (10% to keep stable)
                let fromBackPullY = forceY * 0.1
                
                updatedForces[toNode.id] = CGPoint(x: currentForceTo.x + toForceX, y: currentForceTo.y + toForceY)
                updatedForces[fromNode.id] = CGPoint(x: currentForceFrom.x + fromBackPullX, y: currentForceFrom.y + fromBackPullY)
            } else if isHierarchy {
                // Symmetric for stability (net force zero)
                updatedForces[toNode.id] = CGPoint(x: currentForceTo.x - forceX + symForceX, y: currentForceTo.y - forceY + symForceY)
                updatedForces[fromNode.id] = CGPoint(x: currentForceFrom.x + symForceX, y: currentForceFrom.y + symForceY)
            } else {
                // Symmetric for .association (unchanged)
                updatedForces[toNode.id] = CGPoint(x: currentForceTo.x - forceX + symForceX, y: currentForceTo.y - forceY + symForceY)
                updatedForces[fromNode.id] = CGPoint(x: currentForceFrom.x + symForceX, y: currentForceFrom.y + symForceY)
            }
        }
        return updatedForces
    }
}
----------------------------------------------------------------------------------------------------
File: CenteringCalculator.swift
Path: GraphEditorShared/Sources/GraphEditorShared/CenteringCalculator.swift
Last modified: 2025-09-19 13:45:29

Contents:
//
//  CenteringCalculator.swift
//  GraphEditorShared
//
//  Created by handcart on 8/12/25.
//

import Foundation
import CoreGraphics

struct CenteringCalculator {
    let simulationBounds: CGSize

    @available(iOS 16.0, *)
    func applyCentering(forces: [NodeID: CGPoint], nodes: [any NodeProtocol]) -> [NodeID: CGPoint] {
        var updatedForces = forces
        let center = CGPoint(x: simulationBounds.width / 2, y: simulationBounds.height / 2)
        for node in nodes {
            let deltaX = center.x - node.position.x
            let deltaY = center.y - node.position.y
            let distToCenter = hypot(deltaX, deltaY)
            let forceX = deltaX * Constants.Physics.centeringForce * (1 + distToCenter / max(simulationBounds.width, simulationBounds.height))
            let forceY = deltaY * Constants.Physics.centeringForce * (1 + distToCenter / max(simulationBounds.width, simulationBounds.height))
            let currentForce = updatedForces[node.id] ?? .zero
            updatedForces[node.id] = CGPoint(x: currentForce.x + forceX, y: currentForce.y + forceY)
        }
        return updatedForces
    }
}
----------------------------------------------------------------------------------------------------
File: Constants.swift
Path: GraphEditorShared/Sources/GraphEditorShared/Constants.swift
Last modified: 2025-09-25 15:18:40

Contents:
//
//  Constants.swift
//  GraphEditorShared
//
//  Created by handcart on 8/6/25.
//
// Sources/GraphEditorShared/Constants.swift

import CoreGraphics

public enum Constants {
    public enum Physics {
        public static let stiffness: CGFloat = 0.4  // Reduced from 0.8 for softer springs
        public static let repulsion: CGFloat = 1200  // Reduced from 2200 for less aggressive push
        public static let damping: CGFloat = 0.9  // Reduced from 0.99 for faster settling
        public static let idealLength: CGFloat = 80  // Slightly increased for more space
        public static let centeringForce: CGFloat = 0.03  // Reduced from 0.06 to avoid over-pull
        public static let distanceEpsilon: CGFloat = 1e-3
        public static let timeStep: CGFloat = 0.02  // Slightly reduced for finer steps
        public static let velocityThreshold: CGFloat = 0.3  // Increased from 0.2 for earlier stop
        public static let maxSimulationSteps = 500  // Further reduced from 1000 for quick convergence
        public static let minQuadSize: CGFloat = 1e-6
        public static let maxQuadtreeDepth = 20
        public static let maxNodesForQuadtree = 200
        public static let minCollisionDist: CGFloat = 35.0  // New: For anti-collision separation
        public static let verticalBias: CGFloat = 0.0  // New: Downward bias for hierarchy edges (tune as needed)
    }
    
    public enum App {
        public static let nodeModelRadius: CGFloat = 10.0
        public static let hitScreenRadius: CGFloat = 40.0  // Larger for watchOS tap targets
        public static let tapThreshold: CGFloat = 20.0  // Tightened from 10.0 for small screens
        public static let numZoomLevels: Int = 20  // For crown mapping
        public static let contentPadding: CGFloat = 50.0  // Padding for graph bounds
        public static let maxZoom: CGFloat = 8.0  // Maximum zoom level
    }
    
    // Add more enums as needed (e.g., UI, Testing)
}
----------------------------------------------------------------------------------------------------
File: CoordinateTransformer.swift
Path: GraphEditorShared/Sources/GraphEditorShared/CoordinateTransformer.swift
Last modified: 2025-09-26 08:05:37

Contents:
//
//  CoordinateTransformer.swift
//  GraphEditorShared
//
//  Created by handcart on 9/26/25.
//

import CoreGraphics
import SwiftUI  // For GeometryProxy if enabled

/// Utility for converting between model (graph) coordinates and screen (view) coordinates.
public struct CoordinateTransformer {
    
    /// Converts a model position to screen coordinates.
    /// - Parameters:
    ///   - modelPos: The position in model space.
    ///   - effectiveCentroid: The centroid of the graph for centering.
    ///   - zoomScale: Current zoom level.
    ///   - offset: Pan offset.
    ///   - viewSize: Size of the view.
    ///   - geometry: Optional GeometryProxy for safe area adjustments (e.g., on watchOS).
    /// - Returns: Screen position.
    public static func modelToScreen(
        _ modelPos: CGPoint,
        effectiveCentroid: CGPoint,
        zoomScale: CGFloat,
        offset: CGSize,
        viewSize: CGSize
        // geometry: GeometryProxy? = nil  // Uncomment if needed for safe areas
    ) -> CGPoint {
        let viewCenter = CGPoint(x: viewSize.width / 2, y: viewSize.height / 2)
        let relativePos = modelPos - effectiveCentroid
        let scaledPos = relativePos * zoomScale
        let screenPos = viewCenter + scaledPos + CGPoint(x: offset.width, y: offset.height)
        
        // Optional: Adjust for safe areas (symmetric to screenToModel)
        // if let geo = geometry {
        //     screenPos.x += geo.safeAreaInsets.leading
        //     screenPos.y += geo.safeAreaInsets.top
        // }
        
        #if DEBUG
        print("modelToScreen: Model \(modelPos) -> Screen \(screenPos), Zoom \(zoomScale), Offset \(offset), Centroid \(effectiveCentroid), ViewSize \(viewSize)")
        #endif
        
        return screenPos
    }
    
    /// Converts a screen position back to model coordinates.
    /// - Parameters:
    ///   - screenPos: The position in screen space.
    ///   - effectiveCentroid: The centroid of the graph for centering.
    ///   - zoomScale: Current zoom level.
    ///   - offset: Pan offset.
    ///   - viewSize: Size of the view.
    ///   - geometry: Optional GeometryProxy for safe area adjustments (e.g., on watchOS).
    /// - Returns: Model position (rounded to 3 decimals to reduce floating-point drift).
    public static func screenToModel(
        _ screenPos: CGPoint,
        effectiveCentroid: CGPoint,
        zoomScale: CGFloat,
        offset: CGSize,
        viewSize: CGSize
        // geometry: GeometryProxy? = nil  // Uncomment if needed for safe areas
    ) -> CGPoint {
        let safeZoom = max(zoomScale, 0.001)  // Prevent div-by-zero; adjust based on your minZoom
        let viewCenter = CGPoint(x: viewSize.width / 2, y: viewSize.height / 2)
        let panOffset = CGPoint(x: offset.width, y: offset.height)
        
        let translated = screenPos - viewCenter - panOffset
        
        // Optional: Adjust for safe areas (e.g., touches missing near edges on watchOS)
        // if let geo = geometry {
        //     translated.x -= geo.safeAreaInsets.leading
        //     translated.y -= geo.safeAreaInsets.top
        // }
        
        let unscaled = translated / safeZoom
        let modelPos = effectiveCentroid + unscaled
        
        #if DEBUG
        print("screenToModel: Screen \(screenPos) -> Model \(modelPos), Zoom \(safeZoom), Offset \(panOffset), Centroid \(effectiveCentroid), ViewSize \(viewSize)")
        #endif
        
        // Round to 3 decimals to eliminate floating-point drift
        return CGPoint(x: modelPos.x.rounded(to: 3), y: modelPos.y.rounded(to: 3))
    }
}

// Extension for rounding (if not already in Utilities.swift)
private extension CGFloat {
    func rounded(to decimalPlaces: Int) -> CGFloat {
        let divisor = pow(10.0, CGFloat(decimalPlaces))
        return (self * divisor).rounded() / divisor
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel.swift
Last modified: 2025-09-24 11:08:58

Contents:
import os.log
import SwiftUI
import Combine
import Foundation

#if os(watchOS)
import WatchKit
#endif

private let logger = OSLog(subsystem: "io.handcart.GraphEditor", category: "storage")

@available(iOS 16.0, watchOS 6.0, *)
@MainActor public class GraphModel: ObservableObject {
    @Published public var nodes: [AnyNode] = []
    @Published public var edges: [GraphEdge] = []
    @Published public var isSimulating: Bool = false
    @Published public var isStable: Bool = false
    @Published public var simulationError: Error?

    var simulationTimer: Timer?
    var undoStack: [GraphState] = []
    var redoStack: [GraphState] = []
    public var maxUndo: Int = 10

    public var nextNodeLabel = 1

    let storage: GraphStorage
    public var physicsEngine: PhysicsEngine

    public var hiddenNodeIDs: Set<NodeID> {
        // Removed debug print to avoid side effects; add os_log if needed for production logging.
        var hidden = Set<NodeID>()
        var toHide: [NodeID] = []

        for node in nodes where node.unwrapped.shouldHideChildren() {
            let children = edges.filter { $0.from == node.id && $0.type == .hierarchy }.map { $0.target }
            toHide.append(contentsOf: children)
        }

        let adj = buildAdjacencyList(for: EdgeType.hierarchy)
        while !toHide.isEmpty {
            let current = toHide.removeLast()
            if hidden.insert(current).inserted {
                let children = adj[current] ?? []
                toHide.append(contentsOf: children)
            }
        }

        return hidden
    }

    lazy var simulator: GraphSimulator = {
        GraphSimulator(
            getNodes: { [weak self] in self?.nodes.map { $0.unwrapped } ?? [] },
            setNodes: { [weak self] newNodes in
                self?.nodes = newNodes.map { AnyNode($0) }
            },
            getEdges: { [weak self] in self?.edges ?? [] },
            getVisibleNodes: { [weak self] in self?.visibleNodes() ?? [] },
            getVisibleEdges: { [weak self] in self?.visibleEdges() ?? [] },
            physicsEngine: self.physicsEngine,
            onStable: { [weak self] in
                guard let self = self, !self.isStable else { return }
                let velocities = self.nodes.map { hypot($0.velocity.x, $0.velocity.y) }
                if velocities.allSatisfy({ $0 < 0.001 }) {
                    print("Simulation stable: Centering nodes")
                    let centeredNodes = self.physicsEngine.centerNodes(nodes: self.nodes.map { $0.unwrapped })
                    self.nodes = centeredNodes.map { AnyNode($0.with(position: $0.position, velocity: .zero)) }
                    self.isStable = true
                    Task {
                        await self.stopSimulation()
                        try? await Task.sleep(nanoseconds: 500_000_000)
                        self.isStable = false
                    }
                    self.objectWillChange.send()
                }
            }
        )
    }()

    public var canUndo: Bool {
        !undoStack.isEmpty
    }

    public var canRedo: Bool {
        !redoStack.isEmpty
    }

    public init(storage: GraphStorage, physicsEngine: PhysicsEngine) {
        self.storage = storage
        self.physicsEngine = physicsEngine
        print("GraphModel initialized with storage: \(type(of: storage))")  // NEW: Log init
        
    }
}

@available(iOS 16.0, watchOS 6.0, *)
public struct GraphViewState {
    public var offset: CGPoint
    public var zoomScale: CGFloat
    public var selectedNodeID: UUID?
    public var selectedEdgeID: UUID?
}
----------------------------------------------------------------------------------------------------
File: GraphModel+EdgesNodes.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+EdgesNodes.swift
Last modified: 2025-09-19 14:07:30

Contents:
//
//  GraphModel+EdgesNodes.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    public func wouldCreateCycle(withNewEdgeFrom from: NodeID, target: NodeID, type: EdgeType) -> Bool {
        guard type == EdgeType.hierarchy else { return false } // Changed to EdgeType.hierarchy
        var tempEdges = edges.filter { $0.type == EdgeType.hierarchy } // Changed to EdgeType.hierarchy
        tempEdges.append(GraphEdge(from: from, target: target, type: type))
        return !isAcyclic(edges: tempEdges)
    }

    private func isAcyclic(edges: [GraphEdge]) -> Bool {
        var adj: [NodeID: [NodeID]] = [:]
        var inDegree: [NodeID: Int] = [:]
        nodes.forEach { inDegree[$0.id] = 0 }
        for edge in edges {
            adj[edge.from, default: []].append(edge.target)
            inDegree[edge.target, default: 0] += 1
        }
        var queue = nodes.filter { inDegree[$0.id] == 0 }.map { $0.id }
        var count = 0
        while !queue.isEmpty {
            let node = queue.removeFirst()
            count += 1
            for neighbor in adj[node] ?? [] {
                inDegree[neighbor]! -= 1
                if inDegree[neighbor]! == 0 { queue.append(neighbor) }
            }
        }
        return count == nodes.count
    }

    public func addEdge(from: NodeID, target: NodeID, type: EdgeType) async {
            if wouldCreateCycle(withNewEdgeFrom: from, target: target, type: type) {
                print("Cannot add edge: Would create cycle in hierarchy")
                return
            }
            edges.append(GraphEdge(from: from, target: target, type: type))
            objectWillChange.send()
            await startSimulation()
        }

    public func deleteEdge(withID id: UUID) async {
        edges.removeAll { $0.id == id }
        objectWillChange.send()
        await startSimulation()
    }

    public func addNode(at position: CGPoint) async {
        let newLabel = nextNodeLabel
        nextNodeLabel += 1
        let newNode = AnyNode(Node(label: newLabel, position: position))
        nodes.append(newNode)
        objectWillChange.send()
        await startSimulation()
    }

    public func addToggleNode(at position: CGPoint) async {
        let newLabel = nextNodeLabel
        nextNodeLabel += 1
        let newNode = AnyNode(ToggleNode(label: newLabel, position: position))
        nodes.append(newNode)
        objectWillChange.send()
        await startSimulation()
    }

    public func addChild(to parentID: NodeID) async {
            let newLabel = nextNodeLabel
            nextNodeLabel += 1
            guard let parentIndex = nodes.firstIndex(where: { $0.id == parentID }) else { return }
            let parentPosition = nodes[parentIndex].position
            let offsetX = CGFloat.random(in: -50...50)
            let offsetY = CGFloat.random(in: -50...50)
            let newPosition = parentPosition + CGPoint(x: offsetX, y: offsetY)
            let newNode = AnyNode(Node(label: newLabel, position: newPosition))
            nodes.append(newNode)
            await addEdge(from: parentID, target: newNode.id, type: EdgeType.hierarchy) // Changed to EdgeType.hierarchy
        }

    public func deleteNode(withID id: NodeID) async {
        nodes.removeAll { $0.id == id }
        edges.removeAll { $0.from == id || $0.target == id }
        objectWillChange.send()
        await startSimulation()
    }

    public func updateNodeContent(withID id: NodeID, newContent: NodeContent?) async {
        if let index = nodes.firstIndex(where: { $0.id == id }) {
            var updated = nodes[index].unwrapped
            updated.content = newContent
            nodes[index] = AnyNode(updated)
            objectWillChange.send()
        }
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+Helpers.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Helpers.swift
Last modified: 2025-09-19 14:07:30

Contents:
//
//  GraphModel+Helpers.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    func buildAdjacencyList(for edgeType: EdgeType? = nil) -> [NodeID: [NodeID]] { 
        var adj = [NodeID: [NodeID]]()
        let filteredEdges = edgeType != nil ? edges.filter { $0.type == edgeType! } : edges
        for edge in filteredEdges {
            adj[edge.from, default: []].append(edge.target)
        }
        return adj
    }

    private func dfsVisible(node: any NodeProtocol, adjacency: [NodeID: [NodeID]], visited: inout Set<NodeID>, visible: inout [any NodeProtocol]) {
        visited.insert(node.id)
        visible.append(node)
        if !node.isExpanded { return }
        if let children = adjacency[node.id] {
            for childID in children {
                if !visited.contains(childID), let child = nodes.first(where: { $0.id == childID })?.unwrapped {
                    dfsVisible(node: child, adjacency: adjacency, visited: &visited, visible: &visible)
                }
            }
        }
    }

    public func isBidirectionalBetween(_ id1: NodeID, _ id2: NodeID) -> Bool {
        edges.contains(where: { $0.from == id1 && $0.target == id2 }) &&
        edges.contains(where: { $0.from == id2 && $0.target == id1 })
    }

    public func edgesBetween(_ id1: NodeID, _ id2: NodeID) -> [GraphEdge] {
        edges.filter { ($0.from == id1 && $0.target == id2) || ($0.from == id2 && $0.target == id1) }
    }

    public func handleTap(on nodeID: NodeID) async {
            guard let index = nodes.firstIndex(where: { $0.id == nodeID }) else { return }
            let oldNode = nodes[index]
            let updatedNode = oldNode.handlingTap()
            nodes[index] = updatedNode

            let children = edges.filter { $0.from == nodeID && $0.type == EdgeType.hierarchy }.map { $0.target } // Changed to EdgeType.hierarchy
        
        if let toggleNode = updatedNode.unwrapped as? ToggleNode {
            if toggleNode.isExpanded {
                for childID in children {
                    guard let childIndex = nodes.firstIndex(where: { $0.id == childID }) else { continue }
                    var child = nodes[childIndex]
                    let offsetX = CGFloat.random(in: -Constants.App.nodeModelRadius * 3 ... Constants.App.nodeModelRadius * 3)
                    let offsetY = CGFloat.random(in: Constants.App.nodeModelRadius * 2 ... Constants.App.nodeModelRadius * 4)
                    child.position = toggleNode.position + CGPoint(x: offsetX, y: offsetY)
                    child.velocity = .zero
                    nodes[childIndex] = child
                }
                physicsEngine.temporaryDampingBoost(steps: Constants.Physics.maxSimulationSteps / 10)
            } else {
                for childID in children {
                    guard let childIndex = nodes.firstIndex(where: { $0.id == childID }) else { continue }
                    var child = nodes[childIndex]
                    child.position = toggleNode.position
                    child.velocity = .zero
                    nodes[childIndex] = child
                }
            }
        }

        objectWillChange.send()
        let unwrappedNodes = nodes.map { $0.unwrapped }
        let updatedUnwrapped = physicsEngine.runSimulation(steps: 20, nodes: unwrappedNodes, edges: edges)
        nodes = updatedUnwrapped.map { AnyNode($0) }
        await resumeSimulation()
    }

    public func graphDescription(selectedID: NodeID?, selectedEdgeID: UUID?) -> String {
        let edgeCount = edges.count
        let edgeWord = edgeCount == 1 ? "edge" : "edges"
        var desc = "Graph with \(nodes.count) nodes and \(edgeCount) directed \(edgeWord)."
        if let selectedEdgeID = selectedEdgeID, let selectedEdge = edges.first(where: { $0.id == selectedEdgeID }),
           let fromNode = nodes.first(where: { $0.id == selectedEdge.from })?.unwrapped,
           let toNode = nodes.first(where: { $0.id == selectedEdge.target })?.unwrapped {
            desc += " Directed edge from node \(fromNode.label) to node \(toNode.label) selected."
        } else if let selectedID = selectedID, let selectedNode = nodes.first(where: { $0.id == selectedID })?.unwrapped {
            let outgoingLabels = edges
                .filter { $0.from == selectedID }
                .compactMap { edge in
                    let toID = edge.target
                    return nodes.first { $0.id == toID }?.unwrapped.label
                }
                .sorted()
                .map { String($0) }
                .joined(separator: ", ")
            let incomingLabels = edges
                .filter { $0.target == selectedID }
                .compactMap { edge in
                    let fromID = edge.from
                    return nodes.first { $0.id == fromID }?.unwrapped.label
                }
                .sorted()
                .map { String($0) }
                .joined(separator: ", ")
            let outgoingText = outgoingLabels.isEmpty ? "none" : outgoingLabels
            let incomingText = incomingLabels.isEmpty ? "none" : incomingLabels
            desc += " Node \(selectedNode.label) selected, outgoing to: \(outgoingText); incoming from: \(incomingText)."
        } else {
            desc += " No node or edge selected."
        }
        return desc
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+Simulation.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Simulation.swift
Last modified: 2025-09-19 14:07:30

Contents:
//
//  GraphModel+Simulation.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    public func resizeSimulationBounds(for nodeCount: Int) async {
        let newSize = max(300.0, sqrt(Double(nodeCount)) * 100.0)
        self.physicsEngine = PhysicsEngine(simulationBounds: CGSize(width: newSize, height: newSize))
        self.simulator = GraphSimulator(
            getNodes: { [weak self] in self?.nodes.map { $0.unwrapped } ?? [] },
            setNodes: { [weak self] newNodes in
                self?.nodes = newNodes.map { AnyNode($0) }
            },
            getEdges: { [weak self] in self?.edges ?? [] },
            getVisibleNodes: { [weak self] in self?.visibleNodes() ?? [] },
            getVisibleEdges: { [weak self] in self?.visibleEdges() ?? [] },
            physicsEngine: self.physicsEngine,
            onStable: { [weak self] in
                guard let self = self else { return }
                print("Simulation stable: Centering nodes")
                let centeredNodes = self.physicsEngine.centerNodes(nodes: self.nodes.map { $0.unwrapped })
                self.nodes = centeredNodes.map { AnyNode($0.with(position: $0.position, velocity: .zero)) }
                self.isStable = true
                self.objectWillChange.send()
            }
        )
    }

    public func startSimulation() async {
        isStable = false
        simulationError = nil
        isSimulating = true
        await simulator.startSimulation()
        isSimulating = false
    }

    public func stopSimulation() async {
        await simulator.stopSimulation()
    }

    public func pauseSimulation() async {
        await stopSimulation()
        physicsEngine.isPaused = true
    }

    public func resumeSimulation() async {
        physicsEngine.isPaused = false
        await startSimulation()
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+Storage.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Storage.swift
Last modified: 2025-09-20 10:09:45

Contents:
//
//  GraphModel+Storage.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    private func loadFromStorage() async throws {
        print("loadFromStorage started")  // Existing
        let (loadedNodes, loadedEdges) = try await storage.load()
        print("loadFromStorage: loaded \(loadedNodes.count) nodes, \(loadedEdges.count) edges")  // NEW for consistency
        self.nodes = loadedNodes.map { AnyNode($0) }
        self.edges = loadedEdges
        self.nextNodeLabel = (nodes.map { $0.unwrapped.label }.max() ?? 0) + 1
    }
    
    public func load() async {
        print("GraphModel.load() called")  // Existing
        do {
            try await loadFromStorage()
            syncCollapsedPositions()
            if let viewState = try await loadViewState() {  // NEW: Load view state during graph load
                // Apply view state if needed (e.g., publish or set properties)
                print("Loaded view state: offset \(viewState.offset), zoom \(viewState.zoomScale)")
            }
            print("GraphModel.load() succeeded; nodes: \(nodes.count), edges: \(edges.count)")  // NEW
        } catch {
            print("GraphModel.load() failed: \(error.localizedDescription)")  // Enhanced
        }
    }
    
    public func save() async {
        print("GraphModel.save() called; nodes: \(nodes.count), edges: \(edges.count)")  // Existing
        do {
            try await storage.save(nodes: nodes.map { $0.unwrapped }, edges: edges)
            print("GraphModel.save() succeeded")  // Existing
        } catch {
            print("GraphModel.save() failed: \(error.localizedDescription)")  // Existing
        }
    }
    
    private func syncCollapsedPositions() {
        for parentIndex in 0..<nodes.count {
            if let toggle = nodes[parentIndex].unwrapped as? ToggleNode, !toggle.isExpanded {
                let children = edges.filter { $0.from == nodes[parentIndex].id && $0.type == .hierarchy }.map { $0.target }
                for (index, childID) in children.enumerated() {
                    guard let childIndex = nodes.firstIndex(where: { $0.id == childID }) else { continue }
                    var child = nodes[childIndex]
                    let angle = CGFloat(index) * (2 * .pi / CGFloat(children.count))
                    let jitterX = cos(angle) * 5.0
                    let jitterY = sin(angle) * 5.0
                    child.position = nodes[parentIndex].position + CGPoint(x: jitterX, y: jitterY)
                    child.velocity = .zero
                    nodes[childIndex] = child
                }
            }
        }
        objectWillChange.send()
    }
    
    public func clearGraph() async {
            print("clearGraph called")  // NEW
            nodes = []
            edges = []
            nextNodeLabel = 1
            do {
                try await storage.clear()
                try await storage.saveViewState(ViewState(offset: .zero, zoomScale: 1.0, selectedNodeID: nil, selectedEdgeID: nil))  // NEW: Clear view state too
                print("clearGraph succeeded")  // Existing
            } catch {
                print("clearGraph failed: \(error.localizedDescription)")  // Existing
            }
            objectWillChange.send()
        }
    }
----------------------------------------------------------------------------------------------------
File: GraphModel+Undo.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Undo.swift
Last modified: 2025-09-25 10:28:00

Contents:
//
//  GraphModel+Undo.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    public func snapshot() async {
        print("snapshot() called from: \(#function), nodes: \(nodes.count), edges: \(edges.count)")  // Add for debugging
        let state = GraphState(nodes: nodes.map { $0.unwrapped }, edges: edges)
        undoStack.append(state)
        if undoStack.count > maxUndo { undoStack.removeFirst() }
        redoStack.removeAll()
        await save()  // NEW: Auto-save graph data on snapshot (triggered by mutations)
        print("snapshot() completed; undoStack size: \(undoStack.count)")  // Add for debugging
    }

    public func undo() async {
        print("undo() called; undoStack size: \(undoStack.count)")  // Debugging
        guard undoStack.count > 1 else {
            print("undo() early return: cannot undo further")
            return
        }
        if let popped = undoStack.popLast() {
            redoStack.append(popped)
            if let previous = undoStack.last {
                nodes = previous.nodes.map { AnyNode($0) }
                edges = previous.edges
                objectWillChange.send()
                await save()  // Auto-save
                print("undo() completed; nodes: \(nodes.count), undoStack size: \(undoStack.count), redoStack size: \(redoStack.count)")  // Debugging
            }
        }
    }
    
    public func redo() async {
        print("redo() called; redoStack size: \(redoStack.count)")  // Debugging
        guard let state = redoStack.popLast() else { return }
        nodes = state.nodes.map { AnyNode($0) }
        edges = state.edges
        undoStack.append(state)
        objectWillChange.send()
        await save()  // Auto-save
        print("redo() completed; nodes: \(nodes.count), undoStack size: \(undoStack.count), redoStack size: \(redoStack.count)")  // Debugging (updated to include stacks)
    }

    public func saveViewState(offset: CGPoint, zoomScale: CGFloat, selectedNodeID: UUID?, selectedEdgeID: UUID?) async throws {
        print("GraphModel.saveViewState called with offset: \(offset), zoom: \(zoomScale)")  // Add for debugging
        let viewState = ViewState(offset: offset, zoomScale: zoomScale, selectedNodeID: selectedNodeID, selectedEdgeID: selectedEdgeID)
        try await storage.saveViewState(viewState)  // Delegate to storage (e.g., UserDefaults)
    }

    public func loadViewState() async throws -> ViewState? {
        print("GraphModel.loadViewState called")  // Add for debugging
        return try await storage.loadViewState()  // Delegate to storage
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+Visibility.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Visibility.swift
Last modified: 2025-09-19 14:07:30

Contents:
//
//  GraphModel+Visibility.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    public func visibleNodes() -> [any NodeProtocol] {
        let hidden = hiddenNodeIDs
        return nodes.filter { !hidden.contains($0.id) }.map { $0.unwrapped }
    }

    public func visibleEdges() -> [GraphEdge] {
        let hidden = hiddenNodeIDs
        return edges.filter { !hidden.contains($0.from) && !hidden.contains($0.target) }
    }

    public func boundingBox() -> CGRect {
        self.physicsEngine.boundingBox(nodes: nodes.map { $0.unwrapped })
    }

    public func centerGraph() {
        let centered = physicsEngine.centerNodes(nodes: nodes.map { $0.unwrapped })
        nodes = centered.map { AnyNode($0) }
        objectWillChange.send()
    }

    public func expandAllRoots() async {
        for var root in buildRoots() {
            root.isExpanded = true
            if let index = nodes.firstIndex(where: { $0.id == root.id }) {
                nodes[index] = AnyNode(root)
            }
        }
        objectWillChange.send()
    }

    private func buildRoots() -> [any NodeProtocol] {
        var incoming = Set<NodeID>()
        for edge in edges {
            incoming.insert(edge.target)
        }
        return nodes.filter { !incoming.contains($0.id) }.map { $0.unwrapped }
    }
}
----------------------------------------------------------------------------------------------------
File: GraphSimulator.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphSimulator.swift
Last modified: 2025-09-24 11:08:58

Contents:
// Sources/GraphEditorShared/GraphSimulator.swift

import Foundation
import os.log  // For logging if needed

#if os(watchOS)
import WatchKit  // Only if using haptics; otherwise remove
#endif

@available(iOS 16.0, watchOS 6.0, *)
/// Manages physics simulation loops for graph updates.
class GraphSimulator {
    private(set) var simulationTask: Task<Void, Never>?  // Exposed for testing
    private(set) var recentVelocities: [CGFloat] = []  // Exposed for testing
    
    let velocityChangeThreshold: CGFloat
    let velocityHistoryCount: Int
    let baseInterval: TimeInterval  // Now configurable
    
    let physicsEngine: PhysicsEngine
    private let getVisibleNodes: () -> [any NodeProtocol]
    private let getVisibleEdges: () -> [GraphEdge]
    
    private let getNodes: () -> [any NodeProtocol]  // Updated: Polymorphic
    private let setNodes: ([any NodeProtocol]) -> Void  // Updated: Polymorphic
    private let getEdges: () -> [GraphEdge]
    private let onStable: (() -> Void)?  // New: Optional callback
    
    init(getNodes: @escaping () -> [any NodeProtocol],
         setNodes: @escaping ([any NodeProtocol]) -> Void,
         getEdges: @escaping () -> [GraphEdge],
         getVisibleNodes: @escaping () -> [any NodeProtocol],
         getVisibleEdges: @escaping () -> [GraphEdge],
         physicsEngine: PhysicsEngine,
         onStable: (() -> Void)? = nil,
         baseInterval: TimeInterval = 1.0 / 30.0,  // Default value
         velocityChangeThreshold: CGFloat = 0.01,
         velocityHistoryCount: Int = 5) {
        self.getNodes = getNodes
        self.setNodes = setNodes
        self.getEdges = getEdges
        self.physicsEngine = physicsEngine
        self.onStable = onStable
        
        self.getVisibleNodes = getVisibleNodes
        self.getVisibleEdges = getVisibleEdges
        
        self.baseInterval = baseInterval
        self.velocityChangeThreshold = velocityChangeThreshold
        self.velocityHistoryCount = velocityHistoryCount
    }
    
    struct SimulationStepResult {
        let updatedNodes: [any NodeProtocol]
        let shouldContinue: Bool
        let totalVelocity: CGFloat
    }
    
    @MainActor
    func startSimulation() async {
        #if os(watchOS)
        guard WKApplication.shared().applicationState == .active else { return }
        #endif
        physicsEngine.resetSimulation()
        recentVelocities.removeAll()
        
        let nodeCount = getNodes().count
        if nodeCount < 5 { return }
        
        var adjustedInterval = baseInterval
        if nodeCount >= 20 {
            adjustedInterval = nodeCount < 50 ? 1.0 / 15.0 : 1.0 / 10.0
        }
        if ProcessInfo.processInfo.isLowPowerModeEnabled {
            adjustedInterval *= 2.0
        }
        
        simulationTask = Task {
            await self.runSimulationLoop(baseInterval: adjustedInterval, nodeCount: nodeCount)
        }
        await simulationTask?.value
    }
    
    private func runSimulationLoop(baseInterval: TimeInterval, nodeCount: Int) async {
        while !Task.isCancelled {
            let shouldContinue = await performSimulationStep(baseInterval: baseInterval, nodeCount: nodeCount)
            if !shouldContinue {
                break
            }
        }
        self.onStable?()
    }
    
    private func performSimulationStep(baseInterval: TimeInterval, nodeCount: Int) async -> Bool {
        #if os(watchOS)
        if await WKApplication.shared().applicationState != .active { return false }
        #endif
        
        let result: SimulationStepResult = await Task.detached {
            return self.computeSimulationStep()
        }.value
        
        self.setNodes(result.updatedNodes)
        
        if self.shouldStopSimulation(result: result, nodeCount: nodeCount) {
            return false
        }
        
        try? await Task.sleep(for: .seconds(baseInterval))
        return true
    }
    
    private nonisolated func computeSimulationStep() -> SimulationStepResult {
        let nodes = self.getNodes()
        let visibleNodes = self.getVisibleNodes()
        let visibleEdges = self.getVisibleEdges()
        let (forces, quadtree) = self.physicsEngine.repulsionCalculator.computeRepulsions(nodes: visibleNodes)
        var updatedForces = forces
        updatedForces = self.physicsEngine.attractionCalculator.applyAttractions(forces: updatedForces, edges: visibleEdges, nodes: visibleNodes)
        updatedForces = self.physicsEngine.centeringCalculator.applyCentering(forces: updatedForces, nodes: visibleNodes)
        
        var tempNodes = nodes
        var stepActive = false
        let subSteps = nodes.count < 5 ? 2 : (nodes.count < 10 ? 5 : (nodes.count < 30 ? 3 : 1))
        for _ in 0..<subSteps {
            let (updated, active) = self.physicsEngine.positionUpdater.updatePositionsAndVelocities(nodes: tempNodes, forces: updatedForces, edges: self.getEdges(), quadtree: quadtree)
            tempNodes = updated
            stepActive = stepActive || active
        }
        
        let totalVel = tempNodes.reduce(0.0) { $0 + hypot($1.velocity.x, $1.velocity.y) }
        return SimulationStepResult(updatedNodes: tempNodes, shouldContinue: stepActive, totalVelocity: totalVel)
    }
    
    private func shouldStopSimulation(result: SimulationStepResult, nodeCount: Int) -> Bool {
        if !result.shouldContinue || result.totalVelocity < Constants.Physics.velocityThreshold * CGFloat(nodeCount) {
            return true
        }
        
        recentVelocities.append(result.totalVelocity)
        if recentVelocities.count > velocityHistoryCount {
            recentVelocities.removeFirst()
        }
        
        if recentVelocities.count == velocityHistoryCount {
            let maxVel = recentVelocities.max() ?? 1.0
            let minVel = recentVelocities.min() ?? 0.0
            let relativeChange = (maxVel - minVel) / maxVel
            if relativeChange < velocityChangeThreshold {
                return true
            }
        }
        
        return false
    }
    
    func stopSimulation() async {
        simulationTask?.cancel()
        await simulationTask?.value  // Await to ensure clean stop
        simulationTask = nil
    }
}
--------------------------------------------------
