## Focused Project Concatenation
This file includes only UI, interactivity, model, and core logic files.
Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
Current date: 2025-11-12 10:00:32
Table of Contents:
1. GraphEditorShared/.build/arm64-apple-macosx/debug/GraphEditorSharedPackageTests.derived/runner.swift
2. GraphEditorShared/Sources/GraphEditorShared/AttractionCalculator.swift
3. GraphEditorShared/Sources/GraphEditorShared/CenteringCalculator.swift
4. GraphEditorShared/Sources/GraphEditorShared/Constants.swift
5. GraphEditorShared/Sources/GraphEditorShared/CoordinateTransformer.swift
6. GraphEditorShared/Sources/GraphEditorShared/GraphError.swift
7. GraphEditorShared/Sources/GraphEditorShared/GraphModel.swift--------------------------------------------------
File: runner.swift
Path: GraphEditorShared/.build/arm64-apple-macosx/debug/GraphEditorSharedPackageTests.derived/runner.swift
Last modified: 2025-11-11 13:15:43

Contents:
#if canImport(Testing)
import Testing
#endif

#if false
import Foundation
import XCTest

public final class SwiftPMXCTestObserver: NSObject {
    public override init() {
        super.init()
        XCTestObservationCenter.shared.addTestObserver(self)
    }
}

extension SwiftPMXCTestObserver: XCTestObservation {
    var testOutputPath: String {
        return "/Users/handcart/Development/GraphEditor/GraphEditorShared/.build/arm64-apple-macosx/debug/testOutput.txt"
    }

    private func write(record: any Encodable) {
        let lock = FileLock(at: URL(fileURLWithPath: self.testOutputPath + ".lock"))
        _ = try? lock.withLock {
            self._write(record: record)
        }
    }

    private func _write(record: any Encodable) {
        if let data = try? JSONEncoder().encode(record) {
            if let fileHandle = FileHandle(forWritingAtPath: self.testOutputPath) {
                defer { fileHandle.closeFile() }
                fileHandle.seekToEndOfFile()
                fileHandle.write("
".data(using: .utf8)!)
                fileHandle.write(data)
            } else {
                _ = try? data.write(to: URL(fileURLWithPath: self.testOutputPath))
            }
        }
    }

    public func testBundleWillStart(_ testBundle: Bundle) {
        let record = TestBundleEventRecord(bundle: .init(testBundle), event: .start)
        write(record: TestEventRecord(bundleEvent: record))
    }

    public func testSuiteWillStart(_ testSuite: XCTestSuite) {
        let record = TestSuiteEventRecord(suite: .init(testSuite), event: .start)
        write(record: TestEventRecord(suiteEvent: record))
    }

    public func testCaseWillStart(_ testCase: XCTestCase) {
        let record = TestCaseEventRecord(testCase: .init(testCase), event: .start)
        write(record: TestEventRecord(caseEvent: record))
    }

    #if canImport(Darwin)
    public func testCase(_ testCase: XCTestCase, didRecord issue: XCTIssue) {
        let record = TestCaseFailureRecord(testCase: .init(testCase), issue: .init(issue), failureKind: .unexpected)
        write(record: TestEventRecord(caseFailure: record))
    }

    public func testCase(_ testCase: XCTestCase, didRecord expectedFailure: XCTExpectedFailure) {
        let record = TestCaseFailureRecord(testCase: .init(testCase), issue: .init(expectedFailure.issue), failureKind: .expected(failureReason: expectedFailure.failureReason))
        write(record: TestEventRecord(caseFailure: record))
    }
    #else
    public func testCase(_ testCase: XCTestCase, didFailWithDescription description: String, inFile filePath: String?, atLine lineNumber: Int) {
        let issue = TestIssue(description: description, inFile: filePath, atLine: lineNumber)
        let record = TestCaseFailureRecord(testCase: .init(testCase), issue: issue, failureKind: .unexpected)
        write(record: TestEventRecord(caseFailure: record))
    }
    #endif

    public func testCaseDidFinish(_ testCase: XCTestCase) {
        let record = TestCaseEventRecord(testCase: .init(testCase), event: .finish)
        write(record: TestEventRecord(caseEvent: record))
    }

    #if canImport(Darwin)
    public func testSuite(_ testSuite: XCTestSuite, didRecord issue: XCTIssue) {
        let record = TestSuiteFailureRecord(suite: .init(testSuite), issue: .init(issue), failureKind: .unexpected)
        write(record: TestEventRecord(suiteFailure: record))
    }

    public func testSuite(_ testSuite: XCTestSuite, didRecord expectedFailure: XCTExpectedFailure) {
        let record = TestSuiteFailureRecord(suite: .init(testSuite), issue: .init(expectedFailure.issue), failureKind: .expected(failureReason: expectedFailure.failureReason))
        write(record: TestEventRecord(suiteFailure: record))
    }
    #else
    public func testSuite(_ testSuite: XCTestSuite, didFailWithDescription description: String, inFile filePath: String?, atLine lineNumber: Int) {
        let issue = TestIssue(description: description, inFile: filePath, atLine: lineNumber)
        let record = TestSuiteFailureRecord(suite: .init(testSuite), issue: issue, failureKind: .unexpected)
        write(record: TestEventRecord(suiteFailure: record))
    }
    #endif

    public func testSuiteDidFinish(_ testSuite: XCTestSuite) {
        let record = TestSuiteEventRecord(suite: .init(testSuite), event: .finish)
        write(record: TestEventRecord(suiteEvent: record))
    }

    public func testBundleDidFinish(_ testBundle: Bundle) {
        let record = TestBundleEventRecord(bundle: .init(testBundle), event: .finish)
        write(record: TestEventRecord(bundleEvent: record))
    }
}

// FIXME: Copied from `Lock.swift` in TSCBasic, would be nice if we had a better way

#if canImport(Glibc)
@_exported import Glibc
#elseif canImport(Musl)
@_exported import Musl
#elseif os(Windows)
@_exported import CRT
@_exported import WinSDK
#elseif os(WASI)
@_exported import WASILibc
#elseif canImport(Android)
@_exported import Android
#else
@_exported import Darwin.C
#endif

import Foundation

public final class FileLock {
  #if os(Windows)
    private var handle: HANDLE?
  #else
    private var fileDescriptor: CInt?
  #endif

    private let lockFile: URL

    public init(at lockFile: URL) {
        self.lockFile = lockFile
    }

    public func lock() throws {
      #if os(Windows)
        if handle == nil {
            let h: HANDLE = lockFile.path.withCString(encodedAs: UTF16.self, {
                CreateFileW(
                    $0,
                    UInt32(GENERIC_READ) | UInt32(GENERIC_WRITE),
                    UInt32(FILE_SHARE_READ) | UInt32(FILE_SHARE_WRITE),
                    nil,
                    DWORD(OPEN_ALWAYS),
                    DWORD(FILE_ATTRIBUTE_NORMAL),
                    nil
                )
            })
            if h == INVALID_HANDLE_VALUE {
                throw FileSystemError(errno: Int32(GetLastError()), lockFile)
            }
            self.handle = h
        }
        var overlapped = OVERLAPPED()
        overlapped.Offset = 0
        overlapped.OffsetHigh = 0
        overlapped.hEvent = nil
        if !LockFileEx(handle, DWORD(LOCKFILE_EXCLUSIVE_LOCK), 0,
                           UInt32.max, UInt32.max, &overlapped) {
                throw ProcessLockError.unableToAquireLock(errno: Int32(GetLastError()))
            }
      #elseif os(WASI)
        // WASI doesn't support flock
      #else
        if fileDescriptor == nil {
            let fd = open(lockFile.path, O_WRONLY | O_CREAT | O_CLOEXEC, 0o666)
            if fd == -1 {
                fatalError("errno: \(errno), lockFile: \(lockFile)")
            }
            self.fileDescriptor = fd
        }
        while true {
            if flock(fileDescriptor!, LOCK_EX) == 0 {
                break
            }
            if errno == EINTR { continue }
            fatalError("unable to acquire lock, errno: \(errno)")
        }
      #endif
    }

    public func unlock() {
      #if os(Windows)
        var overlapped = OVERLAPPED()
        overlapped.Offset = 0
        overlapped.OffsetHigh = 0
        overlapped.hEvent = nil
        UnlockFileEx(handle, 0, UInt32.max, UInt32.max, &overlapped)
      #elseif os(WASI)
        // WASI doesn't support flock
      #else
        guard let fd = fileDescriptor else { return }
        flock(fd, LOCK_UN)
      #endif
    }

    deinit {
      #if os(Windows)
        guard let handle = handle else { return }
        CloseHandle(handle)
      #elseif os(WASI)
        // WASI doesn't support flock
      #else
        guard let fd = fileDescriptor else { return }
        close(fd)
      #endif
    }

    public func withLock<T>(_ body: () throws -> T) throws -> T {
        try lock()
        defer { unlock() }
        return try body()
    }

    public func withLock<T>(_ body: () async throws -> T) async throws -> T {
        try lock()
        defer { unlock() }
        return try await body()
    }
}

// FIXME: Copied from `XCTEvents.swift`, would be nice if we had a better way

struct TestEventRecord: Codable {
    let caseFailure: TestCaseFailureRecord?
    let suiteFailure: TestSuiteFailureRecord?

    let bundleEvent: TestBundleEventRecord?
    let suiteEvent: TestSuiteEventRecord?
    let caseEvent: TestCaseEventRecord?

    init(
        caseFailure: TestCaseFailureRecord? = nil,
        suiteFailure: TestSuiteFailureRecord? = nil,
        bundleEvent: TestBundleEventRecord? = nil,
        suiteEvent: TestSuiteEventRecord? = nil,
        caseEvent: TestCaseEventRecord? = nil
    ) {
        self.caseFailure = caseFailure
        self.suiteFailure = suiteFailure
        self.bundleEvent = bundleEvent
        self.suiteEvent = suiteEvent
        self.caseEvent = caseEvent
    }
}

// MARK: - Records

struct TestAttachment: Codable {
    let name: String?
    // TODO: Handle `userInfo: [AnyHashable : Any]?`
    let uniformTypeIdentifier: String
    let payload: Data?
}

struct TestBundleEventRecord: Codable {
    let bundle: TestBundle
    let event: TestEvent
}

struct TestCaseEventRecord: Codable {
    let testCase: TestCase
    let event: TestEvent
}

struct TestCaseFailureRecord: Codable, CustomStringConvertible {
    let testCase: TestCase
    let issue: TestIssue
    let failureKind: TestFailureKind

    var description: String {
        return "\(issue.sourceCodeContext.description)\(testCase) \(issue.compactDescription)"
    }
}

struct TestSuiteEventRecord: Codable {
    let suite: TestSuiteRecord
    let event: TestEvent
}

struct TestSuiteFailureRecord: Codable {
    let suite: TestSuiteRecord
    let issue: TestIssue
    let failureKind: TestFailureKind
}

// MARK: Primitives

struct TestBundle: Codable {
    let bundleIdentifier: String?
    let bundlePath: String
}

struct TestCase: Codable {
    let name: String
}

struct TestErrorInfo: Codable {
    let description: String
    let type: String
}

enum TestEvent: Codable {
    case start
    case finish
}

enum TestFailureKind: Codable, Equatable {
    case unexpected
    case expected(failureReason: String?)

    var isExpected: Bool {
        switch self {
        case .expected: return true
        case .unexpected: return false
        }
    }
}

struct TestIssue: Codable {
    let type: TestIssueType
    let compactDescription: String
    let detailedDescription: String?
    let associatedError: TestErrorInfo?
    let sourceCodeContext: TestSourceCodeContext
    let attachments: [TestAttachment]
}

enum TestIssueType: Codable {
    case assertionFailure
    case performanceRegression
    case system
    case thrownError
    case uncaughtException
    case unmatchedExpectedFailure
    case unknown
}

struct TestLocation: Codable, CustomStringConvertible {
    let file: String
    let line: Int

    var description: String {
        return "\(file):\(line) "
    }
}

struct TestSourceCodeContext: Codable, CustomStringConvertible {
    let callStack: [TestSourceCodeFrame]
    let location: TestLocation?

    var description: String {
        return location?.description ?? ""
    }
}

struct TestSourceCodeFrame: Codable {
    let address: UInt64
    let symbolInfo: TestSourceCodeSymbolInfo?
    let symbolicationError: TestErrorInfo?
}

struct TestSourceCodeSymbolInfo: Codable {
    let imageName: String
    let symbolName: String
    let location: TestLocation?
}

struct TestSuiteRecord: Codable {
    let name: String
}

// MARK: XCTest compatibility

extension TestIssue {
    init(description: String, inFile filePath: String?, atLine lineNumber: Int) {
        let location: TestLocation?
        if let filePath = filePath {
            location = .init(file: filePath, line: lineNumber)
        } else {
            location = nil
        }
        self.init(type: .assertionFailure, compactDescription: description, detailedDescription: description, associatedError: nil, sourceCodeContext: .init(callStack: [], location: location), attachments: [])
    }
}

import XCTest

#if canImport(Darwin) // XCTAttachment is unavailable in swift-corelibs-xctest.
extension TestAttachment {
    init(_ attachment: XCTAttachment) {
        self.init(
            name: attachment.name,
            uniformTypeIdentifier: attachment.uniformTypeIdentifier,
            payload: attachment.value(forKey: "payload") as? Data
        )
    }
}
#endif

extension TestBundle {
    init(_ testBundle: Bundle) {
        self.init(
            bundleIdentifier: testBundle.bundleIdentifier,
            bundlePath: testBundle.bundlePath
        )
    }
}

extension TestCase {
    init(_ testCase: XCTestCase) {
        self.init(name: testCase.name)
    }
}

extension TestErrorInfo {
    init(_ error: any Swift.Error) {
        self.init(description: "\(error)", type: "\(Swift.type(of: error))")
    }
}

#if canImport(Darwin) // XCTIssue is unavailable in swift-corelibs-xctest.
extension TestIssue {
    init(_ issue: XCTIssue) {
        self.init(
            type: .init(issue.type),
            compactDescription: issue.compactDescription,
            detailedDescription: issue.detailedDescription,
            associatedError: issue.associatedError.map { .init($0) },
            sourceCodeContext: .init(issue.sourceCodeContext),
            attachments: issue.attachments.map { .init($0) }
        )
    }
}

extension TestIssueType {
    init(_ type: XCTIssue.IssueType) {
        switch type {
        case .assertionFailure: self = .assertionFailure
        case .thrownError: self = .thrownError
        case .uncaughtException: self = .uncaughtException
        case .performanceRegression: self = .performanceRegression
        case .system: self = .system
        case .unmatchedExpectedFailure: self = .unmatchedExpectedFailure
        @unknown default: self = .unknown
        }
    }
}
#endif

#if canImport(Darwin) // XCTSourceCodeLocation/XCTSourceCodeContext/XCTSourceCodeFrame/XCTSourceCodeSymbolInfo is unavailable in swift-corelibs-xctest.
extension TestLocation {
    init(_ location: XCTSourceCodeLocation) {
        self.init(
            file: location.fileURL.absoluteString,
            line: location.lineNumber
        )
    }
}

extension TestSourceCodeContext {
    init(_ context: XCTSourceCodeContext) {
        self.init(
            callStack: context.callStack.map { .init($0) },
            location: context.location.map { .init($0) }
        )
    }
}

extension TestSourceCodeFrame {
    init(_ frame: XCTSourceCodeFrame) {
        self.init(
            address: frame.address,
            symbolInfo: (try? frame.symbolInfo()).map { .init($0) },
            symbolicationError: frame.symbolicationError.map { .init($0) }
        )
    }
}

extension TestSourceCodeSymbolInfo {
    init(_ symbolInfo: XCTSourceCodeSymbolInfo) {
        self.init(
            imageName: symbolInfo.imageName,
            symbolName: symbolInfo.symbolName,
            location: symbolInfo.location.map { .init($0) }
        )
    }
}
#endif

extension TestSuiteRecord {
    init(_ testSuite: XCTestSuite) {
        self.init(name: testSuite.name)
    }
}

import XCTest

#endif

@main
@available(macOS 10.15, iOS 11, watchOS 4, tvOS 11, *)
@available(*, deprecated, message: "Not actually deprecated. Marked as deprecated to allow inclusion of deprecated tests (which test deprecated functionality) without warnings")
struct Runner {
    private static func testingLibrary() -> String {
        var iterator = CommandLine.arguments.makeIterator()
        while let argument = iterator.next() {
            if argument == "--testing-library", let libraryName = iterator.next() {
                return libraryName.lowercased()
            }
        }

        // Fallback if not specified: run XCTest (legacy behavior)
        return "xctest"
    }

    #if false
    @_silgen_name("$ss13_runAsyncMainyyyyYaKcF")
    private static func _runAsyncMain(_ asyncFun: @Sendable @escaping () async throws -> ())
    #endif

    static func main() async {
        let testingLibrary = Self.testingLibrary()
        #if canImport(Testing)
        if testingLibrary == "swift-testing" {
            #if false
            _runAsyncMain {
                await Testing.__swiftPMEntryPoint() as Never
            }
            #else
            await Testing.__swiftPMEntryPoint() as Never
            #endif
        }
        #endif
        #if false
        if testingLibrary == "xctest" {
            
             XCTMain(__allDiscoveredTests()) as Never
        }
        #endif
    }
}
----------------------------------------------------------------------------------------------------
File: AttractionCalculator.swift
Path: GraphEditorShared/Sources/GraphEditorShared/AttractionCalculator.swift
Last modified: 2025-10-27 09:22:03

Contents:
//
//  AttractionCalculator.swift
//  GraphEditorShared
//
//  Created by handcart on 8/12/25.
//

import Foundation  // For hypot, CGFloat, etc.
import CoreGraphics  // For CGPoint, CGVector (used internally)

@available(iOS 16.0, watchOS 9.0, *)
struct AttractionCalculator {
    let symmetricFactor: CGFloat
    let useAsymmetric: Bool  // New: Controls full asymmetry for hierarchy edges
    let usePreferredAngles: Bool  // NEW: Controls angular torque for hierarchies

    init(symmetricFactor: CGFloat, useAsymmetric: Bool = false, usePreferredAngles: Bool = true) {  // UPDATED: Default usePreferredAngles to true for hierarchies
        self.symmetricFactor = symmetricFactor
        self.useAsymmetric = useAsymmetric
        self.usePreferredAngles = usePreferredAngles
    }

    func applyAttractions(forces: [NodeID: CGPoint], edges: [GraphEdge], nodes: [any NodeProtocol]) -> [NodeID: CGPoint] {
        var updatedForces = forces
        for edge in edges {
            guard let fromNode = nodes.first(where: { $0.id == edge.from }),
                  let toNode = nodes.first(where: { $0.id == edge.target }) else { continue }
            let deltaX = toNode.position.x - fromNode.position.x
            let deltaY = toNode.position.y - fromNode.position.y
            let dist = max(hypot(deltaX, deltaY), Constants.Physics.distanceEpsilon)
            let forceMagnitude = Constants.Physics.stiffness * (dist - Constants.Physics.idealLength)
            let forceDirectionX = deltaX / dist
            let forceDirectionY = deltaY / dist
            let forceX = forceDirectionX * forceMagnitude
            let forceY = forceDirectionY * forceMagnitude
            
            let symForceX = forceX * self.symmetricFactor
            let symForceY = forceY * self.symmetricFactor
            
            let currentForceFrom = updatedForces[fromNode.id] ?? CGPoint.zero
            let currentForceTo = updatedForces[toNode.id] ?? CGPoint.zero
            
            let isHierarchy = edge.type == .hierarchy
            if isHierarchy && self.useAsymmetric {
                // Full asymmetric: Strong pull 'to' toward 'from'; minimal back-pull on 'from' (test-friendly)
                let asymmetricFactor: CGFloat = 2.0  // Stronger pull for 'to'; tune if needed
                let toForceX = -forceX * asymmetricFactor  // Pull 'to' left/up toward 'from'
                let toForceY = -forceY * asymmetricFactor
                let fromBackPullX = forceX * 0.1  // Minimal back-pull (10% to keep stable)
                let fromBackPullY = forceY * 0.1
                
                updatedForces[toNode.id] = CGPoint(x: currentForceTo.x + toForceX, y: currentForceTo.y + toForceY)
                updatedForces[fromNode.id] = CGPoint(x: currentForceFrom.x + fromBackPullX, y: currentForceFrom.y + fromBackPullY)
            } else if isHierarchy {
                // Symmetric for stability (net force zero)
                updatedForces[toNode.id] = CGPoint(x: currentForceTo.x - forceX + symForceX, y: currentForceTo.y - forceY + symForceY)
                updatedForces[fromNode.id] = CGPoint(x: currentForceFrom.x + symForceX, y: currentForceFrom.y + symForceY)
            } else {
                // Symmetric for .association (unchanged)
                updatedForces[toNode.id] = CGPoint(x: currentForceTo.x - forceX + symForceX, y: currentForceTo.y - forceY + symForceY)
                updatedForces[fromNode.id] = CGPoint(x: currentForceFrom.x + symForceX, y: currentForceFrom.y + symForceY)
            }
            
            // NEW: Apply preferred angle torque if enabled and hierarchy
            if isHierarchy && usePreferredAngles, let parent = fromNode as? ToggleNode {
                let siblingIndex = parent.childOrder.firstIndex(of: toNode.id) ?? 0
                let siblingCount = max(parent.childOrder.count, 1)
                let baseAngle: CGFloat = .pi * 1.5  // 270° downward
                let spread: CGFloat = .pi / 1.5  // ~120° fan for spacing
                let anglePerSibling = siblingCount > 1 ? spread / CGFloat(siblingCount - 1) : 0
                let preferredAngle = baseAngle - spread / 2 + CGFloat(siblingIndex) * anglePerSibling
                
                let actualAngle = atan2(deltaY, deltaX)
                let angleDiff = (preferredAngle - actualAngle).clamped(to: -.pi ... .pi)  // Note: Swapped for correct direction
                
                let torqueMagnitude = Constants.Physics.angularStiffness * angleDiff * (forceMagnitude * 1.5)  // NEW: Boost scale for stronger enforcement
                
                // Torque as perpendicular components (Note: Signs flipped for correct rotation)
                let torqueX = torqueMagnitude * forceDirectionY
                let torqueY = -torqueMagnitude * forceDirectionX
                
                // Apply to child (asymmetric guidance)
                let currentTo = updatedForces[toNode.id] ?? .zero
                updatedForces[toNode.id] = CGPoint(x: currentTo.x + torqueX, y: currentTo.y + torqueY)
            }
        }
        return updatedForces
    }
}
----------------------------------------------------------------------------------------------------
File: CenteringCalculator.swift
Path: GraphEditorShared/Sources/GraphEditorShared/CenteringCalculator.swift
Last modified: 2025-09-19 13:45:29

Contents:
//
//  CenteringCalculator.swift
//  GraphEditorShared
//
//  Created by handcart on 8/12/25.
//

import Foundation
import CoreGraphics

struct CenteringCalculator {
    let simulationBounds: CGSize

    @available(iOS 16.0, *)
    func applyCentering(forces: [NodeID: CGPoint], nodes: [any NodeProtocol]) -> [NodeID: CGPoint] {
        var updatedForces = forces
        let center = CGPoint(x: simulationBounds.width / 2, y: simulationBounds.height / 2)
        for node in nodes {
            let deltaX = center.x - node.position.x
            let deltaY = center.y - node.position.y
            let distToCenter = hypot(deltaX, deltaY)
            let forceX = deltaX * Constants.Physics.centeringForce * (1 + distToCenter / max(simulationBounds.width, simulationBounds.height))
            let forceY = deltaY * Constants.Physics.centeringForce * (1 + distToCenter / max(simulationBounds.width, simulationBounds.height))
            let currentForce = updatedForces[node.id] ?? .zero
            updatedForces[node.id] = CGPoint(x: currentForce.x + forceX, y: currentForce.y + forceY)
        }
        return updatedForces
    }
}
----------------------------------------------------------------------------------------------------
File: Constants.swift
Path: GraphEditorShared/Sources/GraphEditorShared/Constants.swift
Last modified: 2025-10-29 09:39:26

Contents:
//
//  Constants.swift
//  GraphEditorShared
//
//  Created by handcart on 8/6/25.
//  Git visibility test
// Sources/GraphEditorShared/Constants.swift

import CoreGraphics

public enum Constants {
    public enum Physics {
        public static let stiffness: CGFloat = 0.4  // Reduced from 0.8 for softer springs
        public static let repulsion: CGFloat = 1200  // Reduced from 2200 for less aggressive push
        public static let damping: CGFloat = 0.94  // Updated from 0.9 for better convergence with alpha
        public static let idealLength: CGFloat = 80  // Slightly increased for more space
        public static let centeringForce: CGFloat = 0.1  // Increased from 0.03 for better centering
        public static let distanceEpsilon: CGFloat = 1e-3
        public static let timeStep: CGFloat = 0.05  // Updated to match PositionUpdater; tune if needed
        public static let velocityThreshold: CGFloat = 0.3  // Increased from 0.2 for earlier stop
        public static let maxSimulationSteps = 500  // Further reduced from 1000 for quick convergence
        public static let minQuadSize: CGFloat = 1e-6
        public static let maxQuadtreeDepth = 20
        public static let maxNodesForQuadtree = 200
        public static let minCollisionDist: CGFloat = 35.0  // New: For anti-collision separation
        public static let verticalBias: CGFloat = 0.0  // New: Downward bias for hierarchy edges (tune as needed)
        public static let alphaDecay: CGFloat = 0.0228  // New: For cooling schedule
        static let angularStiffness: CGFloat = 0.05  // Soft torque; tune up to 0.1 if needed
    }
    
    public enum App {
        public static let nodeModelRadius: CGFloat = 10.0
        public static let hitScreenRadius: CGFloat = 40.0  // Larger for watchOS tap targets
        public static let tapThreshold: CGFloat = 20.0  // Tightened from 10.0 for small screens
        public static let numZoomLevels: Int = 20  // For crown mapping
        public static let contentPadding: CGFloat = 50.0  // Padding for graph bounds
        public static let maxZoom: CGFloat = 8.0  // Maximum zoom level
    }
    
    // Add more enums as needed (e.g., UI, Testing)
}
----------------------------------------------------------------------------------------------------
File: CoordinateTransformer.swift
Path: GraphEditorShared/Sources/GraphEditorShared/CoordinateTransformer.swift
Last modified: 2025-10-14 09:11:42

Contents:
//
//  CoordinateTransformer.swift
//  GraphEditorShared
//
//  Created by handcart on 9/26/25.
//

import CoreGraphics
import SwiftUI  // For GeometryProxy if enabled
import os

/// Utility for converting between model (graph) coordinates and screen (view) coordinates.
public struct CoordinateTransformer {
    private static let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "coordinatetransformer")
    
    /// Converts a model position to screen coordinates.
    /// - Parameters:
    ///   - modelPos: The position in model space.
    ///   - effectiveCentroid: The centroid of the graph for centering.
    ///   - zoomScale: Current zoom level.
    ///   - offset: Pan offset.
    ///   - viewSize: Size of the view.
    ///   - geometry: Optional GeometryProxy for safe area adjustments (e.g., on watchOS).
    /// - Returns: Screen position.
    public static func modelToScreen(
        _ modelPos: CGPoint,
        effectiveCentroid: CGPoint,
        zoomScale: CGFloat,
        offset: CGSize,
        viewSize: CGSize
        // geometry: GeometryProxy? = nil  // Uncomment if needed for safe areas
    ) -> CGPoint {
        let viewCenter = CGPoint(x: viewSize.width / 2, y: viewSize.height / 2)
        let relativePos = modelPos - effectiveCentroid
        let scaledPos = relativePos * zoomScale
        let screenPos = viewCenter + scaledPos + CGPoint(x: offset.width, y: offset.height)
        
        // Optional: Adjust for safe areas (symmetric to screenToModel)
        // if let geo = geometry {
        //     screenPos.x += geo.safeAreaInsets.leading
        //     screenPos.y += geo.safeAreaInsets.top
        // }
        
#if DEBUG
        Self.logger.debug("modelToScreen: Model (\(modelPos.x), \(modelPos.y)) -> Screen (\(screenPos.x), \(screenPos.y)), Zoom \(zoomScale), Offset (\(offset.width), \(offset.height)), Centroid (\(effectiveCentroid.x), \(effectiveCentroid.y)), ViewSize (\(viewSize.width), \(viewSize.height))")
#endif
        
        return screenPos
    }
    
    /// Converts a screen position back to model coordinates.
    /// - Parameters:
    ///   - screenPos: The position in screen space.
    ///   - effectiveCentroid: The centroid of the graph for centering.
    ///   - zoomScale: Current zoom level.
    ///   - offset: Pan offset.
    ///   - viewSize: Size of the view.
    ///   - geometry: Optional GeometryProxy for safe area adjustments (e.g., on watchOS).
    /// - Returns: Model position (rounded to 3 decimals to reduce floating-point drift).
    public static func screenToModel(
        _ screenPos: CGPoint,
        effectiveCentroid: CGPoint,
        zoomScale: CGFloat,
        offset: CGSize,
        viewSize: CGSize
        // geometry: GeometryProxy? = nil  // Uncomment if needed for safe areas
    ) -> CGPoint {
        let safeZoom = max(zoomScale, 0.001)  // Prevent div-by-zero; adjust based on your minZoom
        let viewCenter = CGPoint(x: viewSize.width / 2, y: viewSize.height / 2)
        let panOffset = CGPoint(x: offset.width, y: offset.height)
        
        let translated = screenPos - viewCenter - panOffset
        
        // Optional: Adjust for safe areas (e.g., touches missing near edges on watchOS)
        // if let geo = geometry {
        //     translated.x -= geo.safeAreaInsets.leading
        //     translated.y -= geo.safeAreaInsets.top
        // }
        
        let unscaled = translated / safeZoom
        let modelPos = effectiveCentroid + unscaled
        
#if DEBUG
        Self.logger.debug("screenToModel: Screen (\(screenPos.x), \(screenPos.y)) -> Model (\(modelPos.x), \(modelPos.y)), Zoom \(safeZoom), Offset (\(panOffset.x), \(panOffset.y)), Centroid (\(effectiveCentroid.x), \(effectiveCentroid.y)), ViewSize (\(viewSize.width), \(viewSize.height))")
#endif
        
        // Round to 3 decimals to eliminate floating-point drift
        return CGPoint(x: modelPos.x.rounded(to: 3), y: modelPos.y.rounded(to: 3))
    }
}
----------------------------------------------------------------------------------------------------
File: GraphError.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphError.swift
Last modified: 2025-10-13 20:38:24

Contents:
//
//  GraphError.swift
//  GraphEditorShared
//
//  Created by handcart on 10/13/25.
//

import Foundation  // Added for LocalizedError

public enum GraphError: Error, LocalizedError {
    case storageFailure(String)
    case simulationTimeout(Int)
    case invalidState(String)
    case graphNotFound(String)

    public var errorDescription: String? {
        switch self {
        case .storageFailure(let msg): return "Storage error: \(msg)"
        case .simulationTimeout(let steps): return "Simulation timed out after \(steps) steps"
        case .invalidState(let msg): return "Invalid state: \(msg)"
        case .graphNotFound(let name): return "Graph '\(name)' not found"
        }
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel.swift
Last modified: 2025-11-12 09:12:16

Contents:
//
//  GraphModel.swift
//  GraphEditorShared
//
//  Created by handcart on 10/3/25.
//

import os.log
import SwiftUI
import Combine
import Foundation

#if os(watchOS)
import WatchKit
#endif

@available(iOS 16.0, watchOS 6.0, *)
@MainActor public class GraphModel: ObservableObject {
    @Published public var currentGraphName: String = "default"  // Standardized to "default" for consistency
    @Published public var nodes: [AnyNode] = []
    @Published public var edges: [GraphEdge] = []
    @Published public var isSimulating: Bool = false
    @Published public var isStable: Bool = false
    @Published public var simulationError: Error?
    @Published public var mode: GraphMode = .network  // Per-graph mode
    public let changesPublisher = PassthroughSubject<Void, Never>()  // For future real-time sync

    private static let logger = Logger.forCategory("graphmodel-storage")

    var simulationTimer: Timer?
    var undoStack: [UndoGraphState] = []
    var redoStack: [UndoGraphState] = []
    public var maxUndo: Int = 10

    public var nextNodeLabel = 1

    public let storage: GraphStorage
    public var physicsEngine: PhysicsEngine

    public var hiddenNodeIDs: Set<NodeID> {
        // Removed debug print to avoid side effects; add os_log if needed for production logging.
        var hidden = Set<NodeID>()
        var toHide: [NodeID] = []

        for node in nodes where node.unwrapped.shouldHideChildren() {
            let children = edges.filter { $0.from == node.id && $0.type == .hierarchy }.map { $0.target }
            toHide.append(contentsOf: children)
        }

        let adj = buildAdjacencyList(for: .hierarchy)
        while !toHide.isEmpty {
            let current = toHide.removeLast()
            if hidden.insert(current).inserted {
                let children = adj[current] ?? []
                toHide.append(contentsOf: children)
            }
        }

        return hidden
    }

    lazy var simulator: GraphSimulator = {
        GraphSimulator(
            getNodes: { [weak self] in
                await MainActor.run {
                    self?.nodes.map { $0.unwrapped } ?? []
                }
            },
            setNodes: { [weak self] newNodes in
                await MainActor.run {
                    self?.nodes = newNodes.map { AnyNode($0) }
                }
            },
            getEdges: { [weak self] in
                await MainActor.run {
                    self?.edges ?? []
                }
            },
            getVisibleNodes: { [weak self] in
                await MainActor.run {
                    self?.visibleNodes() ?? []
                }
            },
            getVisibleEdges: { [weak self] in
                await MainActor.run {
                    self?.visibleEdges() ?? []
                }
            },
            physicsEngine: self.physicsEngine,
            onStable: { [weak self] in
                Task { @MainActor in
                    guard let self = self, !self.isStable else { return }
                    let velocities = self.nodes.map { hypot($0.velocity.x, $0.velocity.y) }
                    if velocities.allSatisfy({ $0 < 0.001 }) {
                        // CHANGED: Qualified static logger
                        Self.logger.infoLog("Simulation stable: Centering nodes")  // Replaced print
                        let centeredNodes = self.physicsEngine.centerNodes(nodes: self.nodes.map { $0.unwrapped })
                        self.nodes = centeredNodes.map { AnyNode($0.with(position: $0.position, velocity: .zero)) }
                        self.isStable = true
                        Task.detached {
                            await self.stopSimulation()
                            try? await Task.sleep(nanoseconds: 500_000_000)
                            await MainActor.run {
                                self.isStable = false
                            }
                        }
                        self.objectWillChange.send()
                    }
                }
            },
            onPostStable: { [weak self] in
                Task { @MainActor in
                    self?.isSimulating = false
                    Self.logger.infoLog("Auto-paused simulation after inactivity")
                }
            }
        )
    }()
    
    public var canUndo: Bool {
        !undoStack.isEmpty
    }

    public var canRedo: Bool {
        !redoStack.isEmpty
    }

    public init(storage: GraphStorage, physicsEngine: PhysicsEngine) {
        self.storage = storage
        self.physicsEngine = physicsEngine
        // CHANGED: Qualified static logger
        Self.logger.infoLog("GraphModel initialized with storage: \(type(of: storage))")  // Existing, already good
    }
    
    func buildAdjacencyList(for type: EdgeType) -> [NodeID: [NodeID]] {
        var adj: [NodeID: [NodeID]] = [:]
        for edge in edges where edge.type == type {
            adj[edge.from, default: []].append(edge.target)
        }
        return adj
    }
}
--------------------------------------------------
