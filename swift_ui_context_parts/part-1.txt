## Focused Project Concatenation
This file includes only UI, interactivity, model, and core logic files.
Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
Current date: 2025-10-22 10:21:08
Table of Contents:
1. GraphEditorShared/Sources/GraphEditorShared/AttractionCalculator.swift
2. GraphEditorShared/Sources/GraphEditorShared/CenteringCalculator.swift
3. GraphEditorShared/Sources/GraphEditorShared/Constants.swift
4. GraphEditorShared/Sources/GraphEditorShared/CoordinateTransformer.swift
5. GraphEditorShared/Sources/GraphEditorShared/GraphError.swift
6. GraphEditorShared/Sources/GraphEditorShared/GraphModel.swift
7. GraphEditorShared/Sources/GraphEditorShared/GraphModel+EdgesNodes.swift
8. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Helpers.swift
9. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Simulation.swift
10. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Storage.swift
11. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Undo.swift--------------------------------------------------
File: AttractionCalculator.swift
Path: GraphEditorShared/Sources/GraphEditorShared/AttractionCalculator.swift
Last modified: 2025-09-19 13:45:29

Contents:
//
//  AttractionCalculator.swift
//  GraphEditorShared
//
//  Created by handcart on 8/12/25.
//

import Foundation  // For hypot, CGFloat, etc.
import CoreGraphics  // For CGPoint, CGVector (used internally)

@available(iOS 16.0, watchOS 9.0, *)
struct AttractionCalculator {
    let symmetricFactor: CGFloat
    let useAsymmetric: Bool  // New: Controls full asymmetry for hierarchy edges

    init(symmetricFactor: CGFloat, useAsymmetric: Bool = false) {  // Default false to preserve existing behavior
        self.symmetricFactor = symmetricFactor
        self.useAsymmetric = useAsymmetric
    }

    func applyAttractions(forces: [NodeID: CGPoint], edges: [GraphEdge], nodes: [any NodeProtocol]) -> [NodeID: CGPoint] {
        var updatedForces = forces
        for edge in edges {
            guard let fromNode = nodes.first(where: { $0.id == edge.from }),
                  let toNode = nodes.first(where: { $0.id == edge.target }) else { continue }
            let deltaX = toNode.position.x - fromNode.position.x
            let deltaY = toNode.position.y - fromNode.position.y
            let dist = max(hypot(deltaX, deltaY), Constants.Physics.distanceEpsilon)
            let forceMagnitude = Constants.Physics.stiffness * (dist - Constants.Physics.idealLength)
            let forceDirectionX = deltaX / dist
            let forceDirectionY = deltaY / dist
            let forceX = forceDirectionX * forceMagnitude
            let forceY = forceDirectionY * forceMagnitude
            
            let symForceX = forceX * self.symmetricFactor
            let symForceY = forceY * self.symmetricFactor
            
            let currentForceFrom = updatedForces[fromNode.id] ?? CGPoint.zero
            let currentForceTo = updatedForces[toNode.id] ?? CGPoint.zero
            
            let isHierarchy = edge.type == .hierarchy
            if isHierarchy && self.useAsymmetric {
                // Full asymmetric: Strong pull 'to' toward 'from'; minimal back-pull on 'from' (test-friendly)
                let asymmetricFactor: CGFloat = 2.0  // Stronger pull for 'to'; tune if needed
                let toForceX = -forceX * asymmetricFactor  // Pull 'to' left/up toward 'from'
                let toForceY = -forceY * asymmetricFactor
                let fromBackPullX = forceX * 0.1  // Minimal back-pull (10% to keep stable)
                let fromBackPullY = forceY * 0.1
                
                updatedForces[toNode.id] = CGPoint(x: currentForceTo.x + toForceX, y: currentForceTo.y + toForceY)
                updatedForces[fromNode.id] = CGPoint(x: currentForceFrom.x + fromBackPullX, y: currentForceFrom.y + fromBackPullY)
            } else if isHierarchy {
                // Symmetric for stability (net force zero)
                updatedForces[toNode.id] = CGPoint(x: currentForceTo.x - forceX + symForceX, y: currentForceTo.y - forceY + symForceY)
                updatedForces[fromNode.id] = CGPoint(x: currentForceFrom.x + symForceX, y: currentForceFrom.y + symForceY)
            } else {
                // Symmetric for .association (unchanged)
                updatedForces[toNode.id] = CGPoint(x: currentForceTo.x - forceX + symForceX, y: currentForceTo.y - forceY + symForceY)
                updatedForces[fromNode.id] = CGPoint(x: currentForceFrom.x + symForceX, y: currentForceFrom.y + symForceY)
            }
        }
        return updatedForces
    }
}
----------------------------------------------------------------------------------------------------
File: CenteringCalculator.swift
Path: GraphEditorShared/Sources/GraphEditorShared/CenteringCalculator.swift
Last modified: 2025-09-19 13:45:29

Contents:
//
//  CenteringCalculator.swift
//  GraphEditorShared
//
//  Created by handcart on 8/12/25.
//

import Foundation
import CoreGraphics

struct CenteringCalculator {
    let simulationBounds: CGSize

    @available(iOS 16.0, *)
    func applyCentering(forces: [NodeID: CGPoint], nodes: [any NodeProtocol]) -> [NodeID: CGPoint] {
        var updatedForces = forces
        let center = CGPoint(x: simulationBounds.width / 2, y: simulationBounds.height / 2)
        for node in nodes {
            let deltaX = center.x - node.position.x
            let deltaY = center.y - node.position.y
            let distToCenter = hypot(deltaX, deltaY)
            let forceX = deltaX * Constants.Physics.centeringForce * (1 + distToCenter / max(simulationBounds.width, simulationBounds.height))
            let forceY = deltaY * Constants.Physics.centeringForce * (1 + distToCenter / max(simulationBounds.width, simulationBounds.height))
            let currentForce = updatedForces[node.id] ?? .zero
            updatedForces[node.id] = CGPoint(x: currentForce.x + forceX, y: currentForce.y + forceY)
        }
        return updatedForces
    }
}
----------------------------------------------------------------------------------------------------
File: Constants.swift
Path: GraphEditorShared/Sources/GraphEditorShared/Constants.swift
Last modified: 2025-10-08 13:12:23

Contents:
//
//  Constants.swift
//  GraphEditorShared
//
//  Created by handcart on 8/6/25.
//
// Sources/GraphEditorShared/Constants.swift

import CoreGraphics

public enum Constants {
    public enum Physics {
        public static let stiffness: CGFloat = 0.4  // Reduced from 0.8 for softer springs
        public static let repulsion: CGFloat = 1200  // Reduced from 2200 for less aggressive push
        public static let damping: CGFloat = 0.94  // Updated from 0.9 for better convergence with alpha
        public static let idealLength: CGFloat = 80  // Slightly increased for more space
        public static let centeringForce: CGFloat = 0.1  // Increased from 0.03 for better centering
        public static let distanceEpsilon: CGFloat = 1e-3
        public static let timeStep: CGFloat = 0.05  // Updated to match PositionUpdater; tune if needed
        public static let velocityThreshold: CGFloat = 0.3  // Increased from 0.2 for earlier stop
        public static let maxSimulationSteps = 500  // Further reduced from 1000 for quick convergence
        public static let minQuadSize: CGFloat = 1e-6
        public static let maxQuadtreeDepth = 20
        public static let maxNodesForQuadtree = 200
        public static let minCollisionDist: CGFloat = 35.0  // New: For anti-collision separation
        public static let verticalBias: CGFloat = 0.0  // New: Downward bias for hierarchy edges (tune as needed)
        public static let alphaDecay: CGFloat = 0.0228  // New: For cooling schedule
    }
    
    public enum App {
        public static let nodeModelRadius: CGFloat = 10.0
        public static let hitScreenRadius: CGFloat = 40.0  // Larger for watchOS tap targets
        public static let tapThreshold: CGFloat = 20.0  // Tightened from 10.0 for small screens
        public static let numZoomLevels: Int = 20  // For crown mapping
        public static let contentPadding: CGFloat = 50.0  // Padding for graph bounds
        public static let maxZoom: CGFloat = 8.0  // Maximum zoom level
    }
    
    // Add more enums as needed (e.g., UI, Testing)
}
----------------------------------------------------------------------------------------------------
File: CoordinateTransformer.swift
Path: GraphEditorShared/Sources/GraphEditorShared/CoordinateTransformer.swift
Last modified: 2025-10-14 09:11:42

Contents:
//
//  CoordinateTransformer.swift
//  GraphEditorShared
//
//  Created by handcart on 9/26/25.
//

import CoreGraphics
import SwiftUI  // For GeometryProxy if enabled
import os

/// Utility for converting between model (graph) coordinates and screen (view) coordinates.
public struct CoordinateTransformer {
    private static let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "coordinatetransformer")
    
    /// Converts a model position to screen coordinates.
    /// - Parameters:
    ///   - modelPos: The position in model space.
    ///   - effectiveCentroid: The centroid of the graph for centering.
    ///   - zoomScale: Current zoom level.
    ///   - offset: Pan offset.
    ///   - viewSize: Size of the view.
    ///   - geometry: Optional GeometryProxy for safe area adjustments (e.g., on watchOS).
    /// - Returns: Screen position.
    public static func modelToScreen(
        _ modelPos: CGPoint,
        effectiveCentroid: CGPoint,
        zoomScale: CGFloat,
        offset: CGSize,
        viewSize: CGSize
        // geometry: GeometryProxy? = nil  // Uncomment if needed for safe areas
    ) -> CGPoint {
        let viewCenter = CGPoint(x: viewSize.width / 2, y: viewSize.height / 2)
        let relativePos = modelPos - effectiveCentroid
        let scaledPos = relativePos * zoomScale
        let screenPos = viewCenter + scaledPos + CGPoint(x: offset.width, y: offset.height)
        
        // Optional: Adjust for safe areas (symmetric to screenToModel)
        // if let geo = geometry {
        //     screenPos.x += geo.safeAreaInsets.leading
        //     screenPos.y += geo.safeAreaInsets.top
        // }
        
#if DEBUG
        Self.logger.debug("modelToScreen: Model (\(modelPos.x), \(modelPos.y)) -> Screen (\(screenPos.x), \(screenPos.y)), Zoom \(zoomScale), Offset (\(offset.width), \(offset.height)), Centroid (\(effectiveCentroid.x), \(effectiveCentroid.y)), ViewSize (\(viewSize.width), \(viewSize.height))")
#endif
        
        return screenPos
    }
    
    /// Converts a screen position back to model coordinates.
    /// - Parameters:
    ///   - screenPos: The position in screen space.
    ///   - effectiveCentroid: The centroid of the graph for centering.
    ///   - zoomScale: Current zoom level.
    ///   - offset: Pan offset.
    ///   - viewSize: Size of the view.
    ///   - geometry: Optional GeometryProxy for safe area adjustments (e.g., on watchOS).
    /// - Returns: Model position (rounded to 3 decimals to reduce floating-point drift).
    public static func screenToModel(
        _ screenPos: CGPoint,
        effectiveCentroid: CGPoint,
        zoomScale: CGFloat,
        offset: CGSize,
        viewSize: CGSize
        // geometry: GeometryProxy? = nil  // Uncomment if needed for safe areas
    ) -> CGPoint {
        let safeZoom = max(zoomScale, 0.001)  // Prevent div-by-zero; adjust based on your minZoom
        let viewCenter = CGPoint(x: viewSize.width / 2, y: viewSize.height / 2)
        let panOffset = CGPoint(x: offset.width, y: offset.height)
        
        let translated = screenPos - viewCenter - panOffset
        
        // Optional: Adjust for safe areas (e.g., touches missing near edges on watchOS)
        // if let geo = geometry {
        //     translated.x -= geo.safeAreaInsets.leading
        //     translated.y -= geo.safeAreaInsets.top
        // }
        
        let unscaled = translated / safeZoom
        let modelPos = effectiveCentroid + unscaled
        
#if DEBUG
        Self.logger.debug("screenToModel: Screen (\(screenPos.x), \(screenPos.y)) -> Model (\(modelPos.x), \(modelPos.y)), Zoom \(safeZoom), Offset (\(panOffset.x), \(panOffset.y)), Centroid (\(effectiveCentroid.x), \(effectiveCentroid.y)), ViewSize (\(viewSize.width), \(viewSize.height))")
#endif
        
        // Round to 3 decimals to eliminate floating-point drift
        return CGPoint(x: modelPos.x.rounded(to: 3), y: modelPos.y.rounded(to: 3))
    }
}
----------------------------------------------------------------------------------------------------
File: GraphError.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphError.swift
Last modified: 2025-10-13 20:38:24

Contents:
//
//  GraphError.swift
//  GraphEditorShared
//
//  Created by handcart on 10/13/25.
//

import Foundation  // Added for LocalizedError

public enum GraphError: Error, LocalizedError {
    case storageFailure(String)
    case simulationTimeout(Int)
    case invalidState(String)
    case graphNotFound(String)

    public var errorDescription: String? {
        switch self {
        case .storageFailure(let msg): return "Storage error: \(msg)"
        case .simulationTimeout(let steps): return "Simulation timed out after \(steps) steps"
        case .invalidState(let msg): return "Invalid state: \(msg)"
        case .graphNotFound(let name): return "Graph '\(name)' not found"
        }
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel.swift
Last modified: 2025-10-14 09:19:26

Contents:
//
//  GraphModel.swift
//  GraphEditorShared
//
//  Created by handcart on 10/3/25.
//

import os.log
import SwiftUI
import Combine
import Foundation

#if os(watchOS)
import WatchKit
#endif

@available(iOS 16.0, watchOS 6.0, *)
@MainActor public class GraphModel: ObservableObject {
    @Published public var currentGraphName: String = "default"  // Standardized to "default" for consistency
    @Published public var nodes: [AnyNode] = []
    @Published public var edges: [GraphEdge] = []
    @Published public var isSimulating: Bool = false
    @Published public var isStable: Bool = false
    @Published public var simulationError: Error?

    // CHANGED: Made static for consistency; use Self.logger
    private static let logger = Logger.forCategory("graphmodel-storage")

    var simulationTimer: Timer?
    var undoStack: [UndoGraphState] = []
    var redoStack: [UndoGraphState] = []
    public var maxUndo: Int = 10

    public var nextNodeLabel = 1

    public let storage: GraphStorage
    public var physicsEngine: PhysicsEngine

    public var hiddenNodeIDs: Set<NodeID> {
        // Removed debug print to avoid side effects; add os_log if needed for production logging.
        var hidden = Set<NodeID>()
        var toHide: [NodeID] = []

        for node in nodes where node.unwrapped.shouldHideChildren() {
            let children = edges.filter { $0.from == node.id && $0.type == .hierarchy }.map { $0.target }
            toHide.append(contentsOf: children)
        }

        let adj = buildAdjacencyList(for: .hierarchy)
        while !toHide.isEmpty {
            let current = toHide.removeLast()
            if hidden.insert(current).inserted {
                let children = adj[current] ?? []
                toHide.append(contentsOf: children)
            }
        }

        return hidden
    }

    lazy var simulator: GraphSimulator = {
        GraphSimulator(
            getNodes: { [weak self] in
                await MainActor.run {
                    self?.nodes.map { $0.unwrapped } ?? []
                }
            },
            setNodes: { [weak self] newNodes in
                await MainActor.run {
                    self?.nodes = newNodes.map { AnyNode($0) }
                }
            },
            getEdges: { [weak self] in
                await MainActor.run {
                    self?.edges ?? []
                }
            },
            getVisibleNodes: { [weak self] in
                await MainActor.run {
                    self?.visibleNodes() ?? []
                }
            },
            getVisibleEdges: { [weak self] in
                await MainActor.run {
                    self?.visibleEdges() ?? []
                }
            },
            physicsEngine: self.physicsEngine,
            onStable: { [weak self] in
                guard let self = self, !self.isStable else { return }
                let velocities = self.nodes.map { hypot($0.velocity.x, $0.velocity.y) }
                if velocities.allSatisfy({ $0 < 0.001 }) {
                    // CHANGED: Qualified static logger
                    Self.logger.infoLog("Simulation stable: Centering nodes")  // Replaced print
                    let centeredNodes = self.physicsEngine.centerNodes(nodes: self.nodes.map { $0.unwrapped })
                    self.nodes = centeredNodes.map { AnyNode($0.with(position: $0.position, velocity: .zero)) }
                    self.isStable = true
                    Task.detached {
                        await self.stopSimulation()
                        try? await Task.sleep(nanoseconds: 500_000_000)
                        await MainActor.run {
                            self.isStable = false
                        }
                    }
                    self.objectWillChange.send()
                }
            }
        )
    }()
    
    public var canUndo: Bool {
        !undoStack.isEmpty
    }

    public var canRedo: Bool {
        !redoStack.isEmpty
    }

    public init(storage: GraphStorage, physicsEngine: PhysicsEngine) {
        self.storage = storage
        self.physicsEngine = physicsEngine
        // CHANGED: Qualified static logger
        Self.logger.infoLog("GraphModel initialized with storage: \(type(of: storage))")  // Existing, already good
    }
    
    func buildAdjacencyList(for type: EdgeType) -> [NodeID: [NodeID]] {
        var adj: [NodeID: [NodeID]] = [:]
        for edge in edges where edge.type == type {
            adj[edge.from, default: []].append(edge.target)
        }
        return adj
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+EdgesNodes.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+EdgesNodes.swift
Last modified: 2025-10-20 15:32:34

Contents:
//
//  GraphModel+EdgesNodes.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation
import os  // ADDED: For Logger

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    // NEW: Add static logger for this extension
    private static let logger = Logger.forCategory("graphmodel_edgesnodes")

    public func wouldCreateCycle(withNewEdgeFrom from: NodeID, target: NodeID, type: EdgeType) -> Bool {
        guard type == .hierarchy else { return false }
        var tempEdges = edges.filter { $0.type == .hierarchy }
        tempEdges.append(GraphEdge(from: from, target: target, type: type))
        return !isAcyclic(edges: tempEdges)
    }

    private func isAcyclic(edges: [GraphEdge]) -> Bool {
        var adj: [NodeID: [NodeID]] = [:]
        var inDegree: [NodeID: Int] = [:]
        nodes.forEach { inDegree[$0.id] = 0 }
        for edge in edges {
            adj[edge.from, default: []].append(edge.target)
            inDegree[edge.target, default: 0] += 1
        }
        var queue = nodes.filter { inDegree[$0.id] == 0 }.map { $0.id }
        var count = 0
        while !queue.isEmpty {
            let node = queue.removeFirst()
            count += 1
            for neighbor in adj[node] ?? [] {
                inDegree[neighbor]! -= 1
                if inDegree[neighbor]! == 0 { queue.append(neighbor) }
            }
        }
        return count == nodes.count
    }

    public func addEdge(from: NodeID, target: NodeID, type: EdgeType) async {
        if wouldCreateCycle(withNewEdgeFrom: from, target: target, type: type) {
            // CHANGED: Qualified static logger
            Self.logger.warning("Cannot add edge: Would create cycle in hierarchy")  // Replaced print with warning log
            return
        }
        pushUndo()
        edges.append(GraphEdge(from: from, target: target, type: type))
        objectWillChange.send()
        await resumeSimulation()
    }

    public func deleteEdge(withID id: UUID) async {
        // CHANGED: Qualified
        Self.logger.debugLog("Deleting edge with ID: \(id.uuidString.prefix(8))")  // Added debug log
        pushUndo()
        edges.removeAll { $0.id == id }
        objectWillChange.send()
        await resumeSimulation()
    }

    public func addNode(at position: CGPoint) async {
        // CHANGED: Qualified; manual CGPoint formatting
        Self.logger.debugLog("Adding node at position: x=\(position.x), y=\(position.y)")  // Added debug log
        pushUndo()
        let newLabel = nextNodeLabel
        nextNodeLabel += 1
        let newNode = AnyNode(Node(label: newLabel, position: position))
        nodes.append(newNode)
        objectWillChange.send()
        await resumeSimulation()
    }

    public func addToggleNode(at position: CGPoint) async {
        Self.logger.debugLog("Adding toggle node at position: x=\(position.x), y=\(position.y)")  // Added debug log
        pushUndo()
        let newLabel = nextNodeLabel
        nextNodeLabel += 1
        let newNode = AnyNode(ToggleNode(label: newLabel, position: position))
        nodes.append(newNode)
        objectWillChange.send()
        await resumeSimulation()
    }

    public func addChild(to parentID: NodeID) async {
        Self.logger.debugLog("Adding child to parent ID: \(parentID.uuidString.prefix(8))")  // Added debug log
        pushUndo()
        let newLabel = nextNodeLabel
        nextNodeLabel += 1
        guard let parentIndex = nodes.firstIndex(where: { $0.id == parentID }) else { return }
        let parentPosition = nodes[parentIndex].position
        let offsetX = CGFloat.random(in: -50...50)
        let offsetY = CGFloat.random(in: -50...50)
        let newPosition = parentPosition + CGPoint(x: offsetX, y: offsetY)
        let newNode = AnyNode(Node(label: newLabel, position: newPosition))
        nodes.append(newNode)
        edges.append(GraphEdge(from: parentID, target: newNode.id, type: .hierarchy))
        objectWillChange.send()
        await resumeSimulation()
    }

    public func deleteNode(withID id: NodeID) async {
        // CHANGED: Qualified
        Self.logger.debugLog("Deleting node with ID: \(id.uuidString.prefix(8))")  // Added debug log
        pushUndo()
        nodes.removeAll { $0.id == id }
        edges.removeAll { $0.from == id || $0.target == id }
        objectWillChange.send()
        await resumeSimulation()
    }

    public func updateNodeContents(withID id: NodeID, newContents: [NodeContent]) async {
        // CHANGED: Qualified
        Self.logger.debugLog("Updating contents for node ID: \(id.uuidString.prefix(8))")  // Added debug log
        pushUndo()
        if let index = nodes.firstIndex(where: { $0.id == id }) {
            var updated = nodes[index].unwrapped
            updated.contents = newContents
            nodes[index] = AnyNode(updated)
            objectWillChange.send()
            await resumeSimulation()
        }
    }

    public func deleteSelected(selectedNodeID: NodeID?, selectedEdgeID: UUID?) async {
        // CHANGED: Qualified
        Self.logger.debugLog("Deleting selected: node=\(selectedNodeID?.uuidString.prefix(8) ?? "nil"), edge=\(selectedEdgeID?.uuidString.prefix(8) ?? "nil")")  // Added debug log
        pushUndo()
        if let id = selectedEdgeID {
            edges.removeAll { $0.id == id }
        } else if let id = selectedNodeID {
            nodes.removeAll { $0.id == id }
            edges.removeAll { $0.from == id || $0.target == id }
        }
        objectWillChange.send()
        await resumeSimulation()
    }

    public func toggleExpansion(for nodeID: NodeID) async {
        // CHANGED: Qualified
        Self.logger.debugLog("Toggling expansion for node ID: \(nodeID.uuidString.prefix(8))")  // Added debug log
        pushUndo()
        guard let idx = nodes.firstIndex(where: { $0.id == nodeID }), let toggle = nodes[idx].unwrapped as? ToggleNode else { return }
        let updated = toggle.handlingTap()
        nodes[idx] = AnyNode(updated)
        objectWillChange.send()
        await resumeSimulation()
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+Helpers.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Helpers.swift
Last modified: 2025-10-16 15:42:12

Contents:
//
//  GraphModel+Helpers.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    func buildAdjacencyList(for edgeType: EdgeType? = nil) -> [NodeID: [NodeID]] { 
        var adj = [NodeID: [NodeID]]()
        let filteredEdges = edgeType != nil ? edges.filter { $0.type == edgeType! } : edges
        for edge in filteredEdges {
            adj[edge.from, default: []].append(edge.target)
        }
        return adj
    }

    private func dfsVisible(node: any NodeProtocol, adjacency: [NodeID: [NodeID]], visited: inout Set<NodeID>, visible: inout [any NodeProtocol]) {
        visited.insert(node.id)
        visible.append(node)
        if !node.isExpanded { return }
        if let children = adjacency[node.id] {
            for childID in children {
                if !visited.contains(childID), let child = nodes.first(where: { $0.id == childID })?.unwrapped {
                    dfsVisible(node: child, adjacency: adjacency, visited: &visited, visible: &visible)
                }
            }
        }
    }

    public func isBidirectionalBetween(_ id1: NodeID, _ id2: NodeID) -> Bool {
        edges.contains(where: { $0.from == id1 && $0.target == id2 }) &&
        edges.contains(where: { $0.from == id2 && $0.target == id1 })
    }

    public func edgesBetween(_ id1: NodeID, _ id2: NodeID) -> [GraphEdge] {
        edges.filter { ($0.from == id1 && $0.target == id2) || ($0.from == id2 && $0.target == id1) }
    }

    public func handleTap(on nodeID: NodeID) async {
            guard let index = nodes.firstIndex(where: { $0.id == nodeID }) else { return }
            let oldNode = nodes[index]
            let updatedNode = oldNode.handlingTap()
            nodes[index] = updatedNode

            let children = edges.filter { $0.from == nodeID && $0.type == EdgeType.hierarchy }.map { $0.target } // Changed to EdgeType.hierarchy
        
        if let toggleNode = updatedNode.unwrapped as? ToggleNode {
            if toggleNode.isExpanded {
                for childID in children {
                    guard let childIndex = nodes.firstIndex(where: { $0.id == childID }) else { continue }
                    var child = nodes[childIndex]
                    let offsetX = CGFloat.random(in: -Constants.App.nodeModelRadius * 3 ... Constants.App.nodeModelRadius * 3)
                    let offsetY = CGFloat.random(in: Constants.App.nodeModelRadius * 2 ... Constants.App.nodeModelRadius * 4)
                    child.position = toggleNode.position + CGPoint(x: offsetX, y: offsetY)
                    child.velocity = .zero
                    nodes[childIndex] = child
                }
                physicsEngine.temporaryDampingBoost(steps: Constants.Physics.maxSimulationSteps / 10)
            } else {
                for childID in children {
                    guard let childIndex = nodes.firstIndex(where: { $0.id == childID }) else { continue }
                    var child = nodes[childIndex]
                    child.position = toggleNode.position
                    child.velocity = .zero
                    nodes[childIndex] = child
                }
            }
        }

        objectWillChange.send()
        let unwrappedNodes = nodes.map { $0.unwrapped }
        let updatedUnwrapped = physicsEngine.runSimulation(steps: 20, nodes: unwrappedNodes, edges: edges)
        nodes = updatedUnwrapped.map { AnyNode($0) }
        await resumeSimulation()
    }

    public func graphDescription(selectedID: NodeID?, selectedEdgeID: UUID?) -> String {
        let edgeCount = edges.count
        let edgeWord = edgeCount == 1 ? "edge" : "edges"
        var desc = "Graph with \(nodes.count) nodes and \(edgeCount) directed \(edgeWord)."
        if let selectedEdgeID = selectedEdgeID, let selectedEdge = edges.first(where: { $0.id == selectedEdgeID }),
           let fromNode = nodes.first(where: { $0.id == selectedEdge.from })?.unwrapped,
           let toNode = nodes.first(where: { $0.id == selectedEdge.target })?.unwrapped {
            desc += " Directed edge from node \(fromNode.label) to node \(toNode.label) selected."
        } else if let selectedID = selectedID, let selectedNode = nodes.first(where: { $0.id == selectedID })?.unwrapped {
            let outgoingLabels = edges
                .filter { $0.from == selectedID }
                .compactMap { edge in
                    let targetID = edge.target
                    return nodes.first { $0.id == targetID }?.unwrapped.label
                }
                .sorted()
                .map { String($0) }
                .joined(separator: ", ")
            let incomingLabels = edges
                .filter { $0.target == selectedID }
                .compactMap { edge in
                    let fromID = edge.from
                    return nodes.first { $0.id == fromID }?.unwrapped.label
                }
                .sorted()
                .map { String($0) }
                .joined(separator: ", ")
            let outgoingText = outgoingLabels.isEmpty ? "none" : outgoingLabels
            let incomingText = incomingLabels.isEmpty ? "none" : incomingLabels
            desc += " Node \(selectedNode.label) selected, outgoing to: \(outgoingText); incoming from: \(incomingText)."
        } else {
            desc += " No node or edge selected."
        }
        return desc
    }
    
    public var centroid: CGPoint? {
        GraphEditorShared.centroid(of: visibleNodes())
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+Simulation.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Simulation.swift
Last modified: 2025-10-14 10:01:11

Contents:
//
//  GraphModel+Simulation.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation
import os  // ADDED: For Logger

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    private static let logger = Logger.forCategory("graphmodel-simulation")  // ADDED: Local static logger for this extension

    public func startSimulation() async {
        Self.logger.infoLog("Starting simulation")  // Qualified with Self
        isSimulating = true
        isStable = false
        await simulator.startSimulation()
    }

    public func pauseSimulation() async {
        Self.logger.debugLog("Pausing simulation")  // Qualified with Self
        physicsEngine.isPaused = true
    }

    public func resumeSimulation() async {
        Self.logger.debugLog("Resuming simulation")  // Qualified with Self
        physicsEngine.isPaused = false
        if simulator.simulationTask == nil {
            await startSimulation()
        }
    }

    public func stopSimulation() async {
        Self.logger.infoLog("Stopping simulation")  // Qualified with Self
        await simulator.stopSimulation()
        isSimulating = false
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+Storage.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Storage.swift
Last modified: 2025-10-15 09:59:29

Contents:
//
//  GraphModel+Storage.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation
import CoreGraphics
import os  // Added for Logger

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    private static let logger = Logger.forCategory("graphmodel-storage")  // ADDED: Define local static logger for this extension

    private func syncCollapsedPositions() {
        for parentIndex in 0..<nodes.count {
            if let toggle = nodes[parentIndex].unwrapped as? ToggleNode, !toggle.isExpanded {
                let children = edges.filter { $0.from == nodes[parentIndex].id && $0.type == .hierarchy }.map { $0.target }
                for (index, childID) in children.enumerated() {
                    guard let childIndex = nodes.firstIndex(where: { $0.id == childID }) else { continue }
                    var child = nodes[childIndex]
                    let angle = CGFloat(index) * (2 * .pi / CGFloat(children.count))
                    let jitterX = cos(angle) * 5.0
                    let jitterY = sin(angle) * 5.0
                    child.position = nodes[parentIndex].position + CGPoint(x: jitterX, y: jitterY)
                    child.velocity = .zero
                    nodes[childIndex] = child
                }
            }
        }
        objectWillChange.send()
    }

    private func loadFromStorage(for name: String) async throws {
        Self.logger.infoLog("loadFromStorage started for \(name)")
        do {
            let (loadedNodes, loadedEdges) = try await storage.load(for: name)
            Self.logger.infoLog("loadFromStorage: loaded \(loadedNodes.count) nodes, \(loadedEdges.count) edges for \(name)")
            self.nodes = loadedNodes.map { AnyNode($0) }
            self.edges = loadedEdges
            self.nextNodeLabel = (nodes.map { $0.unwrapped.label }.max() ?? 0) + 1
        } catch {
            Self.logger.errorLog("loadFromStorage failed for \(name)", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation with custom error
        }
    }
    
    public func load() async {
        Self.logger.infoLog("GraphModel.load() called")
        do {
            try await loadFromStorage(for: currentGraphName)
            syncCollapsedPositions()
            if let viewState = try storage.loadViewState(for: currentGraphName) {
                Self.logger.infoLog("Loaded view state: offset \(viewState.offset), zoom \(viewState.zoomScale)")
            }
            Self.logger.infoLog("GraphModel.load() succeeded; nodes: \(nodes.count), edges: \(edges.count)")
        } catch {
            Self.logger.errorLog("GraphModel.load() failed: \(error.localizedDescription)", error: error)
        }
    }
    
    public func save() async throws {
        Self.logger.infoLog("GraphModel.save() called; nodes: \(nodes.count), edges: \(edges.count)")
        do {
            try await storage.save(nodes: nodes.map { $0.unwrapped }, edges: edges, for: currentGraphName)
            Self.logger.infoLog("GraphModel.save() succeeded")
        } catch {
            Self.logger.errorLog("GraphModel.save() failed: \(error.localizedDescription)", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation
        }
    }

    public func clearGraph() async {
        Self.logger.infoLog("clearGraph called")
        nodes = []
        edges = []
        nextNodeLabel = 1
        do {
            try await storage.deleteGraph(name: currentGraphName)
            Self.logger.infoLog("clearGraph succeeded")
        } catch {
            Self.logger.errorLog("clearGraph failed: \(error.localizedDescription)", error: error)
        }
        objectWillChange.send()
    }
    
    // Multi-graph methods (integrated into Storage extension)
    /// Loads the current graph (based on currentGraphName); defaults to empty if not found.
    public func loadGraph() async {
        do {
            try await loadFromStorage(for: currentGraphName)
            nextNodeLabel = (nodes.map { $0.label }.max() ?? 0) + 1
            Self.logger.infoLog("Loaded graph '\(self.currentGraphName)' with \(self.nodes.count) nodes and \(self.edges.count) edges")
            objectWillChange.send()
        } catch GraphStorageError.graphNotFound(_) {
            nodes = []
            edges = []
            nextNodeLabel = 1
            Self.logger.warning("Graph '\(self.currentGraphName)' not found; starting empty")
        } catch {
            nodes = []
            edges = []
            nextNodeLabel = 1
            Self.logger.errorLog("Failed to load graph '\(self.currentGraphName)'", error: error)
        }
    }
    
    /// Saves the current graph state under currentGraphName.
    public func saveGraph() async throws {
        do {
            try await save()
            Self.logger.infoLog("Saved graph '\(self.currentGraphName)'")
        } catch {
            Self.logger.errorLog("Failed to save graph '\(self.currentGraphName)'", error: error)
            throw GraphError.storageFailure(error.localizedDescription)
        }
    }
    
    /// Creates a new empty graph with the given name and switches to it.
    public func createNewGraph(name: String) async throws {
        do {
            try await storage.createNewGraph(name: name)
            currentGraphName = name
            nodes = []
            edges = []
            nextNodeLabel = 1
            undoStack = []
            redoStack = []
            objectWillChange.send()
            Self.logger.infoLog("Created and switched to new graph '\(name)'")
        } catch {
            Self.logger.errorLog("Failed to create graph '\(name)'", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation
        }
    }
    
    /// Loads a specific graph by name and switches to it.
    public func loadGraph(name: String) async {
        currentGraphName = name
        await loadGraph()
    }
    
    /// Deletes the graph with the given name (if not current, no change to model).
    public func deleteGraph(name: String) async throws {
        do {
            try await storage.deleteGraph(name: name)
            if name == currentGraphName {
                currentGraphName = "default"
                await loadGraph()
            }
            Self.logger.infoLog("Deleted graph '\(name)'")
        } catch {
            Self.logger.errorLog("Failed to delete graph '\(name)'", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation
        }
    }
    
    /// Lists all available graph names.
    public func listGraphNames() async throws -> [String] {
        do {
            return try await storage.listGraphNames()
        } catch {
            Self.logger.errorLog("Failed to list graph names", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation
        }
    }
    
    public func saveViewState(offset: CGPoint, zoomScale: CGFloat, selectedNodeID: UUID?, selectedEdgeID: UUID?) async throws {
        let viewState = ViewState(offset: offset, zoomScale: zoomScale, selectedNodeID: selectedNodeID, selectedEdgeID: selectedEdgeID)
        do {
            try storage.saveViewState(viewState, for: currentGraphName)
        } catch {
            Self.logger.errorLog("Failed to save view state for '\(currentGraphName)'", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation
        }
    }

    public func loadViewState() async throws -> ViewState? {
        do {
            return try storage.loadViewState(for: currentGraphName)
        } catch {
            Self.logger.errorLog("Failed to load view state for '\(currentGraphName)'", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation
        }
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+Undo.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Undo.swift
Last modified: 2025-10-14 09:27:58

Contents:
//
//  GraphModel+Undo.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation
import os

struct UndoGraphState {
    let nodes: [AnyNode]
    let edges: [GraphEdge]
    let nextLabel: Int
}

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    private static let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "graphmodel_undo")
    
    internal func pushUndo() {
        undoStack.append(currentState())
        if undoStack.count > maxUndo { undoStack.removeFirst() }
        redoStack = []
    }
    
    private func currentState() -> UndoGraphState {
        UndoGraphState(nodes: nodes, edges: edges, nextLabel: nextNodeLabel)
    }
    
    public func undo(resume: Bool = true) async {
        if let state = undoStack.popLast() {
            redoStack.append(currentState())
            nodes = state.nodes
            edges = state.edges
            nextNodeLabel = state.nextLabel
            objectWillChange.send()
            if resume {
                await resumeSimulation()
            }
        }
    }
    
    public func redo(resume: Bool = true) async {
        if let state = redoStack.popLast() {
            undoStack.append(currentState())
            nodes = state.nodes
            edges = state.edges
            nextNodeLabel = state.nextLabel
            objectWillChange.send()
            if resume {
                await resumeSimulation()
            }
        }
    }
    
    public func snapshot() async {
        Self.logger.debug("snapshot() called from: \(#function), nodes: \(self.nodes.count), edges: \(self.edges.count)")  // Use debug for transient info
        let state = UndoGraphState(nodes: nodes, edges: edges, nextLabel: nextNodeLabel)
        undoStack.append(state)
        if undoStack.count > maxUndo { undoStack.removeFirst() }
        redoStack.removeAll()
        
        // Handle auto-save with error logging (fixes warning on await save())
        do {
            try await save()  // Use 'try await' here
        } catch {
            let logger = Logger.forCategory("graphmodel")  // From your standardized logging
            logger.errorLog("Auto-save failed during snapshot", error: error)
            // Optional: If you want user feedback, set viewModel.errorMessage here (e.g., via NotificationCenter)
        }
        
        Self.logger.debug("snapshot() completed; undoStack size: \(self.undoStack.count)")
    }
}
--------------------------------------------------
