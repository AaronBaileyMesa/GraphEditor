## Focused Project Concatenation
This file includes only UI, interactivity, model, and core logic files.
Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
Current date: 2025-10-03 15:54:40
Table of Contents:
1. GraphEditorShared/Sources/GraphEditorShared/AttractionCalculator.swift
2. GraphEditorShared/Sources/GraphEditorShared/CenteringCalculator.swift
3. GraphEditorShared/Sources/GraphEditorShared/Constants.swift
4. GraphEditorShared/Sources/GraphEditorShared/CoordinateTransformer.swift
5. GraphEditorShared/Sources/GraphEditorShared/GraphModel.swift
6. GraphEditorShared/Sources/GraphEditorShared/GraphModel+EdgesNodes.swift
7. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Helpers.swift
8. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Simulation.swift
9. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Storage.swift
10. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Undo.swift
11. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Visibility.swift--------------------------------------------------
File: AttractionCalculator.swift
Path: GraphEditorShared/Sources/GraphEditorShared/AttractionCalculator.swift
Last modified: 2025-09-19 13:45:29

Contents:
//
//  AttractionCalculator.swift
//  GraphEditorShared
//
//  Created by handcart on 8/12/25.
//

import Foundation  // For hypot, CGFloat, etc.
import CoreGraphics  // For CGPoint, CGVector (used internally)

@available(iOS 16.0, watchOS 9.0, *)
struct AttractionCalculator {
    let symmetricFactor: CGFloat
    let useAsymmetric: Bool  // New: Controls full asymmetry for hierarchy edges

    init(symmetricFactor: CGFloat, useAsymmetric: Bool = false) {  // Default false to preserve existing behavior
        self.symmetricFactor = symmetricFactor
        self.useAsymmetric = useAsymmetric
    }

    func applyAttractions(forces: [NodeID: CGPoint], edges: [GraphEdge], nodes: [any NodeProtocol]) -> [NodeID: CGPoint] {
        var updatedForces = forces
        for edge in edges {
            guard let fromNode = nodes.first(where: { $0.id == edge.from }),
                  let toNode = nodes.first(where: { $0.id == edge.target }) else { continue }
            let deltaX = toNode.position.x - fromNode.position.x
            let deltaY = toNode.position.y - fromNode.position.y
            let dist = max(hypot(deltaX, deltaY), Constants.Physics.distanceEpsilon)
            let forceMagnitude = Constants.Physics.stiffness * (dist - Constants.Physics.idealLength)
            let forceDirectionX = deltaX / dist
            let forceDirectionY = deltaY / dist
            let forceX = forceDirectionX * forceMagnitude
            let forceY = forceDirectionY * forceMagnitude
            
            let symForceX = forceX * self.symmetricFactor
            let symForceY = forceY * self.symmetricFactor
            
            let currentForceFrom = updatedForces[fromNode.id] ?? CGPoint.zero
            let currentForceTo = updatedForces[toNode.id] ?? CGPoint.zero
            
            let isHierarchy = edge.type == .hierarchy
            if isHierarchy && self.useAsymmetric {
                // Full asymmetric: Strong pull 'to' toward 'from'; minimal back-pull on 'from' (test-friendly)
                let asymmetricFactor: CGFloat = 2.0  // Stronger pull for 'to'; tune if needed
                let toForceX = -forceX * asymmetricFactor  // Pull 'to' left/up toward 'from'
                let toForceY = -forceY * asymmetricFactor
                let fromBackPullX = forceX * 0.1  // Minimal back-pull (10% to keep stable)
                let fromBackPullY = forceY * 0.1
                
                updatedForces[toNode.id] = CGPoint(x: currentForceTo.x + toForceX, y: currentForceTo.y + toForceY)
                updatedForces[fromNode.id] = CGPoint(x: currentForceFrom.x + fromBackPullX, y: currentForceFrom.y + fromBackPullY)
            } else if isHierarchy {
                // Symmetric for stability (net force zero)
                updatedForces[toNode.id] = CGPoint(x: currentForceTo.x - forceX + symForceX, y: currentForceTo.y - forceY + symForceY)
                updatedForces[fromNode.id] = CGPoint(x: currentForceFrom.x + symForceX, y: currentForceFrom.y + symForceY)
            } else {
                // Symmetric for .association (unchanged)
                updatedForces[toNode.id] = CGPoint(x: currentForceTo.x - forceX + symForceX, y: currentForceTo.y - forceY + symForceY)
                updatedForces[fromNode.id] = CGPoint(x: currentForceFrom.x + symForceX, y: currentForceFrom.y + symForceY)
            }
        }
        return updatedForces
    }
}
----------------------------------------------------------------------------------------------------
File: CenteringCalculator.swift
Path: GraphEditorShared/Sources/GraphEditorShared/CenteringCalculator.swift
Last modified: 2025-09-19 13:45:29

Contents:
//
//  CenteringCalculator.swift
//  GraphEditorShared
//
//  Created by handcart on 8/12/25.
//

import Foundation
import CoreGraphics

struct CenteringCalculator {
    let simulationBounds: CGSize

    @available(iOS 16.0, *)
    func applyCentering(forces: [NodeID: CGPoint], nodes: [any NodeProtocol]) -> [NodeID: CGPoint] {
        var updatedForces = forces
        let center = CGPoint(x: simulationBounds.width / 2, y: simulationBounds.height / 2)
        for node in nodes {
            let deltaX = center.x - node.position.x
            let deltaY = center.y - node.position.y
            let distToCenter = hypot(deltaX, deltaY)
            let forceX = deltaX * Constants.Physics.centeringForce * (1 + distToCenter / max(simulationBounds.width, simulationBounds.height))
            let forceY = deltaY * Constants.Physics.centeringForce * (1 + distToCenter / max(simulationBounds.width, simulationBounds.height))
            let currentForce = updatedForces[node.id] ?? .zero
            updatedForces[node.id] = CGPoint(x: currentForce.x + forceX, y: currentForce.y + forceY)
        }
        return updatedForces
    }
}
----------------------------------------------------------------------------------------------------
File: Constants.swift
Path: GraphEditorShared/Sources/GraphEditorShared/Constants.swift
Last modified: 2025-09-25 15:18:40

Contents:
//
//  Constants.swift
//  GraphEditorShared
//
//  Created by handcart on 8/6/25.
//
// Sources/GraphEditorShared/Constants.swift

import CoreGraphics

public enum Constants {
    public enum Physics {
        public static let stiffness: CGFloat = 0.4  // Reduced from 0.8 for softer springs
        public static let repulsion: CGFloat = 1200  // Reduced from 2200 for less aggressive push
        public static let damping: CGFloat = 0.9  // Reduced from 0.99 for faster settling
        public static let idealLength: CGFloat = 80  // Slightly increased for more space
        public static let centeringForce: CGFloat = 0.03  // Reduced from 0.06 to avoid over-pull
        public static let distanceEpsilon: CGFloat = 1e-3
        public static let timeStep: CGFloat = 0.02  // Slightly reduced for finer steps
        public static let velocityThreshold: CGFloat = 0.3  // Increased from 0.2 for earlier stop
        public static let maxSimulationSteps = 500  // Further reduced from 1000 for quick convergence
        public static let minQuadSize: CGFloat = 1e-6
        public static let maxQuadtreeDepth = 20
        public static let maxNodesForQuadtree = 200
        public static let minCollisionDist: CGFloat = 35.0  // New: For anti-collision separation
        public static let verticalBias: CGFloat = 0.0  // New: Downward bias for hierarchy edges (tune as needed)
    }
    
    public enum App {
        public static let nodeModelRadius: CGFloat = 10.0
        public static let hitScreenRadius: CGFloat = 40.0  // Larger for watchOS tap targets
        public static let tapThreshold: CGFloat = 20.0  // Tightened from 10.0 for small screens
        public static let numZoomLevels: Int = 20  // For crown mapping
        public static let contentPadding: CGFloat = 50.0  // Padding for graph bounds
        public static let maxZoom: CGFloat = 8.0  // Maximum zoom level
    }
    
    // Add more enums as needed (e.g., UI, Testing)
}
----------------------------------------------------------------------------------------------------
File: CoordinateTransformer.swift
Path: GraphEditorShared/Sources/GraphEditorShared/CoordinateTransformer.swift
Last modified: 2025-09-26 08:05:37

Contents:
//
//  CoordinateTransformer.swift
//  GraphEditorShared
//
//  Created by handcart on 9/26/25.
//

import CoreGraphics
import SwiftUI  // For GeometryProxy if enabled

/// Utility for converting between model (graph) coordinates and screen (view) coordinates.
public struct CoordinateTransformer {
    
    /// Converts a model position to screen coordinates.
    /// - Parameters:
    ///   - modelPos: The position in model space.
    ///   - effectiveCentroid: The centroid of the graph for centering.
    ///   - zoomScale: Current zoom level.
    ///   - offset: Pan offset.
    ///   - viewSize: Size of the view.
    ///   - geometry: Optional GeometryProxy for safe area adjustments (e.g., on watchOS).
    /// - Returns: Screen position.
    public static func modelToScreen(
        _ modelPos: CGPoint,
        effectiveCentroid: CGPoint,
        zoomScale: CGFloat,
        offset: CGSize,
        viewSize: CGSize
        // geometry: GeometryProxy? = nil  // Uncomment if needed for safe areas
    ) -> CGPoint {
        let viewCenter = CGPoint(x: viewSize.width / 2, y: viewSize.height / 2)
        let relativePos = modelPos - effectiveCentroid
        let scaledPos = relativePos * zoomScale
        let screenPos = viewCenter + scaledPos + CGPoint(x: offset.width, y: offset.height)
        
        // Optional: Adjust for safe areas (symmetric to screenToModel)
        // if let geo = geometry {
        //     screenPos.x += geo.safeAreaInsets.leading
        //     screenPos.y += geo.safeAreaInsets.top
        // }
        
        #if DEBUG
        print("modelToScreen: Model \(modelPos) -> Screen \(screenPos), Zoom \(zoomScale), Offset \(offset), Centroid \(effectiveCentroid), ViewSize \(viewSize)")
        #endif
        
        return screenPos
    }
    
    /// Converts a screen position back to model coordinates.
    /// - Parameters:
    ///   - screenPos: The position in screen space.
    ///   - effectiveCentroid: The centroid of the graph for centering.
    ///   - zoomScale: Current zoom level.
    ///   - offset: Pan offset.
    ///   - viewSize: Size of the view.
    ///   - geometry: Optional GeometryProxy for safe area adjustments (e.g., on watchOS).
    /// - Returns: Model position (rounded to 3 decimals to reduce floating-point drift).
    public static func screenToModel(
        _ screenPos: CGPoint,
        effectiveCentroid: CGPoint,
        zoomScale: CGFloat,
        offset: CGSize,
        viewSize: CGSize
        // geometry: GeometryProxy? = nil  // Uncomment if needed for safe areas
    ) -> CGPoint {
        let safeZoom = max(zoomScale, 0.001)  // Prevent div-by-zero; adjust based on your minZoom
        let viewCenter = CGPoint(x: viewSize.width / 2, y: viewSize.height / 2)
        let panOffset = CGPoint(x: offset.width, y: offset.height)
        
        let translated = screenPos - viewCenter - panOffset
        
        // Optional: Adjust for safe areas (e.g., touches missing near edges on watchOS)
        // if let geo = geometry {
        //     translated.x -= geo.safeAreaInsets.leading
        //     translated.y -= geo.safeAreaInsets.top
        // }
        
        let unscaled = translated / safeZoom
        let modelPos = effectiveCentroid + unscaled
        
        #if DEBUG
        print("screenToModel: Screen \(screenPos) -> Model \(modelPos), Zoom \(safeZoom), Offset \(panOffset), Centroid \(effectiveCentroid), ViewSize \(viewSize)")
        #endif
        
        // Round to 3 decimals to eliminate floating-point drift
        return CGPoint(x: modelPos.x.rounded(to: 3), y: modelPos.y.rounded(to: 3))
    }
}

// Extension for rounding (if not already in Utilities.swift)
private extension CGFloat {
    func rounded(to decimalPlaces: Int) -> CGFloat {
        let divisor = pow(10.0, CGFloat(decimalPlaces))
        return (self * divisor).rounded() / divisor
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel.swift
Last modified: 2025-10-03 14:29:14

Contents:
//
//  GraphModel.swift
//  GraphEditorShared
//
//  Created by handcart on 10/3/25.
//

import os.log
import SwiftUI
import Combine
import Foundation

#if os(watchOS)
import WatchKit
#endif

private let logger = OSLog(subsystem: "io.handcart.GraphEditor", category: "storage")

@available(iOS 16.0, watchOS 6.0, *)
@MainActor public class GraphModel: ObservableObject {
    @Published public var currentGraphName: String = "default"  // Standardized to "default" for consistency
    @Published public var nodes: [AnyNode] = []
    @Published public var edges: [GraphEdge] = []
    @Published public var isSimulating: Bool = false
    @Published public var isStable: Bool = false
    @Published public var simulationError: Error?

    var simulationTimer: Timer?
    var undoStack: [UndoGraphState] = []
    var redoStack: [UndoGraphState] = []
    public var maxUndo: Int = 10

    public var nextNodeLabel = 1

    public let storage: GraphStorage
    public var physicsEngine: PhysicsEngine

    public var hiddenNodeIDs: Set<NodeID> {
        // Removed debug print to avoid side effects; add os_log if needed for production logging.
        var hidden = Set<NodeID>()
        var toHide: [NodeID] = []

        for node in nodes where node.unwrapped.shouldHideChildren() {
            let children = edges.filter { $0.from == node.id && $0.type == .hierarchy }.map { $0.target }
            toHide.append(contentsOf: children)
        }

        let adj = buildAdjacencyList(for: .hierarchy)
        while !toHide.isEmpty {
            let current = toHide.removeLast()
            if hidden.insert(current).inserted {
                let children = adj[current] ?? []
                toHide.append(contentsOf: children)
            }
        }

        return hidden
    }

    lazy var simulator: GraphSimulator = {
        GraphSimulator(
            getNodes: { [weak self] in self?.nodes.map { $0.unwrapped } ?? [] },
            setNodes: { [weak self] newNodes in
                self?.nodes = newNodes.map { AnyNode($0) }
            },
            getEdges: { [weak self] in self?.edges ?? [] },
            getVisibleNodes: { [weak self] in self?.visibleNodes() ?? [] },
            getVisibleEdges: { [weak self] in self?.visibleEdges() ?? [] },
            physicsEngine: self.physicsEngine,
            onStable: { [weak self] in
                guard let self = self, !self.isStable else { return }
                let velocities = self.nodes.map { hypot($0.velocity.x, $0.velocity.y) }
                if velocities.allSatisfy({ $0 < 0.001 }) {
                    print("Simulation stable: Centering nodes")
                    let centeredNodes = self.physicsEngine.centerNodes(nodes: self.nodes.map { $0.unwrapped })
                    self.nodes = centeredNodes.map { AnyNode($0.with(position: $0.position, velocity: .zero)) }
                    self.isStable = true
                    Task {
                        await self.stopSimulation()
                        try? await Task.sleep(nanoseconds: 500_000_000)
                        self.isStable = false
                    }
                    self.objectWillChange.send()
                }
            }
        )
    }()

    public var canUndo: Bool {
        !undoStack.isEmpty
    }

    public var canRedo: Bool {
        !redoStack.isEmpty
    }

    public init(storage: GraphStorage, physicsEngine: PhysicsEngine) {
        self.storage = storage
        self.physicsEngine = physicsEngine
        print("GraphModel initialized with storage: \(type(of: storage))")  // NEW: Log init
        
        // Load default graph on init
        Task {
            do {
                try await self.loadGraph()
            } catch {
                print("Failed to load default graph: \(error)")
                // Fallback to empty if load fails
                self.nodes = []
                self.edges = []
            }
        }
    }
    
    func buildAdjacencyList(for type: EdgeType) -> [NodeID: [NodeID]] {
        var adj: [NodeID: [NodeID]] = [:]
        for edge in edges where edge.type == type {
            adj[edge.from, default: []].append(edge.target)
        }
        return adj
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+EdgesNodes.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+EdgesNodes.swift
Last modified: 2025-10-03 14:29:35

Contents:
//
//  GraphModel+EdgesNodes.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    public func wouldCreateCycle(withNewEdgeFrom from: NodeID, target: NodeID, type: EdgeType) -> Bool {
        guard type == .hierarchy else { return false }
        var tempEdges = edges.filter { $0.type == .hierarchy }
        tempEdges.append(GraphEdge(from: from, target: target, type: type))
        return !isAcyclic(edges: tempEdges)
    }

    private func isAcyclic(edges: [GraphEdge]) -> Bool {
        var adj: [NodeID: [NodeID]] = [:]
        var inDegree: [NodeID: Int] = [:]
        nodes.forEach { inDegree[$0.id] = 0 }
        for edge in edges {
            adj[edge.from, default: []].append(edge.target)
            inDegree[edge.target, default: 0] += 1
        }
        var queue = nodes.filter { inDegree[$0.id] == 0 }.map { $0.id }
        var count = 0
        while !queue.isEmpty {
            let node = queue.removeFirst()
            count += 1
            for neighbor in adj[node] ?? [] {
                inDegree[neighbor]! -= 1
                if inDegree[neighbor]! == 0 { queue.append(neighbor) }
            }
        }
        return count == nodes.count
    }

    public func addEdge(from: NodeID, target: NodeID, type: EdgeType) async {
        if wouldCreateCycle(withNewEdgeFrom: from, target: target, type: type) {
            print("Cannot add edge: Would create cycle in hierarchy")
            return
        }
        pushUndo()
        edges.append(GraphEdge(from: from, target: target, type: type))
        objectWillChange.send()
        await resumeSimulation()
    }

    public func deleteEdge(withID id: UUID) async {
        pushUndo()
        edges.removeAll { $0.id == id }
        objectWillChange.send()
        await resumeSimulation()
    }

    public func addNode(at position: CGPoint) async {
        pushUndo()
        let newLabel = nextNodeLabel
        nextNodeLabel += 1
        let newNode = AnyNode(Node(label: newLabel, position: position))
        nodes.append(newNode)
        objectWillChange.send()
        await resumeSimulation()
    }

    public func addToggleNode(at position: CGPoint) async {
        pushUndo()
        let newLabel = nextNodeLabel
        nextNodeLabel += 1
        let newNode = AnyNode(ToggleNode(label: newLabel, position: position))
        nodes.append(newNode)
        objectWillChange.send()
        await resumeSimulation()
    }

    public func addChild(to parentID: NodeID) async {
        pushUndo()
        let newLabel = nextNodeLabel
        nextNodeLabel += 1
        guard let parentIndex = nodes.firstIndex(where: { $0.id == parentID }) else { return }
        let parentPosition = nodes[parentIndex].position
        let offsetX = CGFloat.random(in: -50...50)
        let offsetY = CGFloat.random(in: -50...50)
        let newPosition = parentPosition + CGPoint(x: offsetX, y: offsetY)
        let newNode = AnyNode(Node(label: newLabel, position: newPosition))
        nodes.append(newNode)
        edges.append(GraphEdge(from: parentID, target: newNode.id, type: .hierarchy))
        objectWillChange.send()
        await resumeSimulation()
    }

    public func deleteNode(withID id: NodeID) async {
        pushUndo()
        nodes.removeAll { $0.id == id }
        edges.removeAll { $0.from == id || $0.target == id }
        objectWillChange.send()
        await resumeSimulation()
    }

    public func updateNodeContent(withID id: NodeID, newContent: NodeContent?) async {
        pushUndo()
        if let index = nodes.firstIndex(where: { $0.id == id }) {
            var updated = nodes[index].unwrapped
            updated.content = newContent
            nodes[index] = AnyNode(updated)
            objectWillChange.send()
            await resumeSimulation()
        }
    }

    public func deleteSelected(selectedNodeID: NodeID?, selectedEdgeID: UUID?) async {
        pushUndo()
        if let id = selectedEdgeID {
            edges.removeAll { $0.id == id }
        } else if let id = selectedNodeID {
            nodes.removeAll { $0.id == id }
            edges.removeAll { $0.from == id || $0.target == id }
        }
        objectWillChange.send()
        await resumeSimulation()
    }

    public func toggleExpansion(for nodeID: NodeID) async {
        pushUndo()
        guard let idx = nodes.firstIndex(where: { $0.id == nodeID }), let toggle = nodes[idx].unwrapped as? ToggleNode else { return }
        let updated = toggle.handlingTap()
        nodes[idx] = AnyNode(updated)
        objectWillChange.send()
        await resumeSimulation()
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+Helpers.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Helpers.swift
Last modified: 2025-09-19 14:07:30

Contents:
//
//  GraphModel+Helpers.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    func buildAdjacencyList(for edgeType: EdgeType? = nil) -> [NodeID: [NodeID]] { 
        var adj = [NodeID: [NodeID]]()
        let filteredEdges = edgeType != nil ? edges.filter { $0.type == edgeType! } : edges
        for edge in filteredEdges {
            adj[edge.from, default: []].append(edge.target)
        }
        return adj
    }

    private func dfsVisible(node: any NodeProtocol, adjacency: [NodeID: [NodeID]], visited: inout Set<NodeID>, visible: inout [any NodeProtocol]) {
        visited.insert(node.id)
        visible.append(node)
        if !node.isExpanded { return }
        if let children = adjacency[node.id] {
            for childID in children {
                if !visited.contains(childID), let child = nodes.first(where: { $0.id == childID })?.unwrapped {
                    dfsVisible(node: child, adjacency: adjacency, visited: &visited, visible: &visible)
                }
            }
        }
    }

    public func isBidirectionalBetween(_ id1: NodeID, _ id2: NodeID) -> Bool {
        edges.contains(where: { $0.from == id1 && $0.target == id2 }) &&
        edges.contains(where: { $0.from == id2 && $0.target == id1 })
    }

    public func edgesBetween(_ id1: NodeID, _ id2: NodeID) -> [GraphEdge] {
        edges.filter { ($0.from == id1 && $0.target == id2) || ($0.from == id2 && $0.target == id1) }
    }

    public func handleTap(on nodeID: NodeID) async {
            guard let index = nodes.firstIndex(where: { $0.id == nodeID }) else { return }
            let oldNode = nodes[index]
            let updatedNode = oldNode.handlingTap()
            nodes[index] = updatedNode

            let children = edges.filter { $0.from == nodeID && $0.type == EdgeType.hierarchy }.map { $0.target } // Changed to EdgeType.hierarchy
        
        if let toggleNode = updatedNode.unwrapped as? ToggleNode {
            if toggleNode.isExpanded {
                for childID in children {
                    guard let childIndex = nodes.firstIndex(where: { $0.id == childID }) else { continue }
                    var child = nodes[childIndex]
                    let offsetX = CGFloat.random(in: -Constants.App.nodeModelRadius * 3 ... Constants.App.nodeModelRadius * 3)
                    let offsetY = CGFloat.random(in: Constants.App.nodeModelRadius * 2 ... Constants.App.nodeModelRadius * 4)
                    child.position = toggleNode.position + CGPoint(x: offsetX, y: offsetY)
                    child.velocity = .zero
                    nodes[childIndex] = child
                }
                physicsEngine.temporaryDampingBoost(steps: Constants.Physics.maxSimulationSteps / 10)
            } else {
                for childID in children {
                    guard let childIndex = nodes.firstIndex(where: { $0.id == childID }) else { continue }
                    var child = nodes[childIndex]
                    child.position = toggleNode.position
                    child.velocity = .zero
                    nodes[childIndex] = child
                }
            }
        }

        objectWillChange.send()
        let unwrappedNodes = nodes.map { $0.unwrapped }
        let updatedUnwrapped = physicsEngine.runSimulation(steps: 20, nodes: unwrappedNodes, edges: edges)
        nodes = updatedUnwrapped.map { AnyNode($0) }
        await resumeSimulation()
    }

    public func graphDescription(selectedID: NodeID?, selectedEdgeID: UUID?) -> String {
        let edgeCount = edges.count
        let edgeWord = edgeCount == 1 ? "edge" : "edges"
        var desc = "Graph with \(nodes.count) nodes and \(edgeCount) directed \(edgeWord)."
        if let selectedEdgeID = selectedEdgeID, let selectedEdge = edges.first(where: { $0.id == selectedEdgeID }),
           let fromNode = nodes.first(where: { $0.id == selectedEdge.from })?.unwrapped,
           let toNode = nodes.first(where: { $0.id == selectedEdge.target })?.unwrapped {
            desc += " Directed edge from node \(fromNode.label) to node \(toNode.label) selected."
        } else if let selectedID = selectedID, let selectedNode = nodes.first(where: { $0.id == selectedID })?.unwrapped {
            let outgoingLabels = edges
                .filter { $0.from == selectedID }
                .compactMap { edge in
                    let toID = edge.target
                    return nodes.first { $0.id == toID }?.unwrapped.label
                }
                .sorted()
                .map { String($0) }
                .joined(separator: ", ")
            let incomingLabels = edges
                .filter { $0.target == selectedID }
                .compactMap { edge in
                    let fromID = edge.from
                    return nodes.first { $0.id == fromID }?.unwrapped.label
                }
                .sorted()
                .map { String($0) }
                .joined(separator: ", ")
            let outgoingText = outgoingLabels.isEmpty ? "none" : outgoingLabels
            let incomingText = incomingLabels.isEmpty ? "none" : incomingLabels
            desc += " Node \(selectedNode.label) selected, outgoing to: \(outgoingText); incoming from: \(incomingText)."
        } else {
            desc += " No node or edge selected."
        }
        return desc
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+Simulation.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Simulation.swift
Last modified: 2025-10-03 14:11:39

Contents:
//
//  GraphModel+Simulation.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    public func resizeSimulationBounds(for nodeCount: Int) async {
        let newSize = max(300.0, sqrt(Double(nodeCount)) * 100.0)
        self.physicsEngine = PhysicsEngine(simulationBounds: CGSize(width: newSize, height: newSize))
        self.simulator = GraphSimulator(
            getNodes: { [weak self] in self?.nodes.map { $0.unwrapped } ?? [] },
            setNodes: { [weak self] newNodes in
                self?.nodes = newNodes.map { AnyNode($0) }
            },
            getEdges: { [weak self] in self?.edges ?? [] },
            getVisibleNodes: { [weak self] in self?.visibleNodes() ?? [] },
            getVisibleEdges: { [weak self] in self?.visibleEdges() ?? [] },
            physicsEngine: self.physicsEngine,
            onStable: { [weak self] in
                guard let self = self else { return }
                print("Simulation stable: Centering nodes")
                let centeredNodes = self.physicsEngine.centerNodes(nodes: self.nodes.map { $0.unwrapped })
                self.nodes = centeredNodes.map { AnyNode($0.with(position: $0.position, velocity: .zero)) }
                self.isStable = true
                self.objectWillChange.send()
            }
        )
    }

    public func startSimulation() async {
        
        isStable = false
        simulationError = nil
        isSimulating = true
        await simulator.startSimulation()
        isSimulating = false
    }

    public func stopSimulation() async {
        await simulator.stopSimulation()
    }

    public func pauseSimulation() async {
        await stopSimulation()
        physicsEngine.isPaused = true
    }

    public func resumeSimulation() async {
        physicsEngine.isPaused = false
        await startSimulation()
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+Storage.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Storage.swift
Last modified: 2025-10-03 14:16:01

Contents:
//
//  GraphModel+Storage.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    private func loadFromStorage(for name: String) async throws {
        print("loadFromStorage started for \(name)")  // Updated
        let (loadedNodes, loadedEdges) = try await storage.load(for: name)
        print("loadFromStorage: loaded \(loadedNodes.count) nodes, \(loadedEdges.count) edges for \(name)")  // Updated
        self.nodes = loadedNodes.map { AnyNode($0) }
        self.edges = loadedEdges
        self.nextNodeLabel = (nodes.map { $0.unwrapped.label }.max() ?? 0) + 1
    }
    
    public func load() async {
        print("GraphModel.load() called")  // Existing
        do {
            try await loadFromStorage(for: currentGraphName)
            syncCollapsedPositions()
            if let viewState = try storage.loadViewState(for: currentGraphName) {  // Updated to named (note: throws, but no await as per storage)
                // Apply view state if needed (e.g., publish or set properties)
                print("Loaded view state: offset \(viewState.offset), zoom \(viewState.zoomScale)")
            }
            print("GraphModel.load() succeeded; nodes: \(nodes.count), edges: \(edges.count)")  // NEW
        } catch {
            print("GraphModel.load() failed: \(error.localizedDescription)")  // Enhanced
        }
    }
    
    public func save() async {
        print("GraphModel.save() called; nodes: \(nodes.count), edges: \(edges.count)")  // Existing
        do {
            try await storage.save(nodes: nodes.map { $0.unwrapped }, edges: edges, for: currentGraphName)
            print("GraphModel.save() succeeded")  // Existing
        } catch {
            print("GraphModel.save() failed: \(error.localizedDescription)")  // Existing
        }
    }
    
    private func syncCollapsedPositions() {
        for parentIndex in 0..<nodes.count {
            if let toggle = nodes[parentIndex].unwrapped as? ToggleNode, !toggle.isExpanded {
                let children = edges.filter { $0.from == nodes[parentIndex].id && $0.type == .hierarchy }.map { $0.target }
                for (index, childID) in children.enumerated() {
                    guard let childIndex = nodes.firstIndex(where: { $0.id == childID }) else { continue }
                    var child = nodes[childIndex]
                    let angle = CGFloat(index) * (2 * .pi / CGFloat(children.count))
                    let jitterX = cos(angle) * 5.0
                    let jitterY = sin(angle) * 5.0
                    child.position = nodes[parentIndex].position + CGPoint(x: jitterX, y: jitterY)
                    child.velocity = .zero
                    nodes[childIndex] = child
                }
            }
        }
        objectWillChange.send()
    }
    
    public func clearGraph() async {
        print("clearGraph called")  // NEW
        nodes = []
        edges = []
        nextNodeLabel = 1
        do {
            try await storage.deleteGraph(name: currentGraphName)  // Updated to multi-graph clear (delete)
            print("clearGraph succeeded")  // Existing
        } catch {
            print("clearGraph failed: \(error.localizedDescription)")  // Existing
        }
        objectWillChange.send()
    }
    
    // Multi-graph methods (integrated into Storage extension)
    /// Loads the current graph (based on currentGraphName); defaults to empty if not found.
    public func loadGraph() async throws {
        do {
            try await loadFromStorage(for: currentGraphName)
            print("Loaded graph '\(currentGraphName)' with \(nodes.count) nodes and \(edges.count) edges")
            objectWillChange.send()
        } catch GraphStorageError.graphNotFound(_) {
            // Graph doesn't exist: Treat as new/empty
            nodes = []
            edges = []
            print("Graph '\(currentGraphName)' not found; starting empty")
        } catch {
            throw error
        }
    }
    
    /// Saves the current graph state under currentGraphName.
    public func saveGraph() async throws {
        try await save()
    }
    
    /// Creates a new empty graph with the given name and switches to it.
    public func createNewGraph(name: String) async throws {
        try await storage.createNewGraph(name: name)
        currentGraphName = name
        nodes = []
        edges = []
        nextNodeLabel = 1
        undoStack = []
        redoStack = []
        objectWillChange.send()
        print("Created and switched to new graph '\(name)'")
    }
    
    /// Loads a specific graph by name and switches to it.
    public func loadGraph(name: String) async throws {
        currentGraphName = name
        try await loadGraph()
    }
    
    /// Deletes the graph with the given name (if not current, no change to model).
    public func deleteGraph(name: String) async throws {
        try await storage.deleteGraph(name: name)
        if name == currentGraphName {
            // Reset to default if current is deleted
            currentGraphName = "default"
            try await loadGraph()
        }
        print("Deleted graph '\(name)'")
    }
    
    /// Lists all available graph names.
    public func listGraphNames() async throws -> [String] {
        try await storage.listGraphNames()
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+Undo.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Undo.swift
Last modified: 2025-10-03 11:45:25

Contents:
//
//  GraphModel+Undo.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation

struct UndoGraphState {
    let nodes: [AnyNode]
    let edges: [GraphEdge]
    let nextLabel: Int
}

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    internal func pushUndo() {
        undoStack.append(currentState())
        if undoStack.count > maxUndo { undoStack.removeFirst() }
        redoStack = []
    }
    
    private func currentState() -> UndoGraphState {
        UndoGraphState(nodes: nodes, edges: edges, nextLabel: nextNodeLabel)
    }
    
    public func undo() async {
        if let state = undoStack.popLast() {
            redoStack.append(currentState())
            nodes = state.nodes
            edges = state.edges
            nextNodeLabel = state.nextLabel
            objectWillChange.send()
            await resumeSimulation()
        }
    }
    
    public func redo() async {
        if let state = redoStack.popLast() {
            undoStack.append(currentState())
            nodes = state.nodes
            edges = state.edges
            nextNodeLabel = state.nextLabel
            objectWillChange.send()
            await resumeSimulation()
        }
    }
    
    public func snapshot() async {
        print("snapshot() called from: \(#function), nodes: \(nodes.count), edges: \(edges.count)")  // Add for debugging
        let state = UndoGraphState(nodes: nodes, edges: edges, nextLabel: nextNodeLabel)
        undoStack.append(state)
        if undoStack.count > maxUndo { undoStack.removeFirst() }
        redoStack.removeAll()
        await save()  // NEW: Auto-save graph data on snapshot (triggered by mutations)
        print("snapshot() completed; undoStack size: \(undoStack.count)")  // Add for debugging
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+Visibility.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Visibility.swift
Last modified: 2025-10-03 10:02:52

Contents:
//
//  GraphModel+Visibility.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    public func visibleNodes() -> [any NodeProtocol] {
        let hidden = hiddenNodeIDs
        return nodes.map { $0.unwrapped }.filter { !hidden.contains($0.id) }
    }

    public func visibleEdges() -> [GraphEdge] {
        let hidden = hiddenNodeIDs
        return edges.filter { !hidden.contains($0.from) && !hidden.contains($0.target) }
    }

    public func boundingBox() -> CGRect {
        self.physicsEngine.boundingBox(nodes: nodes.map { $0.unwrapped })
    }

    public func centerGraph() {
        let centered = physicsEngine.centerNodes(nodes: nodes.map { $0.unwrapped })
        nodes = centered.map { AnyNode($0) }
        objectWillChange.send()
    }

    public func expandAllRoots() async {
        for var root in buildRoots() {
            root.isExpanded = true
            if let index = nodes.firstIndex(where: { $0.id == root.id }) {
                nodes[index] = AnyNode(root)
            }
        }
        objectWillChange.send()
    }

    private func buildRoots() -> [any NodeProtocol] {
        var incoming = Set<NodeID>()
        for edge in edges {
            incoming.insert(edge.target)
        }
        return nodes.filter { !incoming.contains($0.id) }.map { $0.unwrapped }
    }
}
--------------------------------------------------
