## Focused Project Concatenation
This file includes only UI, interactivity, model, and core logic files.
Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
Current date: 2025-10-21 12:56:21
Table of Contents:
1. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Visibility.swift
2. GraphEditorShared/Sources/GraphEditorShared/GraphSimulator.swift
3. GraphEditorShared/Sources/GraphEditorShared/GraphTypes.swift
4. GraphEditorShared/Sources/GraphEditorShared/HitTestContext.swift
5. GraphEditorShared/Sources/GraphEditorShared/NodeProtocol.swift
6. GraphEditorShared/Sources/GraphEditorShared/PersistenceManager.swift--------------------------------------------------
File: GraphModel+Visibility.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Visibility.swift
Last modified: 2025-10-03 10:02:52

Contents:
//
//  GraphModel+Visibility.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    public func visibleNodes() -> [any NodeProtocol] {
        let hidden = hiddenNodeIDs
        return nodes.map { $0.unwrapped }.filter { !hidden.contains($0.id) }
    }

    public func visibleEdges() -> [GraphEdge] {
        let hidden = hiddenNodeIDs
        return edges.filter { !hidden.contains($0.from) && !hidden.contains($0.target) }
    }

    public func boundingBox() -> CGRect {
        self.physicsEngine.boundingBox(nodes: nodes.map { $0.unwrapped })
    }

    public func centerGraph() {
        let centered = physicsEngine.centerNodes(nodes: nodes.map { $0.unwrapped })
        nodes = centered.map { AnyNode($0) }
        objectWillChange.send()
    }

    public func expandAllRoots() async {
        for var root in buildRoots() {
            root.isExpanded = true
            if let index = nodes.firstIndex(where: { $0.id == root.id }) {
                nodes[index] = AnyNode(root)
            }
        }
        objectWillChange.send()
    }

    private func buildRoots() -> [any NodeProtocol] {
        var incoming = Set<NodeID>()
        for edge in edges {
            incoming.insert(edge.target)
        }
        return nodes.filter { !incoming.contains($0.id) }.map { $0.unwrapped }
    }
}
----------------------------------------------------------------------------------------------------
File: GraphSimulator.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphSimulator.swift
Last modified: 2025-10-15 03:54:44

Contents:
//
//  GraphSimulator.swift
//  GraphEditorShared
//
//  Created by handcart on 8/12/25.
//

import Foundation
import os  // For logging and signposts

#if os(watchOS)
import WatchKit  // Only if using haptics; otherwise remove
#endif

@available(iOS 16.0, watchOS 6.0, *)
/// Manages physics simulation loops for graph updates.
class GraphSimulator {
    private let logger = Logger.forCategory("graphsimulator")  // Added: Define logger instance
    
    // NEW: Signposter for performance tracing
    #if DEBUG
    private let signposter: OSSignposter = {
        let subsystem = "io.handcart.GraphEditor"  // Match your app's subsystem
        return OSSignposter(subsystem: subsystem, category: "graphsimulator")
    }()
    #endif

    var simulationTask: Task<Void, Never>?  // Exposed for testing
    internal var recentVelocities: [CGFloat] = []  // Explicit internal for test access
    let velocityChangeThreshold: CGFloat
    let velocityHistoryCount: Int
    let baseInterval: TimeInterval  // Now configurable
    
    let physicsEngine: PhysicsEngine
    private let getVisibleNodes: () async -> [any NodeProtocol]
    private let getVisibleEdges: () async -> [GraphEdge]
    
    internal let getNodes: () async -> [any NodeProtocol]  // Changed from private to internal
    internal let setNodes: ([any NodeProtocol]) async -> Void  // Updated: Polymorphic
    private let getEdges: () async -> [GraphEdge]
    internal let onStable: (() -> Void)?  // New: Optional callback
    
    init(getNodes: @escaping () async -> [any NodeProtocol],
         setNodes: @escaping ([any NodeProtocol]) async -> Void,
         getEdges: @escaping () async -> [GraphEdge],
         getVisibleNodes: @escaping () async -> [any NodeProtocol],
         getVisibleEdges: @escaping () async -> [GraphEdge],
         physicsEngine: PhysicsEngine,
         onStable: (() -> Void)? = nil,
         baseInterval: TimeInterval = 1.0 / 30.0,  // Default value
         velocityChangeThreshold: CGFloat = 0.01,
         velocityHistoryCount: Int = 5) {
        self.getNodes = getNodes
        self.setNodes = setNodes
        self.getEdges = getEdges
        self.physicsEngine = physicsEngine
        self.onStable = onStable
        
        self.getVisibleNodes = getVisibleNodes
        self.getVisibleEdges = getVisibleEdges
        
        self.baseInterval = baseInterval
        self.velocityChangeThreshold = velocityChangeThreshold
        self.velocityHistoryCount = velocityHistoryCount
    }
    
    struct SimulationStepResult {
        let updatedNodes: [any NodeProtocol]
        let shouldContinue: Bool
        let totalVelocity: CGFloat
    }
    
    @MainActor
    func startSimulation() async {
    #if os(watchOS)
        guard WKApplication.shared().applicationState == .active else { return }
    #endif
        physicsEngine.resetSimulation()
        recentVelocities.removeAll()
        
        let nodeCount = await getNodes().count
        if nodeCount < 5 {
            onStable?()  // NEW: Call here to handle "already stable" cases
            return
        }
        
        var adjustedInterval = baseInterval
        if nodeCount >= 20 {
            adjustedInterval = nodeCount < 50 ? 1.0 / 15.0 : 1.0 / 10.0
        }
        if ProcessInfo.processInfo.isLowPowerModeEnabled {
            adjustedInterval *= 2.0
        }
        
        simulationTask = Task {
            await self.runSimulationLoop(baseInterval: adjustedInterval, nodeCount: nodeCount)
            self.simulationTask = nil  // Clear after completion (moved inside Task)
        }
    }
    
    func stopSimulation() async {
        simulationTask?.cancel()
        await simulationTask?.value
        simulationTask = nil  // Added: Clear task after stop
    }
    
    internal func runSimulationLoop(baseInterval: TimeInterval, nodeCount: Int) async {
        #if DEBUG
        let loopState = signposter.beginInterval("SimulationLoop", "Nodes: \(nodeCount)")
        #endif
        
        let startTime = Date()  // Added for perf logging
        logger.debug("Starting sim loop with nodeCount: \(nodeCount), maxIterations: 500")
        var iterations = 0
        let maxIterations = 500
        while !Task.isCancelled && iterations < maxIterations {
            if physicsEngine.isPaused {
                try? await Task.sleep(for: .milliseconds(100))
                continue
            }
            let shouldContinue = await performSimulationStep(baseInterval: baseInterval, nodeCount: nodeCount)
            physicsEngine.alpha *= (1 - Constants.Physics.alphaDecay)
            iterations += 1
            logger.debug("Iteration \(iterations): shouldContinue = \(shouldContinue)")
            if !shouldContinue {
                logger.info("Simulation stabilized after \(iterations) iterations")
                #if DEBUG
                signposter.endInterval("SimulationLoop", loopState, "Stabilized after \(iterations) iterations")
                #endif
                break
            }
        }
        let duration = Date().timeIntervalSince(startTime)  // Added for perf
        if iterations >= maxIterations {
            logger.warning("Simulation timed out after \(iterations) iterations; recent velocities: \(self.recentVelocities); duration: \(duration)s")
            #if DEBUG
            signposter.endInterval("SimulationLoop", loopState, "Timed out after \(iterations) iterations")
            signposter.emitEvent("SimulationTimeout", "Recent velocities: \(self.recentVelocities)")
            #endif
        }
        self.onStable?()
    }

    internal func performSimulationStep(baseInterval: TimeInterval, nodeCount: Int) async -> Bool {
    #if os(watchOS)
        if await WKApplication.shared().applicationState != .active { return false }
    #endif
        
        if physicsEngine.isPaused { return false }
        
        #if DEBUG
        let stepState = signposter.beginInterval("SimulationStep", "Nodes: \(nodeCount)")
        #endif
        
        let result: SimulationStepResult = await Task.detached {
            await self.computeSimulationStep()
        }.value
        logger.debug("Step: Total velocity = \(result.totalVelocity)")
        await self.setNodes(result.updatedNodes)
        
        recentVelocities.append(result.totalVelocity)
        if recentVelocities.count > velocityHistoryCount {
            recentVelocities.removeFirst()
        }
        
        let velocityChange = recentVelocities.max()! - recentVelocities.min()!
        let isStable = velocityChange < velocityChangeThreshold && recentVelocities.allSatisfy { $0 < 0.5 }
        
        #if DEBUG
        signposter.endInterval("SimulationStep", stepState, "Total velocity: \(result.totalVelocity), Stable: \(isStable)")
        #endif
        
        return !isStable
    }
    
    internal func computeSimulationStep() async -> SimulationStepResult {
        let nodes = await getNodes()
        let edges = await getEdges()
        
        let (updatedNodes, isActive) = physicsEngine.simulationStep(nodes: nodes, edges: edges)
        let totalVelocity = updatedNodes.reduce(0.0) { $0 + hypot($1.velocity.x, $1.velocity.y) }
        
        return SimulationStepResult(updatedNodes: updatedNodes, shouldContinue: isActive, totalVelocity: totalVelocity)
    }
    
    internal func shouldStopSimulation(result: SimulationStepResult, nodeCount: Int) -> Bool {
        recentVelocities.append(result.totalVelocity)
        if recentVelocities.count > velocityHistoryCount {
            recentVelocities.removeFirst()
        }
        let velocityChange = recentVelocities.max()! - recentVelocities.min()!
        let isStable = velocityChange < velocityChangeThreshold && recentVelocities.allSatisfy { $0 < 0.5 }
        return isStable  // True if should stop (stable and low velocity)
    }
}
----------------------------------------------------------------------------------------------------
File: GraphTypes.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphTypes.swift
Last modified: 2025-10-20 15:08:40

Contents:
//
//  GraphTypes.swift
//  GraphEditorShared
//
//  Created by handcart on 2025-09-19 13:45:29

import SwiftUI
import Foundation

public typealias NodeID = UUID

@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public struct Node: NodeProtocol, Equatable {
    public let id: NodeID
    public let label: Int
    public var position: CGPoint
    public var velocity: CGPoint = .zero
    public var radius: CGFloat = 10.0
    public var isExpanded: Bool = true  // Satisfy protocol (always true for basic Node)
    public var contents: [NodeContent] = []  // NEW: Ordered list, default empty
    public var fillColor: Color { .red }  // Explicit red for basic nodes

    // Init with all params
    public init(id: NodeID = NodeID(), label: Int, position: CGPoint, velocity: CGPoint = .zero, radius: CGFloat = 10.0, isExpanded: Bool = true, contents: [NodeContent] = []) {
        self.id = id
        self.label = label
        self.position = position
        self.velocity = velocity
        self.radius = radius
        self.isExpanded = isExpanded
        self.contents = contents
    }
    
    public func with(position: CGPoint, velocity: CGPoint) -> Self {
        Node(id: id, label: label, position: position, velocity: velocity, radius: radius, isExpanded: isExpanded, contents: contents)
    }
    
    public func with(position: CGPoint, velocity: CGPoint, contents: [NodeContent]) -> Self {
        Node(id: id, label: label, position: position, velocity: velocity, radius: radius, isExpanded: isExpanded, contents: contents)
    }
}

// New: EdgeType enum
public enum EdgeType: String, Codable {
    case hierarchy  // DAG-enforced, directed
    case association  // Allows cycles, symmetric/undirected feel
}

// Represents an edge connecting two nodes.
public struct GraphEdge: Identifiable, Equatable, Codable {
    public let id: NodeID
    public let from: NodeID
    public let target: NodeID
    public let type: EdgeType  // Required type
    
    enum CodingKeys: String, CodingKey {
        case id, from, target, type
    }
    
    public init(id: NodeID = NodeID(), from: NodeID, target: NodeID, type: EdgeType = .association) {
        self.id = id
        self.from = from
        self.target = target
        self.type = type
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(NodeID.self, forKey: .id)
        from = try container.decode(NodeID.self, forKey: .from)
        target = try container.decode(NodeID.self, forKey: .target)
        type = try container.decode(EdgeType.self, forKey: .type)
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(from, forKey: .from)
        try container.encode(target, forKey: .target)
        try container.encode(type, forKey: .type)
    }
    
    public static func == (lhs: GraphEdge, rhs: GraphEdge) -> Bool {
        lhs.id == rhs.id && lhs.from == rhs.from && lhs.target == rhs.target && lhs.type == rhs.type
    }
}

// Snapshot of the graph state for undo/redo.
@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public struct GraphState {
    public let nodes: [any NodeProtocol]
    public let edges: [GraphEdge]
    
    public init(nodes: [any NodeProtocol], edges: [GraphEdge]) {
        self.nodes = nodes
        self.edges = edges
    }
}

@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public enum NodeWrapper: Codable {
    case node(Node)
    case toggleNode(ToggleNode)
    
    enum CodingKeys: String, CodingKey {
        case type, data
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(String.self, forKey: .type)
        switch type {
        case "node":
            let data = try container.decode(Node.self, forKey: .data)
            self = .node(data)
        case "toggleNode":
            let data = try container.decode(ToggleNode.self, forKey: .data)
            self = .toggleNode(data)
        default:
            throw DecodingError.dataCorruptedError(forKey: .type, in: container, debugDescription: "Unknown node type")
        }
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
        case .node(let node):
            try container.encode("node", forKey: .type)
            try container.encode(node, forKey: .data)
        case .toggleNode(let toggleNode):
            try container.encode("toggleNode", forKey: .type)
            try container.encode(toggleNode, forKey: .data)
        }
    }
    
    public var value: any NodeProtocol {
        switch self {
        case .node(let node): return node
        case .toggleNode(let toggleNode): return toggleNode
        }
    }
}
----------------------------------------------------------------------------------------------------
File: HitTestContext.swift
Path: GraphEditorShared/Sources/GraphEditorShared/HitTestContext.swift
Last modified: 2025-09-26 10:18:51

Contents:
// GraphEditorShared/Sources/GraphEditorShared/HitTestHelper.swift

import CoreGraphics
import os.log  // For standardized logging

private let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "hit_test")

/// Context for hit testing (matches GestureContext from GraphGesturesModifier).
public struct HitTestContext {
    public init(zoomScale: CGFloat, offset: CGSize, viewSize: CGSize, effectiveCentroid: CGPoint) {
          self.zoomScale = zoomScale
          self.offset = offset
          self.viewSize = viewSize
          self.effectiveCentroid = effectiveCentroid
      }
    
    public let zoomScale: CGFloat
    public let offset: CGSize
    public let viewSize: CGSize
    public let effectiveCentroid: CGPoint
}

/// Helper for performing hit tests on nodes and edges in screen space.
public struct HitTestHelper {
    
    /// Finds the closest node to a screen position, if within hit radius.
    /// - Returns: The closest node, or nil if none hit.
    public static func closestNode(at screenPos: CGPoint, visibleNodes: [any NodeProtocol], context: HitTestContext) -> (any NodeProtocol)? {
        var closest: (node: (any NodeProtocol)?, dist: CGFloat) = (nil, .infinity)
        let minHitRadius: CGFloat = 10.0  // Minimum tappable radius in screen points
        let padding: CGFloat = 5.0  // Extra forgiveness
        
        for node in visibleNodes {
            let safeZoom = max(context.zoomScale, 0.1)
            let nodeScreenPos = CoordinateTransformer.modelToScreen(
                node.position,
                effectiveCentroid: context.effectiveCentroid,
                zoomScale: safeZoom,
                offset: context.offset,
                viewSize: context.viewSize
            )
            let dist = hypot(screenPos.x - nodeScreenPos.x, screenPos.y - nodeScreenPos.y)
            let visibleRadius = node.radius * safeZoom
            let nodeHitRadius = max(minHitRadius, visibleRadius) + padding
            
            if dist <= nodeHitRadius && dist < closest.dist {
                closest = (node, dist)
            }
        }
        
        #if DEBUG
        if let node = closest.node {
            logger.debug("Hit closest node \(node.label) at dist \(closest.dist)")
        } else {
            logger.debug("No node hit at screen pos \(String(describing: screenPos))")
        }
        #endif
        
        return closest.node
    }
    
    /// Finds the closest edge to a screen position, if within hit radius.
    /// - Returns: The closest edge, or nil if none hit.
    public static func closestEdge(at screenPos: CGPoint, visibleEdges: [GraphEdge], visibleNodes: [any NodeProtocol], context: HitTestContext) -> GraphEdge? {
        var closest: (edge: GraphEdge?, dist: CGFloat) = (nil, .infinity)
        let hitScreenRadius: CGFloat = 10.0  // Adjustable; smaller for edges to avoid node overlap
        
        for edge in visibleEdges {
            guard let fromNode = visibleNodes.first(where: { $0.id == edge.from }),
                  let toNode = visibleNodes.first(where: { $0.id == edge.target }) else { continue }
            
            let safeZoom = max(context.zoomScale, 0.1)
            let fromScreen = CoordinateTransformer.modelToScreen(
                fromNode.position,
                effectiveCentroid: context.effectiveCentroid,
                zoomScale: safeZoom,
                offset: context.offset,
                viewSize: context.viewSize
            )
            let toScreen = CoordinateTransformer.modelToScreen(
                toNode.position,
                effectiveCentroid: context.effectiveCentroid,
                zoomScale: safeZoom,
                offset: context.offset,
                viewSize: context.viewSize
            )
            
            let dist = pointToLineDistance(point: screenPos, from: fromScreen, target: toScreen)
            
            if dist <= hitScreenRadius && dist < closest.dist {
                closest = (edge, dist)
            }
        }
        
        #if DEBUG
        if let edge = closest.edge {
            logger.debug("Hit closest edge \(edge.id.uuidString.prefix(8)) at dist \(closest.dist)")
        } else {
            logger.debug("No edge hit at screen pos \(String(describing: screenPos))")
        }
        #endif
        
        return closest.edge
    }
    
    // Helper: Distance from point to line segment (extracted for clarity; add if not already in utilities)
    public static func pointToLineDistance(point: CGPoint, from: CGPoint, target: CGPoint) -> CGFloat {
        let lineVec = CGVector(dx: target.x - from.x, dy: target.y - from.y)
        let pointVec = CGVector(dx: point.x - from.x, dy: point.y - from.y)
        let lineLen = hypot(lineVec.dx, lineVec.dy)
        if lineLen == 0 { return hypot(pointVec.dx, pointVec.dy) }
        
        // Parametric position along the segment clamped to [0, 1]
        let clampedT = max(0, min(1, (pointVec.dx * lineVec.dx + pointVec.dy * lineVec.dy) / (lineLen * lineLen)))
        let proj = CGPoint(x: from.x + clampedT * lineVec.dx, y: from.y + clampedT * lineVec.dy)
        return hypot(point.x - proj.x, point.y - proj.y)
    }
}
----------------------------------------------------------------------------------------------------
File: NodeProtocol.swift
Path: GraphEditorShared/Sources/GraphEditorShared/NodeProtocol.swift
Last modified: 2025-10-21 08:18:29

Contents:
// Sources/GraphEditorShared/NodeProtocol.swift

import SwiftUI
import Foundation
import os

@available(iOS 15.0, *)
private var nodeTextCache: [String: GraphicsContext.ResolvedText] = [:]
private let maxCacheSize = 100  // Arbitrary limit; adjust based on testing
private let nodeCacheQueue = DispatchQueue(label: "nodeTextCache", attributes: .concurrent)
private var insertionOrder: [String] = []  // New: Track order

// NEW: Define NodeContent enum here (was missing; added with all primitives)
public enum NodeContent: Codable, Equatable {
    case string(String)
    case date(Date)
    case number(Double)
    case boolean(Bool)
    
    public var displayText: String {
        switch self {
        case .string(let value): return value.prefix(10) + (value.count > 10 ? "â€¦" : "")
        case .date(let value):
            let formatter = DateFormatter()
            formatter.dateStyle = .short
            formatter.timeStyle = .none
            formatter.timeZone = TimeZone(secondsFromGMT: 0)  // Force UTC for consistent output
            return formatter.string(from: value)
        case .number(let value): return String(format: "%.2f", value)  // Format to 2 decimal places
        case .boolean(let value): return value ? "True" : "False"
        }
    }
    
    private enum CodingKeys: String, CodingKey {
        case type, value
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(String.self, forKey: .type)
        switch type {
        case "string":
            let value = try container.decode(String.self, forKey: .value)
            self = .string(value)
        case "date":
            let value = try container.decode(Date.self, forKey: .value)
            self = .date(value)
        case "number":
            let value = try container.decode(Double.self, forKey: .value)
            self = .number(value)
        case "boolean":
            let value = try container.decode(Bool.self, forKey: .value)
            self = .boolean(value)
        default:
            throw DecodingError.dataCorruptedError(forKey: .type, in: container, debugDescription: "Unknown NodeContent type")
        }
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
        case .string(let value):
            try container.encode("string", forKey: .type)
            try container.encode(value, forKey: .value)
        case .date(let value):
            try container.encode("date", forKey: .type)
            try container.encode(value, forKey: .value)
        case .number(let value):
            try container.encode("number", forKey: .type)
            try container.encode(value, forKey: .value)
        case .boolean(let value):
            try container.encode("boolean", forKey: .type)
            try container.encode(value, forKey: .value)
        }
    }
}

/// Protocol for graph nodes, enabling polymorphism for types like standard or toggleable nodes.
/// Conformers must provide core properties; defaults are available for common behaviors.
@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public protocol NodeProtocol: Identifiable, Equatable, Codable where ID == NodeID {
    
    /// Unique identifier for the node.
    var id: NodeID { get }
    
    /// Permanent label for the node (e.g., for display and accessibility).
    var label: Int { get }
    
    /// Current position in the graph canvas.
    var position: CGPoint { get set }
    
    /// Velocity vector for physics simulation.
    var velocity: CGPoint { get set }
    
    /// Radius for rendering and hit detection.
    var radius: CGFloat { get set }
    
    /// Expansion state for hierarchical nodes (e.g., true shows children).
    var isExpanded: Bool { get set }
    
    // Data payload for the node
    // Ordered list of data payloads for the node (replaces single optional content)
    var contents: [NodeContent] { get set }
    
    /// Mass for physics calculations (default: 1.0).
    var mass: CGFloat { get }
    
    /// Creates a copy with updated position and velocity.
    func with(position: CGPoint, velocity: CGPoint) -> Self
    
    /// Creates a copy with updated position, velocity, and optional new contents list.
    func with(position: CGPoint, velocity: CGPoint, contents: [NodeContent]) -> Self
    
    /// Renders the node as a SwiftUI view, customizable by zoom and selection.
    /// - Parameters:
    ///   - zoomScale: Current zoom level of the canvas.
    ///   - isSelected: Whether the node is selected (e.g., for border highlight).
    /// - Returns: A SwiftUI view representing the node.
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    func renderView(zoomScale: CGFloat, isSelected: Bool) -> AnyView
    
    /// Handles tap gestures, returning a mutated copy (immutable pattern).
    /// - Returns: Updated node after tap (e.g., toggled state).
    func handlingTap() -> Self
    
    /// Indicates if the node is visible in the graph.
    var isVisible: Bool { get }
    
    /// Configurable fill color for the node's roundel.
    var fillColor: Color { get }
    
    /// Determines if child nodes (via outgoing edges) should be hidden.
    /// - Returns: True if children should be hidden (e.g., collapsed toggle).
    func shouldHideChildren() -> Bool
    
    /// Draws the node in a GraphicsContext for efficient Canvas rendering.
    /// - Parameters:
    ///   - context: The GraphicsContext to draw into.
    ///   - position: Center position for drawing.
    ///   - zoomScale: Current zoom level.
    ///   - isSelected: Whether to draw selection highlights.
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    func draw(in context: GraphicsContext, at position: CGPoint, zoomScale: CGFloat, isSelected: Bool)
}

extension NodeProtocol {
    public var isVisible: Bool { true }  // Default visible
    
    public var fillColor: Color { .blue }  // Default fill
    
    public var mass: CGFloat { 1.0 }  // Default mass
    
    public func shouldHideChildren() -> Bool { false }  // Default: show children
    
    public func handlingTap() -> Self { self }  // Default: no-op
    
    public func with(position: CGPoint, velocity: CGPoint) -> Self {
        var newSelf = self
        newSelf.position = position
        newSelf.velocity = velocity
        return newSelf
    }
    
    public func with(position: CGPoint, velocity: CGPoint, contents: [NodeContent]) -> Self {
        var newSelf = self
        newSelf.position = position
        newSelf.velocity = velocity
        newSelf.contents = contents
        return newSelf
    }
    
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    public func renderView(zoomScale: CGFloat, isSelected: Bool) -> AnyView {
        AnyView(Circle().fill(fillColor).frame(width: radius * 2 * zoomScale, height: radius * 2 * zoomScale))
    }
    
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    public func draw(in context: GraphicsContext, at position: CGPoint, zoomScale: CGFloat, isSelected: Bool) {
        let scaledRadius = radius * zoomScale
        let path = CGPath(ellipseIn: CGRect(x: position.x - scaledRadius, y: position.y - scaledRadius, width: scaledRadius * 2, height: scaledRadius * 2), transform: nil)
        context.fill(Path(path), with: .color(fillColor))
        context.stroke(Path(path), with: .color(isSelected ? Color.green : Color.white), lineWidth: 2 * zoomScale)
        
        let textKey = "\(label)_\(zoomScale)"
        var labelResolved: GraphicsContext.ResolvedText?
        nodeCacheQueue.sync {
            if let cached = nodeTextCache[textKey] {
                labelResolved = cached
            } else {
                let text = Text("\(label)").font(.system(size: 12 * zoomScale)).foregroundColor(.white)
                let resolved = context.resolve(text)
                nodeTextCache[textKey] = resolved
                insertionOrder.append(textKey)
                if nodeTextCache.count > maxCacheSize {
                    let oldestKey = insertionOrder.removeFirst()
                    nodeTextCache.removeValue(forKey: oldestKey)
                }
                labelResolved = resolved
            }
        }
        context.draw(labelResolved!, at: position, anchor: .center)
        
        // NEW: Draw contents list vertically below node
        if !contents.isEmpty && zoomScale > 0.5 {  // Only if zoomed
            var yOffset = scaledRadius + 5 * zoomScale  // Start below node
            let contentFontSize = max(6.0, 8.0 * zoomScale)
            let maxItems = 3  // Limit for watchOS
            for content in contents.prefix(maxItems) {
                let contentText = Text(content.displayText).font(.system(size: contentFontSize)).foregroundColor(.gray)
                let resolved = context.resolve(contentText)
                let contentPosition = CGPoint(x: position.x, y: position.y + yOffset)
                context.draw(resolved, at: contentPosition, anchor: .center)
                yOffset += 10 * zoomScale  // Line spacing
            }
            if contents.count > maxItems {
                let moreText = Text("+\(contents.count - maxItems) more").font(.system(size: contentFontSize * 0.75)).foregroundColor(.gray)
                let resolved = context.resolve(moreText)
                context.draw(resolved, at: CGPoint(x: position.x, y: position.y + yOffset), anchor: .center)
            }
        }
    }
}

@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public struct AnyNode: NodeProtocol {
    // NEW: Add the static logger here (moved from protocol)
    private static let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "nodeprotocol")
    
    private var base: any NodeProtocol  // var for mutability
    
    public var contents: [NodeContent] {
        get { base.contents }
        set { base.contents = newValue }
    }
    
    public var unwrapped: any NodeProtocol { base }
    
    public var id: NodeID { base.id }
    public var label: Int { base.label }
    public var position: CGPoint {
        get { base.position }
        set { base.position = newValue }
    }
    public var velocity: CGPoint {
        get { base.velocity }
        set { base.velocity = newValue }
    }
    public var radius: CGFloat {
        get { base.radius }
        set { base.radius = newValue }
    }
    public var isExpanded: Bool {
        get { base.isExpanded }
        set { base.isExpanded = newValue }
    }
    public var isVisible: Bool { base.isVisible }
    public var fillColor: Color { base.fillColor }
    public var mass: CGFloat { base.mass }
    
    public init(_ base: any NodeProtocol) {
        self.base = base
    }
    
    public func with(position: CGPoint, velocity: CGPoint) -> Self {
        var newBase = base
        newBase.position = position
        newBase.velocity = velocity
        return AnyNode(newBase)
    }
    
    public func with(position: CGPoint, velocity: CGPoint, contents: [NodeContent]) -> Self {
        var newBase = base
        newBase.position = position
        newBase.velocity = velocity
        newBase.contents = contents
        return AnyNode(newBase)
    }
    
    public func handlingTap() -> Self {
        AnyNode(base.handlingTap())
    }
    
    public func shouldHideChildren() -> Bool {
        base.shouldHideChildren()
    }
    
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    public func renderView(zoomScale: CGFloat, isSelected: Bool) -> AnyView {
        base.renderView(zoomScale: zoomScale, isSelected: isSelected)
    }
    
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    public func draw(in context: GraphicsContext, at position: CGPoint, zoomScale: CGFloat, isSelected: Bool) {
#if DEBUG
        Self.logger.debug("Drawing node \(label) at (\(position.x), \(position.y)), isSelected: \(isSelected), zoom: \(zoomScale)")
#endif
        base.draw(in: context, at: position, zoomScale: zoomScale, isSelected: isSelected)
    }
    
    public static func == (lhs: AnyNode, rhs: AnyNode) -> Bool {
        lhs.id == rhs.id && lhs.position == rhs.position && lhs.velocity == rhs.velocity &&
        lhs.isExpanded == rhs.isExpanded && lhs.contents == rhs.contents  // Updated for array
    }
    
    public init(from decoder: Decoder) throws {
        let wrapper = try NodeWrapper(from: decoder)
        self.base = wrapper.value
    }
    
    public func encode(to encoder: Encoder) throws {
        let wrapper: NodeWrapper
        if let node = base as? Node {
            wrapper = .node(node)
        } else if let toggleNode = base as? ToggleNode {
            wrapper = .toggleNode(toggleNode)
        } else {
            throw EncodingError.invalidValue(base, EncodingError.Context(codingPath: [], debugDescription: "Unsupported node type"))
        }
        try wrapper.encode(to: encoder)
    }
}
----------------------------------------------------------------------------------------------------
File: PersistenceManager.swift
Path: GraphEditorShared/Sources/GraphEditorShared/PersistenceManager.swift
Last modified: 2025-10-02 20:55:48

Contents:
// Sources/GraphEditorShared/PersistenceManager.swift

import Foundation
import os  // For Logger

@available(iOS 16.0, watchOS 6.0, *)
private let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "storage")

/// Error types for graph storage operations.
public enum GraphStorageError: Error {
    case encodingFailed(Error)
    case writingFailed(Error)
    case loadingFailed(Error)
    case decodingFailed(Error)
    case inconsistentFiles(String)  // Retained for potential future multi-file use
    case graphExists(String)  // New: For createNewGraph duplicates
    case graphNotFound(String)  // New: For load/delete misses
}

/// File-based JSON persistence conforming to GraphStorage.
@available(iOS 16.0, watchOS 6.0, *)
public class PersistenceManager: GraphStorage {
    private let directory: URL
    private let defaultGraphName = "default"
    
    public init(directoryName: String = "graphs") {
        let documents = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        self.directory = documents.appendingPathComponent(directoryName)
        createDirectoryIfNeeded()
    }
    
    private func createDirectoryIfNeeded() {
        do {
            try FileManager.default.createDirectory(at: directory, withIntermediateDirectories: true)
        } catch {
            logger.error("Failed to create directory: \(error.localizedDescription)")
        }
    }
    
    private func fileURL(for name: String) -> URL {
        directory.appendingPathComponent("graph-\(name).json")
    }
    
    private func viewStateKey(for name: String) -> String {
        "graphViewState_\(name)"
    }
    
    struct SavedState: Codable {
        var version: Int = 1
        let nodes: [NodeWrapper]
        let edges: [GraphEdge]
    }
    
    // MARK: - Default (Single-Graph) Methods (Unchanged Behavior)
    
    public func save(nodes: [any NodeProtocol], edges: [GraphEdge]) async throws {
        try await save(nodes: nodes, edges: edges, for: defaultGraphName)
    }
    
    public func load() async throws -> (nodes: [any NodeProtocol], edges: [GraphEdge]) {
        try await load(for: defaultGraphName)
    }
    
    public func clear() async throws {
        try await deleteGraph(name: defaultGraphName)
    }
    
    public func saveViewState(_ viewState: ViewState) async throws {
        try saveViewState(viewState, for: defaultGraphName)
    }
    
    public func loadViewState() async throws -> ViewState? {
        try loadViewState(for: defaultGraphName)
    }
    
    // MARK: - Multi-Graph Methods
    
    public func listGraphNames() async throws -> [String] {
        do {
            let contents = try FileManager.default.contentsOfDirectory(at: directory, includingPropertiesForKeys: nil)
            let names = contents
                .filter { $0.lastPathComponent.hasPrefix("graph-") && $0.pathExtension == "json" }
                .map { String($0.deletingPathExtension().lastPathComponent.dropFirst(6)) }  // Drop "graph-"
                .sorted()
            logger.debug("Listed \(names.count) graphs: \(names)")
            return names
        } catch {
            logger.error("Listing failed: \(error.localizedDescription)")
            throw GraphStorageError.loadingFailed(error)
        }
    }
    
    public func createNewGraph(name: String) async throws {
        let url = fileURL(for: name)
        if FileManager.default.fileExists(atPath: url.path) {
            logger.warning("Graph '\(name)' already exists")
            throw GraphStorageError.graphExists(name)
        }
        // Create empty graph
        let emptyNodes: [any NodeProtocol] = []
        let emptyEdges: [GraphEdge] = []
        try await save(nodes: emptyNodes, edges: emptyEdges, for: name)
        logger.debug("Created new graph: \(name)")
    }
    
    public func save(nodes: [any NodeProtocol], edges: [GraphEdge], for name: String) async throws {
        let wrapped = nodes.compactMap { node -> NodeWrapper? in
            if let plainNode = node as? Node { return .node(plainNode) } else if let toggleNode = node as? ToggleNode { return .toggleNode(toggleNode) } else {
                logger.error("Unsupported node type: \(String(describing: type(of: node))); skipping.")
                return nil  // Skip instead of fatalError
            }
        }
        let state = SavedState(nodes: wrapped, edges: edges)
        do {
            let data = try JSONEncoder().encode(state)
            try data.write(to: fileURL(for: name), options: .atomic)  // Ensures full overwrite
            logger.debug("Saved \(wrapped.count) nodes and \(edges.count) edges for graph '\(name)'")
        } catch let error as EncodingError {
            logger.error("Encoding failed for '\(name)': \(error.localizedDescription)")
            throw GraphStorageError.encodingFailed(error)
        } catch {
            logger.error("Writing failed for '\(name)': \(error.localizedDescription)")
            throw GraphStorageError.writingFailed(error)
        }
    }
    
    public func load(for name: String) async throws -> (nodes: [any NodeProtocol], edges: [GraphEdge]) {
        let url = fileURL(for: name)
        guard FileManager.default.fileExists(atPath: url.path) else {
            logger.debug("No saved file for '\(name)'; throwing not found")
            throw GraphStorageError.graphNotFound(name)
        }
        do {
            let data = try Data(contentsOf: url)
            let state = try JSONDecoder().decode(SavedState.self, from: data)
            if state.version != 1 {
                throw GraphStorageError.decodingFailed(NSError(domain: "Invalid version \(state.version) for '\(name)'", code: 0))
            }
            let loadedNodes = state.nodes.map { $0.value }
            logger.debug("Loaded \(loadedNodes.count) nodes and \(state.edges.count) edges for graph '\(name)'")
            return (loadedNodes, state.edges)
        } catch let error as DecodingError {
            logger.error("Decoding failed for '\(name)': \(error.localizedDescription)")
            throw GraphStorageError.decodingFailed(error)
        } catch {
            logger.error("Loading failed for '\(name)': \(error.localizedDescription)")
            throw GraphStorageError.loadingFailed(error)
        }
    }
    
    public func deleteGraph(name: String) async throws {
        let url = fileURL(for: name)
        if FileManager.default.fileExists(atPath: url.path) {
            try FileManager.default.removeItem(at: url)
            // Also clear associated view state
            UserDefaults.standard.removeObject(forKey: viewStateKey(for: name))
            UserDefaults.standard.synchronize()
            logger.debug("Deleted graph '\(name)'")
        } else {
            logger.warning("Graph '\(name)' not found for deletion")
            throw GraphStorageError.graphNotFound(name)
        }
    }
    
    // MARK: - View State (Per-Graph)
    
    public func saveViewState(_ viewState: ViewState, for name: String) throws {
        let data = try JSONEncoder().encode(viewState)
        UserDefaults.standard.set(data, forKey: viewStateKey(for: name))
        UserDefaults.standard.synchronize()  // Ensure immediate write
        logger.debug("Saved view state for '\(name)'")
    }
    
    public func loadViewState(for name: String) throws -> ViewState? {
        guard let data = UserDefaults.standard.data(forKey: viewStateKey(for: name)) else {
            logger.debug("No view state for '\(name)'")
            return nil
        }
        let decoded = try JSONDecoder().decode(ViewState.self, from: data)
        logger.debug("Loaded view state for '\(name)'")
        return decoded
    }
}
--------------------------------------------------
