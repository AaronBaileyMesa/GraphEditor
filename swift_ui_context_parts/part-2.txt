## Focused Project Concatenation
This file includes only UI, interactivity, model, and core logic files.
Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
Current date: 2025-11-12 10:00:32
Table of Contents:
1. GraphEditorShared/Sources/GraphEditorShared/GraphModel+EdgesNodes.swift
2. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Helpers.swift
3. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Simulation.swift
4. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Storage.swift
5. GraphEditorShared/Sources/GraphEditorShared/GraphModel+TreeSupport.swift
6. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Undo.swift
7. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Visibility.swift
8. GraphEditorShared/Sources/GraphEditorShared/GraphSimulator.swift--------------------------------------------------
File: GraphModel+EdgesNodes.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+EdgesNodes.swift
Last modified: 2025-11-10 22:56:21

Contents:
//
//  GraphModel+EdgesNodes.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation
import os  // ADDED: For Logger

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    // NEW: Add static logger for this extension
    private static let logger = Logger.forCategory("graphmodel_edgesnodes")

    // ADDED: @MainActor to isolate this method to the main thread
    @MainActor
    public func wouldCreateCycle(withNewEdgeFrom from: NodeID, target: NodeID, type: EdgeType) -> Bool {
        guard type == .hierarchy else { return false }
        var tempEdges = edges.filter { $0.type == .hierarchy }
        tempEdges.append(GraphEdge(from: from, target: target, type: type))
        return !isAcyclic(edges: tempEdges)
    }

    // ADDED: @MainActor to isolate this method to the main thread
    @MainActor
    private func isAcyclic(edges: [GraphEdge]) -> Bool {
        var adj: [NodeID: [NodeID]] = [:]
        var inDegree: [NodeID: Int] = [:]
        nodes.forEach { inDegree[$0.id] = 0 }
        for edge in edges {
            adj[edge.from, default: []].append(edge.target)
            inDegree[edge.target, default: 0] += 1
        }
        var queue = nodes.filter { inDegree[$0.id] == 0 }.map { $0.id }
        var count = 0
        while !queue.isEmpty {
            let node = queue.removeFirst()
            count += 1
            for neighbor in adj[node] ?? [] {
                inDegree[neighbor]! -= 1
                if inDegree[neighbor]! == 0 { queue.append(neighbor) }
            }
        }
        return count == nodes.count
    }

    // ADDED: @MainActor to isolate this method to the main thread
    @MainActor
    public func addEdge(from: NodeID, target: NodeID, type: EdgeType) async {
        if wouldCreateCycle(withNewEdgeFrom: from, target: target, type: type) {
            // CHANGED: Qualified static logger
            Self.logger.warning("Cannot add edge: Would create cycle in hierarchy")  // Replaced print with warning log
            return
        }
        pushUndo()
        edges.append(GraphEdge(from: from, target: target, type: type))
        objectWillChange.send()
        await resumeSimulation()
    }

    // ADDED: @MainActor to isolate this method to the main thread
    @MainActor
    public func deleteEdge(withID id: UUID) async {
        // CHANGED: Qualified
        Self.logger.debugLog("Deleting edge with ID: \(id.uuidString.prefix(8))")  // Added debug log
        pushUndo()
        edges.removeAll { $0.id == id }
        objectWillChange.send()
        await resumeSimulation()
    }

    // ADDED: @MainActor to isolate this method to the main thread
    @MainActor
    public func addNode(at position: CGPoint) async {
        // CHANGED: Qualified; manual CGPoint formatting
        Self.logger.debugLog("Adding node at position: x=\(position.x), y=\(position.y)")  // Added debug log
        pushUndo()
        let newLabel = nextNodeLabel
        nextNodeLabel += 1
        let newNode = AnyNode(Node(label: newLabel, position: position))
        nodes.append(newNode)
        objectWillChange.send()
        await resumeSimulation()
    }

    // ADDED: @MainActor to isolate this method to the main thread
    @MainActor
    public func addToggleNode(at position: CGPoint) async {
        Self.logger.debugLog("Adding toggle node at position: x=\(position.x), y=\(position.y)")  // Added debug log
        pushUndo()
        let newLabel = nextNodeLabel
        nextNodeLabel += 1
        let newNode = AnyNode(ToggleNode(label: newLabel, position: position))
        nodes.append(newNode)
        objectWillChange.send()
        await resumeSimulation()
    }

    // ADDED: @MainActor to isolate this method to the main thread
    @MainActor
    public func addPlainChild(to parentID: NodeID) async {
        Self.logger.debugLog("Adding plain child to parent ID: \(parentID.uuidString.prefix(8))")
        await addChildInternal(to: parentID, createChild: { label, position in
            Node(label: label, position: position)  // Use existing Node type
        })
    }

    // ADDED: @MainActor to isolate this method to the main thread
    @MainActor
    public func addToggleChild(to parentID: NodeID) async {
        Self.logger.debugLog("Adding toggle child to parent ID: \(parentID.uuidString.prefix(8))")
        await addChildInternal(to: parentID, createChild: { label, position in
            ToggleNode(label: label, position: position)  // Use existing ToggleNode type
        })
    }
    
    // ADDED: @MainActor to isolate this method to the main thread
    @MainActor
    // Private helper to avoid duplication (handles common logic like offsets, edges, and childOrder updates)
    private func addChildInternal(to parentID: NodeID, createChild: (Int, CGPoint) -> some NodeProtocol) async {
        pushUndo()
        let newLabel = nextNodeLabel
        nextNodeLabel += 1
        guard let parentIndex = nodes.firstIndex(where: { $0.id == parentID }) else { return }
        let parentPosition = nodes[parentIndex].position
        let offsetX = CGFloat.random(in: -50...50)  // Random for natural spread
        let offsetY = CGFloat.random(in: -50...50)
        let newPosition = CGPoint(x: parentPosition.x + offsetX, y: parentPosition.y + offsetY)
        
        // Create the child using the provided factory (leverages existing types)
        let child = createChild(newLabel, newPosition)
        let newNode = AnyNode(child)
        nodes.append(newNode)
        edges.append(GraphEdge(from: parentID, target: newNode.id, type: .hierarchy))
        
        // If parent is ToggleNode, append to its children and childOrder
        if var parentToggle = nodes[parentIndex].unwrapped as? ToggleNode {
            if !parentToggle.children.contains(newNode.id) {  // Avoid duplicates
                parentToggle.children.append(newNode.id)
                parentToggle.childOrder.append(newNode.id)  // Append to maintain initial order
                nodes[parentIndex] = AnyNode(parentToggle)
            }
        }
        
        objectWillChange.send()
        await resumeSimulation()
    }
    
    // ADDED: @MainActor to isolate this method to the main thread
    @MainActor
    public func deleteNode(withID id: NodeID) async {
        // CHANGED: Qualified
        Self.logger.debugLog("Deleting node with ID: \(id.uuidString.prefix(8))")  // Added debug log
        pushUndo()
        nodes.removeAll { $0.id == id }
        edges.removeAll { $0.from == id || $0.target == id }
        objectWillChange.send()
        await resumeSimulation()
    }

    // ADDED: @MainActor to isolate this method to the main thread
    @MainActor
    public func updateNodeContents(withID id: NodeID, newContents: [NodeContent]) async {
        // CHANGED: Qualified
        Self.logger.debugLog("Updating contents for node ID: \(id.uuidString.prefix(8))")  // Added debug log
        pushUndo()
        if let index = nodes.firstIndex(where: { $0.id == id }) {
            var updated = nodes[index].unwrapped
            updated.contents = newContents
            nodes[index] = AnyNode(updated)
            objectWillChange.send()
            await resumeSimulation()
        }
    }

    // ADDED: @MainActor to isolate this method to the main thread
    @MainActor
    public func deleteSelected(selectedNodeID: NodeID?, selectedEdgeID: UUID?) async {
        // CHANGED: Qualified
        Self.logger.debugLog("Deleting selected: node=\(selectedNodeID?.uuidString.prefix(8) ?? "nil"), edge=\(selectedEdgeID?.uuidString.prefix(8) ?? "nil")")  // Added debug log
        pushUndo()
        if let id = selectedEdgeID {
            edges.removeAll { $0.id == id }
        } else if let id = selectedNodeID {
            nodes.removeAll { $0.id == id }
            edges.removeAll { $0.from == id || $0.target == id }
        }
        objectWillChange.send()
        await resumeSimulation()
    }

    // ADDED: @MainActor to isolate this method to the main thread
    @MainActor
    public func toggleExpansion(for nodeID: NodeID) async {
        // CHANGED: Qualified
        Self.logger.debugLog("Toggling expansion for node ID: \(nodeID.uuidString.prefix(8))")  // Added debug log
        pushUndo()
        guard let idx = nodes.firstIndex(where: { $0.id == nodeID }), let toggle = nodes[idx].unwrapped as? ToggleNode else { return }
        let updated = toggle.handlingTap()
        nodes[idx] = AnyNode(updated)
        objectWillChange.send()
        await resumeSimulation()
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+Helpers.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Helpers.swift
Last modified: 2025-11-06 14:22:57

Contents:
//
//  GraphModel+Helpers.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    public func resetGraph() async {
        nodes.removeAll()
        edges.removeAll()
        nextNodeLabel = 1  // Reset label counter
        undoStack.removeAll()
        redoStack.removeAll()
        objectWillChange.send()
        await startSimulation()  // Or resume if needed
    }
    
    func buildAdjacencyList(for edgeType: EdgeType? = nil) -> [NodeID: [NodeID]] {
        var adj = [NodeID: [NodeID]]()
        let filteredEdges = edgeType != nil ? edges.filter { $0.type == edgeType! } : edges
        for edge in filteredEdges {
            adj[edge.from, default: []].append(edge.target)
        }
        return adj
    }

    private func dfsVisible(node: any NodeProtocol, adjacency: [NodeID: [NodeID]], visited: inout Set<NodeID>, visible: inout [any NodeProtocol]) {
        visited.insert(node.id)
        visible.append(node)
        if !node.isExpanded { return }
        if let children = adjacency[node.id] {
            for childID in children {
                if !visited.contains(childID), let child = nodes.first(where: { $0.id == childID })?.unwrapped {
                    dfsVisible(node: child, adjacency: adjacency, visited: &visited, visible: &visible)
                }
            }
        }
    }

    public func isBidirectionalBetween(_ id1: NodeID, _ id2: NodeID) -> Bool {
        edges.contains(where: { $0.from == id1 && $0.target == id2 }) &&
        edges.contains(where: { $0.from == id2 && $0.target == id1 })
    }

    public func edgesBetween(_ id1: NodeID, _ id2: NodeID) -> [GraphEdge] {
        edges.filter { ($0.from == id1 && $0.target == id2) || ($0.from == id2 && $0.target == id1) }
    }

    public func handleTap(on nodeID: NodeID) async {
        guard let index = nodes.firstIndex(where: { $0.id == nodeID }) else {
            print("handleTap: Index not found for ID \(nodeID)")
            return
        }
        let oldNode = nodes[index]
        print("handleTap: Pre-handlingTap - old isExpanded: \((oldNode.unwrapped as? ToggleNode)?.isExpanded.description ?? "not ToggleNode")")  // Check initial

        let updatedNode = oldNode.handlingTap()
        print("handleTap: Post-handlingTap - updated isExpanded: \((updatedNode.unwrapped as? ToggleNode)?.isExpanded.description ?? "not ToggleNode")")  // Key: Should be toggled, but won't be

        nodes[index] = updatedNode
        print("handleTap: Post-assignment - model.nodes[\(index)] isExpanded: \((nodes[index].unwrapped as? ToggleNode)?.isExpanded.description ?? "not ToggleNode")")  // Verify stuck in model

        let children = edges.filter { $0.from == nodeID && $0.type == EdgeType.hierarchy }.map { $0.target }
        if let toggleNode = updatedNode.unwrapped as? ToggleNode {
            print("handleTap: Entered if-let - toggleNode isExpanded: \(toggleNode.isExpanded)")  // Will print false, enters else
            if toggleNode.isExpanded {
                print("handleTap: Running expand block")
                for childID in children {
                                    guard let childIndex = nodes.firstIndex(where: { $0.id == childID }) else { continue }
                                    var child = nodes[childIndex]
                                    let offsetX = CGFloat.random(in: -Constants.App.nodeModelRadius * 3 ... Constants.App.nodeModelRadius * 3)
                                    let offsetY = CGFloat.random(in: Constants.App.nodeModelRadius * 2 ... Constants.App.nodeModelRadius * 4)
                                    child.position = toggleNode.position + CGPoint(x: offsetX, y: offsetY)
                                    child.velocity = .zero
                                    nodes[childIndex] = child
                                }
                                physicsEngine.temporaryDampingBoost(steps: Constants.Physics.maxSimulationSteps / 10)
            } else {
                print("handleTap: Running collapse block")
                for childID in children {
                    guard let childIndex = nodes.firstIndex(where: { $0.id == childID }) else { continue }
                    var child = nodes[childIndex]
                    child.position = toggleNode.position
                    child.velocity = .zero
                    nodes[childIndex] = child
                }
            }
        } else {
            print("handleTap: Cast to ToggleNode failed on updatedNode")
        }

        objectWillChange.send()
        let unwrappedNodes = nodes.map { $0.unwrapped }
        let updatedUnwrapped = physicsEngine.runSimulation(steps: 20, nodes: unwrappedNodes, edges: edges)
        nodes = updatedUnwrapped.map { AnyNode($0) }
        print("handleTap: Post-simulation - model.nodes[\(index)] isExpanded: \((nodes[index].unwrapped as? ToggleNode)?.isExpanded.description ?? "not ToggleNode")")  // Check if sim overwrote

        await resumeSimulation()
    }
    
    public func graphDescription(selectedID: NodeID?, selectedEdgeID: UUID?) -> String {
        let edgeCount = edges.count
        let edgeWord = edgeCount == 1 ? "edge" : "edges"
        var desc = "Graph with \(nodes.count) nodes and \(edgeCount) directed \(edgeWord)."
        if let selectedEdgeID = selectedEdgeID, let selectedEdge = edges.first(where: { $0.id == selectedEdgeID }),
           let fromNode = nodes.first(where: { $0.id == selectedEdge.from })?.unwrapped,
           let toNode = nodes.first(where: { $0.id == selectedEdge.target })?.unwrapped {
            desc += " Directed edge from node \(fromNode.label) to node \(toNode.label) selected."
        } else if let selectedID = selectedID, let selectedNode = nodes.first(where: { $0.id == selectedID })?.unwrapped {
            let outgoingLabels = edges
                .filter { $0.from == selectedID }
                .compactMap { edge in
                    let targetID = edge.target
                    return nodes.first { $0.id == targetID }?.unwrapped.label
                }
                .sorted()
                .map { String($0) }
                .joined(separator: ", ")
            let incomingLabels = edges
                .filter { $0.target == selectedID }
                .compactMap { edge in
                    let fromID = edge.from
                    return nodes.first { $0.id == fromID }?.unwrapped.label
                }
                .sorted()
                .map { String($0) }
                .joined(separator: ", ")
            let outgoingText = outgoingLabels.isEmpty ? "none" : outgoingLabels
            let incomingText = incomingLabels.isEmpty ? "none" : incomingLabels
            desc += " Node \(selectedNode.label) selected, outgoing to: \(outgoingText); incoming from: \(incomingText)."
        } else {
            desc += " No node or edge selected."
        }
        return desc
    }
    
    public var centroid: CGPoint? {
        GraphEditorShared.centroid(of: visibleNodes())
    }
    
    public func sortChildren<ComparableValue: Comparable>(of nodeID: NodeID, by keyPath: KeyPath<any NodeProtocol, ComparableValue>) async {
        guard let index = nodes.firstIndex(where: { $0.id == nodeID }),
              let toggleNode = nodes[index].unwrapped as? ToggleNode else {
            // Skip if not ToggleNode
            return
        }
        
        pushUndo()  // Allow undo of sorting
        let sortedOrder = toggleNode.children.sorted { childID1, childID2 in
            guard let node1 = nodes.first(where: { $0.id == childID1 })?.unwrapped,
                  let node2 = nodes.first(where: { $0.id == childID2 })?.unwrapped else {
                return false  // Stable sort if nodes missing
            }
            return node1[keyPath: keyPath] < node2[keyPath: keyPath]
        }
        
        let updated = toggleNode.with(childOrder: sortedOrder)
        nodes[index] = AnyNode(updated)
        objectWillChange.send()
        await resumeSimulation()  // Re-simulate for layout adjustments
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+Simulation.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Simulation.swift
Last modified: 2025-11-10 23:32:45

Contents:
//
//  GraphModel+Simulation.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation
import os  // ADDED: For Logger

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    private static let logger = Logger.forCategory("graphmodel-simulation")  // ADDED: Local static logger for this extension

    // ADDED: @MainActor to isolate this method to the main thread
    @MainActor
    public func startSimulation() async {
        Self.logger.infoLog("Starting simulation")  // Qualified with Self
        isSimulating = true
        isStable = false
        await simulator.startSimulation()
    }

    // ADDED: @MainActor to isolate this method to the main thread
    @MainActor
    public func pauseSimulation() async {
        Self.logger.debugLog("Pausing simulation")  // Qualified with Self
        physicsEngine.isPaused = true
    }

    // ADDED: @MainActor to isolate this method to the main thread
    @MainActor
    public func resumeSimulation() async {
        Self.logger.debugLog("Resuming simulation")  // Qualified with Self
        physicsEngine.isPaused = false
        if await simulator.simulationTask == nil {
            await startSimulation()
        }
    }

    // ADDED: @MainActor to isolate this method to the main thread
    @MainActor
    public func stopSimulation() async {
        Self.logger.infoLog("Stopping simulation")  // Qualified with Self
        await simulator.stopSimulation()
        isSimulating = false
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+Storage.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Storage.swift
Last modified: 2025-10-25 20:18:48

Contents:
//
//  GraphModel+Storage.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation
import CoreGraphics
import os  // Added for Logger

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    private static let logger = Logger.forCategory("graphmodel-storage")  // ADDED: Define local static logger for this extension

    private func syncCollapsedPositions() {
        for parentIndex in 0..<nodes.count {
            if let toggle = nodes[parentIndex].unwrapped as? ToggleNode, !toggle.isExpanded {
                let children = edges.filter { $0.from == nodes[parentIndex].id && $0.type == .hierarchy }.map { $0.target }
                for (index, childID) in children.enumerated() {
                    guard let childIndex = nodes.firstIndex(where: { $0.id == childID }) else { continue }
                    var child = nodes[childIndex]
                    let angle = CGFloat(index) * (2 * .pi / CGFloat(children.count))
                    let jitterX = cos(angle) * 5.0
                    let jitterY = sin(angle) * 5.0
                    child.position = nodes[parentIndex].position + CGPoint(x: jitterX, y: jitterY)
                    child.velocity = .zero
                    nodes[childIndex] = child
                }
            }
        }
        objectWillChange.send()
    }

    private func loadFromStorage(for name: String) async throws {
        Self.logger.infoLog("loadFromStorage started for \(name)")
        do {
            let (loadedNodes, loadedEdges) = try await storage.load(for: name)
            Self.logger.infoLog("loadFromStorage: loaded \(loadedNodes.count) nodes, \(loadedEdges.count) edges for \(name)")
            self.nodes = loadedNodes.map { AnyNode($0) }
            self.edges = loadedEdges
            self.nextNodeLabel = (nodes.map { $0.unwrapped.label }.max() ?? 0) + 1
        } catch {
            Self.logger.errorLog("loadFromStorage failed for \(name)", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation with custom error
        }
    }
    
    public func load() async {
        Self.logger.infoLog("GraphModel.load() called")
        do {
            try await loadFromStorage(for: currentGraphName)
            syncCollapsedPositions()
            if let viewState = try storage.loadViewState(for: currentGraphName) {
                Self.logger.infoLog("Loaded view state: offset \(viewState.offset), zoom \(viewState.zoomScale)")
            }
            Self.logger.infoLog("GraphModel.load() succeeded; nodes: \(nodes.count), edges: \(edges.count)")
        } catch {
            Self.logger.errorLog("GraphModel.load() failed: \(error.localizedDescription)", error: error)
        }
    }
    
    public func save() async throws {
        Self.logger.infoLog("GraphModel.save() called; nodes: \(nodes.count), edges: \(edges.count)")
        do {
            try await storage.save(nodes: nodes.map { $0.unwrapped }, edges: edges, for: currentGraphName)
            Self.logger.infoLog("GraphModel.save() succeeded")
        } catch {
            Self.logger.errorLog("GraphModel.save() failed: \(error.localizedDescription)", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation
        }
    }

    public func clearGraph() async {
        Self.logger.infoLog("clearGraph called")
        nodes = []
        edges = []
        nextNodeLabel = 1
        do {
            try await storage.deleteGraph(name: currentGraphName)
            Self.logger.infoLog("clearGraph succeeded")
        } catch {
            Self.logger.errorLog("clearGraph failed: \(error.localizedDescription)", error: error)
        }
        objectWillChange.send()
    }
    
    // Multi-graph methods (integrated into Storage extension)
    /// Loads the current graph (based on currentGraphName); defaults to empty if not found.
    public func loadGraph() async {
        do {
            try await loadFromStorage(for: currentGraphName)
            nextNodeLabel = (nodes.map { $0.label }.max() ?? 0) + 1
            Self.logger.infoLog("Loaded graph '\(self.currentGraphName)' with \(self.nodes.count) nodes and \(self.edges.count) edges")
            objectWillChange.send()
        } catch GraphStorageError.graphNotFound(_) {
            nodes = []
            edges = []
            nextNodeLabel = 1
            Self.logger.warning("Graph '\(self.currentGraphName)' not found; starting empty")
        } catch {
            nodes = []
            edges = []
            nextNodeLabel = 1
            Self.logger.errorLog("Failed to load graph '\(self.currentGraphName)'", error: error)
        }
    }
    
    /// Saves the current graph state under currentGraphName.
    public func saveGraph() async throws {
        do {
            try await save()
            Self.logger.infoLog("Saved graph '\(self.currentGraphName)'")
        } catch {
            Self.logger.errorLog("Failed to save graph '\(self.currentGraphName)'", error: error)
            throw GraphError.storageFailure(error.localizedDescription)
        }
    }
    
    /// Creates a new empty graph with the given name and switches to it.
    public func createNewGraph(name: String) async throws {
        do {
            try await storage.createNewGraph(name: name)
            currentGraphName = name
            nodes = []
            edges = []
            nextNodeLabel = 1
            undoStack = []
            redoStack = []
            objectWillChange.send()
            Self.logger.infoLog("Created and switched to new graph '\(name)'")
        } catch {
            Self.logger.errorLog("Failed to create graph '\(name)'", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation
        }
    }
    
    /// Loads a specific graph by name and switches to it.
    public func loadGraph(name: String) async {
        currentGraphName = name
        await loadGraph()
    }
    
    /// Deletes the graph with the given name (if not current, no change to model).
    public func deleteGraph(name: String) async throws {
        do {
            try await storage.deleteGraph(name: name)
            if name == currentGraphName {
                currentGraphName = "default"
                await loadGraph()
            }
            Self.logger.infoLog("Deleted graph '\(name)'")
        } catch {
            Self.logger.errorLog("Failed to delete graph '\(name)'", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation
        }
    }
    
    /// Lists all available graph names.
    public func listGraphNames() async throws -> [String] {
        do {
            return try await storage.listGraphNames()
        } catch {
            Self.logger.errorLog("Failed to list graph names", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation
        }
    }
    
    public func saveViewState(offset: CGPoint, zoomScale: CGFloat, selectedNodeID: UUID?, selectedEdgeID: UUID?) async throws {
        let viewState = ViewState(offset: offset, zoomScale: zoomScale, selectedNodeID: selectedNodeID, selectedEdgeID: selectedEdgeID)
        do {
            try storage.saveViewState(viewState, for: currentGraphName)
        } catch {
            Self.logger.errorLog("Failed to save view state for '\(currentGraphName)'", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation
        }
    }

    public func loadViewState() async throws -> ViewState? {
        do {
            return try storage.loadViewState(for: currentGraphName)
        } catch {
            Self.logger.errorLog("Failed to load view state for '\(currentGraphName)'", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation
        }
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+TreeSupport.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+TreeSupport.swift
Last modified: 2025-11-06 09:34:31

Contents:
//
//  GraphModel+TreeSupport.swift
//  GraphEditorShared
//
//  Created by handcart on 10/27/25.
//

import Foundation
import Combine  // If needed
import os

extension GraphModel {
    // Removed stored properties—now in main class

    // Tree validation (unchanged, but confirmed working)
    public func isTree() -> Bool {
        guard !nodes.isEmpty else { return true }
        var incomingCounts = Dictionary(nodes.map { ($0.id, 0) }, uniquingKeysWith: { $1 })
        for edge in edges {
            incomingCounts[edge.target, default: 0] += 1
        }
        let roots = nodes.filter { incomingCounts[$0.id] == 0 }
        if roots.count != 1 { return false }  // Single root

        var visited = Set<UUID>()
        var stack = [roots[0].id]
        while !stack.isEmpty {
            let current = stack.removeLast()
            if visited.contains(current) { return false }  // Cycle
            visited.insert(current)
            let children = edges.filter { $0.from == current }.map { $0.target }
            stack.append(contentsOf: children)
        }
        return visited.count == nodes.count  // Connected
    }

    // Mode-enforced addEdge (unchanged)
    public func addEdge(source: UUID, target: UUID) {
        if mode == .tree {
            let tempEdge = GraphEdge(from: source, target: target)
            edges.append(tempEdge)
            if !isTree() {
                edges.removeLast()
                return
            }
            edges.removeLast()
        }
        let edge = GraphEdge(from: source, target: target)
        edges.append(edge)
        objectWillChange.send()
        changesPublisher.send()
    }

    // Updated bulkCollapseAll: No casting needed with protocol inheritance; mutate directly
    public func bulkCollapseAll() {
        for nodeIndex in 0..<nodes.count {
            nodes[nodeIndex].bulkCollapse()  // Direct call—types now compatible
            let childIds = nodes[nodeIndex].children
            for childId in childIds {
                if let childIndex = nodes.firstIndex(where: { $0.id == childId }) {
                    nodes[childIndex].bulkCollapse()  // Direct mutation
                }
            }
        }
        objectWillChange.send()
        changesPublisher.send()
    }

    // Auto-save hook (unchanged)
    private func saveState() {
        changesPublisher.send()
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+Undo.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Undo.swift
Last modified: 2025-10-25 20:18:44

Contents:
//
//  GraphModel+Undo.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation
import os

struct UndoGraphState {
    let nodes: [AnyNode]
    let edges: [GraphEdge]
    let nextLabel: Int
}

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    private static let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "graphmodel_undo")
    
    internal func pushUndo() {
        undoStack.append(currentState())
        if undoStack.count > maxUndo { undoStack.removeFirst() }
        redoStack = []
    }
    
    private func currentState() -> UndoGraphState {
        UndoGraphState(nodes: nodes, edges: edges, nextLabel: nextNodeLabel)
    }
    
    public func undo(resume: Bool = true) async {
        if let state = undoStack.popLast() {
            redoStack.append(currentState())
            nodes = state.nodes
            edges = state.edges
            nextNodeLabel = state.nextLabel
            objectWillChange.send()
            if resume {
                await resumeSimulation()
            }
        }
    }
    
    public func redo(resume: Bool = true) async {
        if let state = redoStack.popLast() {
            undoStack.append(currentState())
            nodes = state.nodes
            edges = state.edges
            nextNodeLabel = state.nextLabel
            objectWillChange.send()
            if resume {
                await resumeSimulation()
            }
        }
    }
    
    public func snapshot() async {
        Self.logger.debug("snapshot() called from: \(#function), nodes: \(self.nodes.count), edges: \(self.edges.count)")  // Use debug for transient info
        let state = UndoGraphState(nodes: nodes, edges: edges, nextLabel: nextNodeLabel)
        undoStack.append(state)
        if undoStack.count > maxUndo { undoStack.removeFirst() }
        redoStack.removeAll()
        
        // Handle auto-save with error logging (fixes warning on await save())
        do {
            try await save()  // Use 'try await' here
        } catch {
            let logger = Logger.forCategory("graphmodel")  // From your standardized logging
            logger.errorLog("Auto-save failed during snapshot", error: error)
            // Optional: If you want user feedback, set viewModel.errorMessage here (e.g., via NotificationCenter)
        }
        
        Self.logger.debug("snapshot() completed; undoStack size: \(self.undoStack.count)")
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+Visibility.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Visibility.swift
Last modified: 2025-10-03 10:02:52

Contents:
//
//  GraphModel+Visibility.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    public func visibleNodes() -> [any NodeProtocol] {
        let hidden = hiddenNodeIDs
        return nodes.map { $0.unwrapped }.filter { !hidden.contains($0.id) }
    }

    public func visibleEdges() -> [GraphEdge] {
        let hidden = hiddenNodeIDs
        return edges.filter { !hidden.contains($0.from) && !hidden.contains($0.target) }
    }

    public func boundingBox() -> CGRect {
        self.physicsEngine.boundingBox(nodes: nodes.map { $0.unwrapped })
    }

    public func centerGraph() {
        let centered = physicsEngine.centerNodes(nodes: nodes.map { $0.unwrapped })
        nodes = centered.map { AnyNode($0) }
        objectWillChange.send()
    }

    public func expandAllRoots() async {
        for var root in buildRoots() {
            root.isExpanded = true
            if let index = nodes.firstIndex(where: { $0.id == root.id }) {
                nodes[index] = AnyNode(root)
            }
        }
        objectWillChange.send()
    }

    private func buildRoots() -> [any NodeProtocol] {
        var incoming = Set<NodeID>()
        for edge in edges {
            incoming.insert(edge.target)
        }
        return nodes.filter { !incoming.contains($0.id) }.map { $0.unwrapped }
    }
}
----------------------------------------------------------------------------------------------------
File: GraphSimulator.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphSimulator.swift
Last modified: 2025-11-11 00:04:25

Contents:
//
//  GraphSimulator.swift
//  GraphEditorShared
//
//  Created by handcart on 8/12/25.
//

import Foundation
import os  // For logging and signposts

#if os(watchOS)
import WatchKit  // Only if using haptics; otherwise remove
#endif

@available(iOS 16.0, watchOS 6.0, *)
actor GraphSimulator {
    private let logger = Logger.forCategory("graphsimulator")  // Added: Define logger instance
    
    #if DEBUG
    private let signposter: OSSignposter = {
        let subsystem = "io.handcart.GraphEditor"  // Match your app's subsystem
        return OSSignposter(subsystem: subsystem, category: "graphsimulator")
    }()
    #endif

    var simulationTask: Task<Void, Never>?  // Exposed for testing
    private var recentVelocities: [CGFloat] = []  // Changed from internal to private (actor isolates it)
    let velocityChangeThreshold: CGFloat
    let velocityHistoryCount: Int
    let baseInterval: TimeInterval  // Now configurable
    
    let physicsEngine: PhysicsEngine
    private let getVisibleNodes: () async -> [any NodeProtocol]
    private let getVisibleEdges: () async -> [GraphEdge]
    
    private let getNodes: () async -> [any NodeProtocol]  // Changed from internal to private
    private let setNodes: ([any NodeProtocol]) async -> Void  // Updated: Polymorphic
    private let getEdges: () async -> [GraphEdge]
    private let onStable: (() -> Void)?  // New: Optional callback
    
    private let onPostStable: (() -> Void)?
    private let postStableDelay: TimeInterval
    
    private let bypassAppCheck: Bool  // Flag to skip watchOS app state check in tests
        private let testStepDelay: TimeInterval?  // Optional delay per step for test slowing

        init(getNodes: @escaping () async -> [any NodeProtocol],
             setNodes: @escaping ([any NodeProtocol]) async -> Void,
             getEdges: @escaping () async -> [GraphEdge],
             getVisibleNodes: @escaping () async -> [any NodeProtocol],
             getVisibleEdges: @escaping () async -> [GraphEdge],
             physicsEngine: PhysicsEngine,
             onStable: (() -> Void)? = nil,
             onPostStable: (() -> Void)? = nil,
             postStableDelay: TimeInterval = 5.0,
             baseInterval: TimeInterval = 1.0 / 30.0,
             velocityChangeThreshold: CGFloat = 0.01,
             velocityHistoryCount: Int = 5,
             bypassAppCheck: Bool = false,  // ADDED: Default false (normal behavior)
             testStepDelay: TimeInterval? = nil) {  // ADDED: Default nil (no delay)
        self.getNodes = getNodes
        self.setNodes = setNodes
        self.getEdges = getEdges
        self.physicsEngine = physicsEngine
        self.onStable = onStable
        
        self.getVisibleNodes = getVisibleNodes
        self.getVisibleEdges = getVisibleEdges
        
        self.baseInterval = baseInterval
        self.velocityChangeThreshold = velocityChangeThreshold
        self.velocityHistoryCount = velocityHistoryCount
        
        self.onPostStable = onPostStable
        self.postStableDelay = postStableDelay
            self.bypassAppCheck = bypassAppCheck
                    self.testStepDelay = testStepDelay
    }
    
    struct SimulationStepResult {
        let updatedNodes: [any NodeProtocol]
        let shouldContinue: Bool
        let totalVelocity: CGFloat
    }
    
    func startSimulation() async {
#if os(watchOS)
        if !bypassAppCheck {  // ADDED: Only check if not bypassed
            let appState = await WKApplication.shared().applicationState
            guard appState == .active else { return }
        }
    #endif
        physicsEngine.resetSimulation()
        recentVelocities.removeAll()
        
        let nodeCount = await getNodes().count
        if nodeCount < 5 {
            onStable?()  // NEW: Call here to handle "already stable" cases
            return
        }
        
        var adjustedInterval = baseInterval
        if nodeCount >= 20 {
            adjustedInterval = nodeCount < 50 ? 1.0 / 15.0 : 1.0 / 10.0
        }
        if ProcessInfo.processInfo.isLowPowerModeEnabled {
            adjustedInterval *= 2.0
        }
        
        simulationTask = Task {
            await self.runSimulationLoop(baseInterval: adjustedInterval, nodeCount: nodeCount)
            self.simulationTask = nil  // Clear after completion (moved inside Task)
        }
    }
    
    // ADDED: Now async (actor-isolated)
    func stopSimulation() async {
        simulationTask?.cancel()
        simulationTask = nil
    }
    
    // ADDED: Now async (actor-isolated)
    private func runSimulationLoop(baseInterval: TimeInterval, nodeCount: Int) async {
        let startTime = Date()
        #if DEBUG
        let loopState = signposter.beginInterval("SimulationLoop", "Nodes: \(nodeCount)")
        #endif
        
        let maxIterations = 500  // Arbitrary limit to prevent infinite loops
        var iterations = 0
        
        while !Task.isCancelled && iterations < maxIterations {
            // ADDED: Optional test delay for slowing loop (e.g., for reliability)
            if let delay = testStepDelay {
                            try? await Task.sleep(for: .milliseconds(Int(delay * 1000)))
                        } else {
                            try? await Task.sleep(for: .seconds(baseInterval))
                        }
            if physicsEngine.isPaused {
                try? await Task.sleep(for: .milliseconds(100))
                continue
            }
            let shouldContinue = await performSimulationStep(baseInterval: baseInterval, nodeCount: nodeCount)
            physicsEngine.alpha *= (1 - Constants.Physics.alphaDecay)
            iterations += 1
            logger.debug("Iteration \(iterations): shouldContinue = \(shouldContinue)")
            if !shouldContinue {
                logger.info("Simulation stabilized after \(iterations) iterations")
                #if DEBUG
                signposter.endInterval("SimulationLoop", loopState, "Stabilized after \(iterations) iterations")
                #endif
                break
            }
        }
        
        if iterations < maxIterations && !Task.isCancelled {
            logger.info("Simulation stabilized; waiting \(self.postStableDelay)s for inactivity pause")
            try? await Task.sleep(for: .seconds(postStableDelay))
            if !Task.isCancelled {
                onPostStable?()
            }
        }
        
        let duration = Date().timeIntervalSince(startTime)  // Added for perf
        if iterations >= maxIterations {
            logger.warning("Simulation timed out after \(iterations) iterations; recent velocities: \(self.recentVelocities); duration: \(duration)s")
            #if DEBUG
            signposter.endInterval("SimulationLoop", loopState, "Timed out after \(iterations) iterations")
            signposter.emitEvent("SimulationTimeout", "Recent velocities: \(self.recentVelocities)")
            #endif
        }
        self.onStable?()
    }

    private func performSimulationStep(baseInterval: TimeInterval, nodeCount: Int) async -> Bool {
    #if os(watchOS)
        let appState = await WKApplication.shared().applicationState
        if appState != .active { return false }
    #endif
        
        if physicsEngine.isPaused { return false }
        
        #if DEBUG
        let stepState = signposter.beginInterval("SimulationStep", "Nodes: \(nodeCount)")
        #endif
        
        let result: SimulationStepResult = await Task.detached {
            await self.computeSimulationStep()
        }.value
        logger.debug("Step: Total velocity = \(result.totalVelocity)")
        await self.setNodes(result.updatedNodes)
        
        recentVelocities.append(result.totalVelocity)
        if recentVelocities.count > velocityHistoryCount {
            recentVelocities.removeFirst()
        }
        
        let velocityChange = recentVelocities.max()! - recentVelocities.min()!
        let isStable = velocityChange < velocityChangeThreshold && recentVelocities.allSatisfy { $0 < 0.5 }
        
        #if DEBUG
        signposter.endInterval("SimulationStep", stepState, "Total velocity: \(result.totalVelocity), Stable: \(isStable)")
        #endif
        
        return !isStable
    }
    
    private func computeSimulationStep() async -> SimulationStepResult {
        let nodes = await getNodes()
        let edges = await getEdges()
        
        let (updatedNodes, isActive) = physicsEngine.simulationStep(nodes: nodes, edges: edges)
        let totalVelocity = updatedNodes.reduce(0.0) { $0 + hypot($1.velocity.x, $1.velocity.y) }
        
        return SimulationStepResult(updatedNodes: updatedNodes, shouldContinue: isActive, totalVelocity: totalVelocity)
    }
    
    private func shouldStopSimulation(result: SimulationStepResult, nodeCount: Int) async -> Bool {
        recentVelocities.append(result.totalVelocity)
        if recentVelocities.count > velocityHistoryCount {
            recentVelocities.removeFirst()
        }
        let velocityChange = recentVelocities.max()! - recentVelocities.min()!
        let isStable = velocityChange < velocityChangeThreshold && recentVelocities.allSatisfy { $0 < 0.5 }
        return isStable  // True if should stop (stable and low velocity)
    }
}
--------------------------------------------------
