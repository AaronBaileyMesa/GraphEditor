## Focused Project Concatenation
This file includes only UI, interactivity, model, and core logic files.
Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
Current date: 2025-11-08 13:41:16
Table of Contents:
1. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Storage.swift
2. GraphEditorShared/Sources/GraphEditorShared/GraphModel+TreeSupport.swift
3. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Undo.swift
4. GraphEditorShared/Sources/GraphEditorShared/GraphModel+Visibility.swift
5. GraphEditorShared/Sources/GraphEditorShared/GraphSimulator.swift
6. GraphEditorShared/Sources/GraphEditorShared/GraphTypes.swift
7. GraphEditorShared/Sources/GraphEditorShared/HitTestContext.swift--------------------------------------------------
File: GraphModel+Storage.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Storage.swift
Last modified: 2025-10-25 20:18:48

Contents:
//
//  GraphModel+Storage.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation
import CoreGraphics
import os  // Added for Logger

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    private static let logger = Logger.forCategory("graphmodel-storage")  // ADDED: Define local static logger for this extension

    private func syncCollapsedPositions() {
        for parentIndex in 0..<nodes.count {
            if let toggle = nodes[parentIndex].unwrapped as? ToggleNode, !toggle.isExpanded {
                let children = edges.filter { $0.from == nodes[parentIndex].id && $0.type == .hierarchy }.map { $0.target }
                for (index, childID) in children.enumerated() {
                    guard let childIndex = nodes.firstIndex(where: { $0.id == childID }) else { continue }
                    var child = nodes[childIndex]
                    let angle = CGFloat(index) * (2 * .pi / CGFloat(children.count))
                    let jitterX = cos(angle) * 5.0
                    let jitterY = sin(angle) * 5.0
                    child.position = nodes[parentIndex].position + CGPoint(x: jitterX, y: jitterY)
                    child.velocity = .zero
                    nodes[childIndex] = child
                }
            }
        }
        objectWillChange.send()
    }

    private func loadFromStorage(for name: String) async throws {
        Self.logger.infoLog("loadFromStorage started for \(name)")
        do {
            let (loadedNodes, loadedEdges) = try await storage.load(for: name)
            Self.logger.infoLog("loadFromStorage: loaded \(loadedNodes.count) nodes, \(loadedEdges.count) edges for \(name)")
            self.nodes = loadedNodes.map { AnyNode($0) }
            self.edges = loadedEdges
            self.nextNodeLabel = (nodes.map { $0.unwrapped.label }.max() ?? 0) + 1
        } catch {
            Self.logger.errorLog("loadFromStorage failed for \(name)", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation with custom error
        }
    }
    
    public func load() async {
        Self.logger.infoLog("GraphModel.load() called")
        do {
            try await loadFromStorage(for: currentGraphName)
            syncCollapsedPositions()
            if let viewState = try storage.loadViewState(for: currentGraphName) {
                Self.logger.infoLog("Loaded view state: offset \(viewState.offset), zoom \(viewState.zoomScale)")
            }
            Self.logger.infoLog("GraphModel.load() succeeded; nodes: \(nodes.count), edges: \(edges.count)")
        } catch {
            Self.logger.errorLog("GraphModel.load() failed: \(error.localizedDescription)", error: error)
        }
    }
    
    public func save() async throws {
        Self.logger.infoLog("GraphModel.save() called; nodes: \(nodes.count), edges: \(edges.count)")
        do {
            try await storage.save(nodes: nodes.map { $0.unwrapped }, edges: edges, for: currentGraphName)
            Self.logger.infoLog("GraphModel.save() succeeded")
        } catch {
            Self.logger.errorLog("GraphModel.save() failed: \(error.localizedDescription)", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation
        }
    }

    public func clearGraph() async {
        Self.logger.infoLog("clearGraph called")
        nodes = []
        edges = []
        nextNodeLabel = 1
        do {
            try await storage.deleteGraph(name: currentGraphName)
            Self.logger.infoLog("clearGraph succeeded")
        } catch {
            Self.logger.errorLog("clearGraph failed: \(error.localizedDescription)", error: error)
        }
        objectWillChange.send()
    }
    
    // Multi-graph methods (integrated into Storage extension)
    /// Loads the current graph (based on currentGraphName); defaults to empty if not found.
    public func loadGraph() async {
        do {
            try await loadFromStorage(for: currentGraphName)
            nextNodeLabel = (nodes.map { $0.label }.max() ?? 0) + 1
            Self.logger.infoLog("Loaded graph '\(self.currentGraphName)' with \(self.nodes.count) nodes and \(self.edges.count) edges")
            objectWillChange.send()
        } catch GraphStorageError.graphNotFound(_) {
            nodes = []
            edges = []
            nextNodeLabel = 1
            Self.logger.warning("Graph '\(self.currentGraphName)' not found; starting empty")
        } catch {
            nodes = []
            edges = []
            nextNodeLabel = 1
            Self.logger.errorLog("Failed to load graph '\(self.currentGraphName)'", error: error)
        }
    }
    
    /// Saves the current graph state under currentGraphName.
    public func saveGraph() async throws {
        do {
            try await save()
            Self.logger.infoLog("Saved graph '\(self.currentGraphName)'")
        } catch {
            Self.logger.errorLog("Failed to save graph '\(self.currentGraphName)'", error: error)
            throw GraphError.storageFailure(error.localizedDescription)
        }
    }
    
    /// Creates a new empty graph with the given name and switches to it.
    public func createNewGraph(name: String) async throws {
        do {
            try await storage.createNewGraph(name: name)
            currentGraphName = name
            nodes = []
            edges = []
            nextNodeLabel = 1
            undoStack = []
            redoStack = []
            objectWillChange.send()
            Self.logger.infoLog("Created and switched to new graph '\(name)'")
        } catch {
            Self.logger.errorLog("Failed to create graph '\(name)'", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation
        }
    }
    
    /// Loads a specific graph by name and switches to it.
    public func loadGraph(name: String) async {
        currentGraphName = name
        await loadGraph()
    }
    
    /// Deletes the graph with the given name (if not current, no change to model).
    public func deleteGraph(name: String) async throws {
        do {
            try await storage.deleteGraph(name: name)
            if name == currentGraphName {
                currentGraphName = "default"
                await loadGraph()
            }
            Self.logger.infoLog("Deleted graph '\(name)'")
        } catch {
            Self.logger.errorLog("Failed to delete graph '\(name)'", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation
        }
    }
    
    /// Lists all available graph names.
    public func listGraphNames() async throws -> [String] {
        do {
            return try await storage.listGraphNames()
        } catch {
            Self.logger.errorLog("Failed to list graph names", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation
        }
    }
    
    public func saveViewState(offset: CGPoint, zoomScale: CGFloat, selectedNodeID: UUID?, selectedEdgeID: UUID?) async throws {
        let viewState = ViewState(offset: offset, zoomScale: zoomScale, selectedNodeID: selectedNodeID, selectedEdgeID: selectedEdgeID)
        do {
            try storage.saveViewState(viewState, for: currentGraphName)
        } catch {
            Self.logger.errorLog("Failed to save view state for '\(currentGraphName)'", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation
        }
    }

    public func loadViewState() async throws -> ViewState? {
        do {
            return try storage.loadViewState(for: currentGraphName)
        } catch {
            Self.logger.errorLog("Failed to load view state for '\(currentGraphName)'", error: error)
            throw GraphError.storageFailure(error.localizedDescription)  // Added propagation
        }
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+TreeSupport.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+TreeSupport.swift
Last modified: 2025-11-06 09:34:31

Contents:
//
//  GraphModel+TreeSupport.swift
//  GraphEditorShared
//
//  Created by handcart on 10/27/25.
//

import Foundation
import Combine  // If needed
import os

extension GraphModel {
    // Removed stored properties—now in main class

    // Tree validation (unchanged, but confirmed working)
    public func isTree() -> Bool {
        guard !nodes.isEmpty else { return true }
        var incomingCounts = Dictionary(nodes.map { ($0.id, 0) }, uniquingKeysWith: { $1 })
        for edge in edges {
            incomingCounts[edge.target, default: 0] += 1
        }
        let roots = nodes.filter { incomingCounts[$0.id] == 0 }
        if roots.count != 1 { return false }  // Single root

        var visited = Set<UUID>()
        var stack = [roots[0].id]
        while !stack.isEmpty {
            let current = stack.removeLast()
            if visited.contains(current) { return false }  // Cycle
            visited.insert(current)
            let children = edges.filter { $0.from == current }.map { $0.target }
            stack.append(contentsOf: children)
        }
        return visited.count == nodes.count  // Connected
    }

    // Mode-enforced addEdge (unchanged)
    public func addEdge(source: UUID, target: UUID) {
        if mode == .tree {
            let tempEdge = GraphEdge(from: source, target: target)
            edges.append(tempEdge)
            if !isTree() {
                edges.removeLast()
                return
            }
            edges.removeLast()
        }
        let edge = GraphEdge(from: source, target: target)
        edges.append(edge)
        objectWillChange.send()
        changesPublisher.send()
    }

    // Updated bulkCollapseAll: No casting needed with protocol inheritance; mutate directly
    public func bulkCollapseAll() {
        for nodeIndex in 0..<nodes.count {
            nodes[nodeIndex].bulkCollapse()  // Direct call—types now compatible
            let childIds = nodes[nodeIndex].children
            for childId in childIds {
                if let childIndex = nodes.firstIndex(where: { $0.id == childId }) {
                    nodes[childIndex].bulkCollapse()  // Direct mutation
                }
            }
        }
        objectWillChange.send()
        changesPublisher.send()
    }

    // Auto-save hook (unchanged)
    private func saveState() {
        changesPublisher.send()
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+Undo.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Undo.swift
Last modified: 2025-10-25 20:18:44

Contents:
//
//  GraphModel+Undo.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation
import os

struct UndoGraphState {
    let nodes: [AnyNode]
    let edges: [GraphEdge]
    let nextLabel: Int
}

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    private static let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "graphmodel_undo")
    
    internal func pushUndo() {
        undoStack.append(currentState())
        if undoStack.count > maxUndo { undoStack.removeFirst() }
        redoStack = []
    }
    
    private func currentState() -> UndoGraphState {
        UndoGraphState(nodes: nodes, edges: edges, nextLabel: nextNodeLabel)
    }
    
    public func undo(resume: Bool = true) async {
        if let state = undoStack.popLast() {
            redoStack.append(currentState())
            nodes = state.nodes
            edges = state.edges
            nextNodeLabel = state.nextLabel
            objectWillChange.send()
            if resume {
                await resumeSimulation()
            }
        }
    }
    
    public func redo(resume: Bool = true) async {
        if let state = redoStack.popLast() {
            undoStack.append(currentState())
            nodes = state.nodes
            edges = state.edges
            nextNodeLabel = state.nextLabel
            objectWillChange.send()
            if resume {
                await resumeSimulation()
            }
        }
    }
    
    public func snapshot() async {
        Self.logger.debug("snapshot() called from: \(#function), nodes: \(self.nodes.count), edges: \(self.edges.count)")  // Use debug for transient info
        let state = UndoGraphState(nodes: nodes, edges: edges, nextLabel: nextNodeLabel)
        undoStack.append(state)
        if undoStack.count > maxUndo { undoStack.removeFirst() }
        redoStack.removeAll()
        
        // Handle auto-save with error logging (fixes warning on await save())
        do {
            try await save()  // Use 'try await' here
        } catch {
            let logger = Logger.forCategory("graphmodel")  // From your standardized logging
            logger.errorLog("Auto-save failed during snapshot", error: error)
            // Optional: If you want user feedback, set viewModel.errorMessage here (e.g., via NotificationCenter)
        }
        
        Self.logger.debug("snapshot() completed; undoStack size: \(self.undoStack.count)")
    }
}
----------------------------------------------------------------------------------------------------
File: GraphModel+Visibility.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Visibility.swift
Last modified: 2025-10-03 10:02:52

Contents:
//
//  GraphModel+Visibility.swift
//  GraphEditorShared
//
//  Created by handcart on 9/19/25.
//
import Foundation

@available(iOS 16.0, watchOS 6.0, *)
extension GraphModel {
    public func visibleNodes() -> [any NodeProtocol] {
        let hidden = hiddenNodeIDs
        return nodes.map { $0.unwrapped }.filter { !hidden.contains($0.id) }
    }

    public func visibleEdges() -> [GraphEdge] {
        let hidden = hiddenNodeIDs
        return edges.filter { !hidden.contains($0.from) && !hidden.contains($0.target) }
    }

    public func boundingBox() -> CGRect {
        self.physicsEngine.boundingBox(nodes: nodes.map { $0.unwrapped })
    }

    public func centerGraph() {
        let centered = physicsEngine.centerNodes(nodes: nodes.map { $0.unwrapped })
        nodes = centered.map { AnyNode($0) }
        objectWillChange.send()
    }

    public func expandAllRoots() async {
        for var root in buildRoots() {
            root.isExpanded = true
            if let index = nodes.firstIndex(where: { $0.id == root.id }) {
                nodes[index] = AnyNode(root)
            }
        }
        objectWillChange.send()
    }

    private func buildRoots() -> [any NodeProtocol] {
        var incoming = Set<NodeID>()
        for edge in edges {
            incoming.insert(edge.target)
        }
        return nodes.filter { !incoming.contains($0.id) }.map { $0.unwrapped }
    }
}
----------------------------------------------------------------------------------------------------
File: GraphSimulator.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphSimulator.swift
Last modified: 2025-10-15 03:54:44

Contents:
//
//  GraphSimulator.swift
//  GraphEditorShared
//
//  Created by handcart on 8/12/25.
//

import Foundation
import os  // For logging and signposts

#if os(watchOS)
import WatchKit  // Only if using haptics; otherwise remove
#endif

@available(iOS 16.0, watchOS 6.0, *)
/// Manages physics simulation loops for graph updates.
class GraphSimulator {
    private let logger = Logger.forCategory("graphsimulator")  // Added: Define logger instance
    
    // NEW: Signposter for performance tracing
    #if DEBUG
    private let signposter: OSSignposter = {
        let subsystem = "io.handcart.GraphEditor"  // Match your app's subsystem
        return OSSignposter(subsystem: subsystem, category: "graphsimulator")
    }()
    #endif

    var simulationTask: Task<Void, Never>?  // Exposed for testing
    internal var recentVelocities: [CGFloat] = []  // Explicit internal for test access
    let velocityChangeThreshold: CGFloat
    let velocityHistoryCount: Int
    let baseInterval: TimeInterval  // Now configurable
    
    let physicsEngine: PhysicsEngine
    private let getVisibleNodes: () async -> [any NodeProtocol]
    private let getVisibleEdges: () async -> [GraphEdge]
    
    internal let getNodes: () async -> [any NodeProtocol]  // Changed from private to internal
    internal let setNodes: ([any NodeProtocol]) async -> Void  // Updated: Polymorphic
    private let getEdges: () async -> [GraphEdge]
    internal let onStable: (() -> Void)?  // New: Optional callback
    
    init(getNodes: @escaping () async -> [any NodeProtocol],
         setNodes: @escaping ([any NodeProtocol]) async -> Void,
         getEdges: @escaping () async -> [GraphEdge],
         getVisibleNodes: @escaping () async -> [any NodeProtocol],
         getVisibleEdges: @escaping () async -> [GraphEdge],
         physicsEngine: PhysicsEngine,
         onStable: (() -> Void)? = nil,
         baseInterval: TimeInterval = 1.0 / 30.0,  // Default value
         velocityChangeThreshold: CGFloat = 0.01,
         velocityHistoryCount: Int = 5) {
        self.getNodes = getNodes
        self.setNodes = setNodes
        self.getEdges = getEdges
        self.physicsEngine = physicsEngine
        self.onStable = onStable
        
        self.getVisibleNodes = getVisibleNodes
        self.getVisibleEdges = getVisibleEdges
        
        self.baseInterval = baseInterval
        self.velocityChangeThreshold = velocityChangeThreshold
        self.velocityHistoryCount = velocityHistoryCount
    }
    
    struct SimulationStepResult {
        let updatedNodes: [any NodeProtocol]
        let shouldContinue: Bool
        let totalVelocity: CGFloat
    }
    
    @MainActor
    func startSimulation() async {
    #if os(watchOS)
        guard WKApplication.shared().applicationState == .active else { return }
    #endif
        physicsEngine.resetSimulation()
        recentVelocities.removeAll()
        
        let nodeCount = await getNodes().count
        if nodeCount < 5 {
            onStable?()  // NEW: Call here to handle "already stable" cases
            return
        }
        
        var adjustedInterval = baseInterval
        if nodeCount >= 20 {
            adjustedInterval = nodeCount < 50 ? 1.0 / 15.0 : 1.0 / 10.0
        }
        if ProcessInfo.processInfo.isLowPowerModeEnabled {
            adjustedInterval *= 2.0
        }
        
        simulationTask = Task {
            await self.runSimulationLoop(baseInterval: adjustedInterval, nodeCount: nodeCount)
            self.simulationTask = nil  // Clear after completion (moved inside Task)
        }
    }
    
    func stopSimulation() async {
        simulationTask?.cancel()
        await simulationTask?.value
        simulationTask = nil  // Added: Clear task after stop
    }
    
    internal func runSimulationLoop(baseInterval: TimeInterval, nodeCount: Int) async {
        #if DEBUG
        let loopState = signposter.beginInterval("SimulationLoop", "Nodes: \(nodeCount)")
        #endif
        
        let startTime = Date()  // Added for perf logging
        logger.debug("Starting sim loop with nodeCount: \(nodeCount), maxIterations: 500")
        var iterations = 0
        let maxIterations = 500
        while !Task.isCancelled && iterations < maxIterations {
            if physicsEngine.isPaused {
                try? await Task.sleep(for: .milliseconds(100))
                continue
            }
            let shouldContinue = await performSimulationStep(baseInterval: baseInterval, nodeCount: nodeCount)
            physicsEngine.alpha *= (1 - Constants.Physics.alphaDecay)
            iterations += 1
            logger.debug("Iteration \(iterations): shouldContinue = \(shouldContinue)")
            if !shouldContinue {
                logger.info("Simulation stabilized after \(iterations) iterations")
                #if DEBUG
                signposter.endInterval("SimulationLoop", loopState, "Stabilized after \(iterations) iterations")
                #endif
                break
            }
        }
        let duration = Date().timeIntervalSince(startTime)  // Added for perf
        if iterations >= maxIterations {
            logger.warning("Simulation timed out after \(iterations) iterations; recent velocities: \(self.recentVelocities); duration: \(duration)s")
            #if DEBUG
            signposter.endInterval("SimulationLoop", loopState, "Timed out after \(iterations) iterations")
            signposter.emitEvent("SimulationTimeout", "Recent velocities: \(self.recentVelocities)")
            #endif
        }
        self.onStable?()
    }

    internal func performSimulationStep(baseInterval: TimeInterval, nodeCount: Int) async -> Bool {
    #if os(watchOS)
        if await WKApplication.shared().applicationState != .active { return false }
    #endif
        
        if physicsEngine.isPaused { return false }
        
        #if DEBUG
        let stepState = signposter.beginInterval("SimulationStep", "Nodes: \(nodeCount)")
        #endif
        
        let result: SimulationStepResult = await Task.detached {
            await self.computeSimulationStep()
        }.value
        logger.debug("Step: Total velocity = \(result.totalVelocity)")
        await self.setNodes(result.updatedNodes)
        
        recentVelocities.append(result.totalVelocity)
        if recentVelocities.count > velocityHistoryCount {
            recentVelocities.removeFirst()
        }
        
        let velocityChange = recentVelocities.max()! - recentVelocities.min()!
        let isStable = velocityChange < velocityChangeThreshold && recentVelocities.allSatisfy { $0 < 0.5 }
        
        #if DEBUG
        signposter.endInterval("SimulationStep", stepState, "Total velocity: \(result.totalVelocity), Stable: \(isStable)")
        #endif
        
        return !isStable
    }
    
    internal func computeSimulationStep() async -> SimulationStepResult {
        let nodes = await getNodes()
        let edges = await getEdges()
        
        let (updatedNodes, isActive) = physicsEngine.simulationStep(nodes: nodes, edges: edges)
        let totalVelocity = updatedNodes.reduce(0.0) { $0 + hypot($1.velocity.x, $1.velocity.y) }
        
        return SimulationStepResult(updatedNodes: updatedNodes, shouldContinue: isActive, totalVelocity: totalVelocity)
    }
    
    internal func shouldStopSimulation(result: SimulationStepResult, nodeCount: Int) -> Bool {
        recentVelocities.append(result.totalVelocity)
        if recentVelocities.count > velocityHistoryCount {
            recentVelocities.removeFirst()
        }
        let velocityChange = recentVelocities.max()! - recentVelocities.min()!
        let isStable = velocityChange < velocityChangeThreshold && recentVelocities.allSatisfy { $0 < 0.5 }
        return isStable  // True if should stop (stable and low velocity)
    }
}
----------------------------------------------------------------------------------------------------
File: GraphTypes.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphTypes.swift
Last modified: 2025-10-29 08:20:26

Contents:
//
//  GraphTypes.swift
//  GraphEditorShared
//
//  Created by handcart on 2025-09-19 13:45:29

import SwiftUI
import Foundation

public typealias NodeID = UUID

@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public struct Node: NodeProtocol {  // Updated: Conform to NodeProtocol (which now includes HierarchicalNode)
    public let id: NodeID
    public let label: Int
    public var position: CGPoint
    public var velocity: CGPoint = .zero
    public var radius: CGFloat = 10.0
    public var children: [UUID] = []
    public var isExpanded: Bool = true
    public var contents: [NodeContent] = []
    public var fillColor: Color { .red }

    // Init with all params
    public init(id: NodeID = NodeID(), label: Int, position: CGPoint, velocity: CGPoint = .zero, radius: CGFloat = 10.0, isExpanded: Bool = true, contents: [NodeContent] = []) {
        self.id = id
        self.label = label
        self.position = position
        self.velocity = velocity
        self.radius = radius
        self.isExpanded = isExpanded
        self.contents = contents
    }
    
    public func with(position: CGPoint, velocity: CGPoint) -> Self {
        Node(id: id, label: label, position: position, velocity: velocity, radius: radius, isExpanded: isExpanded, contents: contents)
    }
    
    public func with(position: CGPoint, velocity: CGPoint, contents: [NodeContent]) -> Self {
        Node(id: id, label: label, position: position, velocity: velocity, radius: radius, isExpanded: isExpanded, contents: contents)
    }
}

// Extension for methods only (no stored props)
extension Node {
    public mutating func collapse() {
        isExpanded = false
    }
    
    public mutating func bulkCollapse() {
        isExpanded = false
        // Recursion handled in GraphModel for full graph access
    }
}

// New: EdgeType enum
public enum EdgeType: String, Codable {
    case hierarchy  // DAG-enforced, directed
    case association  // Allows cycles, symmetric/undirected feel
}

// Represents an edge connecting two nodes.
public struct GraphEdge: Identifiable, Equatable, Codable {
    public let id: NodeID
    public let from: NodeID
    public let target: NodeID
    public let type: EdgeType  // Required type
    
    enum CodingKeys: String, CodingKey {
        case id, from, target, type
    }
    
    public init(id: NodeID = NodeID(), from: NodeID, target: NodeID, type: EdgeType = .association) {
        self.id = id
        self.from = from
        self.target = target
        self.type = type
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(NodeID.self, forKey: .id)
        from = try container.decode(NodeID.self, forKey: .from)
        target = try container.decode(NodeID.self, forKey: .target)
        type = try container.decode(EdgeType.self, forKey: .type)
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(from, forKey: .from)
        try container.encode(target, forKey: .target)
        try container.encode(type, forKey: .type)
    }
    
    public static func == (lhs: GraphEdge, rhs: GraphEdge) -> Bool {
        lhs.id == rhs.id && lhs.from == rhs.from && lhs.target == rhs.target && lhs.type == rhs.type
    }
}

// Snapshot of the graph state for undo/redo.
@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public struct GraphState {
    public let nodes: [any NodeProtocol]
    public let edges: [GraphEdge]
    
    public init(nodes: [any NodeProtocol], edges: [GraphEdge]) {
        self.nodes = nodes
        self.edges = edges
    }
}

@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public enum NodeWrapper: Codable {
    case node(Node)
    case toggleNode(ToggleNode)
    
    enum CodingKeys: String, CodingKey {
        case type, data
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(String.self, forKey: .type)
        switch type {
        case "node":
            let data = try container.decode(Node.self, forKey: .data)
            self = .node(data)
        case "toggleNode":
            let data = try container.decode(ToggleNode.self, forKey: .data)
            self = .toggleNode(data)
        default:
            throw DecodingError.dataCorruptedError(forKey: .type, in: container, debugDescription: "Unknown node type")
        }
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
        case .node(let node):
            try container.encode("node", forKey: .type)
            try container.encode(node, forKey: .data)
        case .toggleNode(let toggleNode):
            try container.encode("toggleNode", forKey: .type)
            try container.encode(toggleNode, forKey: .data)
        }
    }
    
    public var value: any NodeProtocol {
        switch self {
        case .node(let node): return node
        case .toggleNode(let toggleNode): return toggleNode
        }
    }
}

public enum GraphMode: Codable {  // Codable for saving
    case network  // General graphs, allows cycles/associations
    case tree     // Enforces acyclicity, hierarchy only
}

public protocol HierarchicalNode {
    var children: [UUID] { get set }
    var isExpanded: Bool { get set }
    mutating func collapse()  // Set isExpanded = false
    mutating func bulkCollapse()  // Recursive on children (needs graph access)
}
----------------------------------------------------------------------------------------------------
File: HitTestContext.swift
Path: GraphEditorShared/Sources/GraphEditorShared/HitTestContext.swift
Last modified: 2025-09-26 10:18:51

Contents:
// GraphEditorShared/Sources/GraphEditorShared/HitTestHelper.swift

import CoreGraphics
import os.log  // For standardized logging

private let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "hit_test")

/// Context for hit testing (matches GestureContext from GraphGesturesModifier).
public struct HitTestContext {
    public init(zoomScale: CGFloat, offset: CGSize, viewSize: CGSize, effectiveCentroid: CGPoint) {
          self.zoomScale = zoomScale
          self.offset = offset
          self.viewSize = viewSize
          self.effectiveCentroid = effectiveCentroid
      }
    
    public let zoomScale: CGFloat
    public let offset: CGSize
    public let viewSize: CGSize
    public let effectiveCentroid: CGPoint
}

/// Helper for performing hit tests on nodes and edges in screen space.
public struct HitTestHelper {
    
    /// Finds the closest node to a screen position, if within hit radius.
    /// - Returns: The closest node, or nil if none hit.
    public static func closestNode(at screenPos: CGPoint, visibleNodes: [any NodeProtocol], context: HitTestContext) -> (any NodeProtocol)? {
        var closest: (node: (any NodeProtocol)?, dist: CGFloat) = (nil, .infinity)
        let minHitRadius: CGFloat = 10.0  // Minimum tappable radius in screen points
        let padding: CGFloat = 5.0  // Extra forgiveness
        
        for node in visibleNodes {
            let safeZoom = max(context.zoomScale, 0.1)
            let nodeScreenPos = CoordinateTransformer.modelToScreen(
                node.position,
                effectiveCentroid: context.effectiveCentroid,
                zoomScale: safeZoom,
                offset: context.offset,
                viewSize: context.viewSize
            )
            let dist = hypot(screenPos.x - nodeScreenPos.x, screenPos.y - nodeScreenPos.y)
            let visibleRadius = node.radius * safeZoom
            let nodeHitRadius = max(minHitRadius, visibleRadius) + padding
            
            if dist <= nodeHitRadius && dist < closest.dist {
                closest = (node, dist)
            }
        }
        
        #if DEBUG
        if let node = closest.node {
            logger.debug("Hit closest node \(node.label) at dist \(closest.dist)")
        } else {
            logger.debug("No node hit at screen pos \(String(describing: screenPos))")
        }
        #endif
        
        return closest.node
    }
    
    /// Finds the closest edge to a screen position, if within hit radius.
    /// - Returns: The closest edge, or nil if none hit.
    public static func closestEdge(at screenPos: CGPoint, visibleEdges: [GraphEdge], visibleNodes: [any NodeProtocol], context: HitTestContext) -> GraphEdge? {
        var closest: (edge: GraphEdge?, dist: CGFloat) = (nil, .infinity)
        let hitScreenRadius: CGFloat = 10.0  // Adjustable; smaller for edges to avoid node overlap
        
        for edge in visibleEdges {
            guard let fromNode = visibleNodes.first(where: { $0.id == edge.from }),
                  let toNode = visibleNodes.first(where: { $0.id == edge.target }) else { continue }
            
            let safeZoom = max(context.zoomScale, 0.1)
            let fromScreen = CoordinateTransformer.modelToScreen(
                fromNode.position,
                effectiveCentroid: context.effectiveCentroid,
                zoomScale: safeZoom,
                offset: context.offset,
                viewSize: context.viewSize
            )
            let toScreen = CoordinateTransformer.modelToScreen(
                toNode.position,
                effectiveCentroid: context.effectiveCentroid,
                zoomScale: safeZoom,
                offset: context.offset,
                viewSize: context.viewSize
            )
            
            let dist = pointToLineDistance(point: screenPos, from: fromScreen, target: toScreen)
            
            if dist <= hitScreenRadius && dist < closest.dist {
                closest = (edge, dist)
            }
        }
        
        #if DEBUG
        if let edge = closest.edge {
            logger.debug("Hit closest edge \(edge.id.uuidString.prefix(8)) at dist \(closest.dist)")
        } else {
            logger.debug("No edge hit at screen pos \(String(describing: screenPos))")
        }
        #endif
        
        return closest.edge
    }
    
    // Helper: Distance from point to line segment (extracted for clarity; add if not already in utilities)
    public static func pointToLineDistance(point: CGPoint, from: CGPoint, target: CGPoint) -> CGFloat {
        let lineVec = CGVector(dx: target.x - from.x, dy: target.y - from.y)
        let pointVec = CGVector(dx: point.x - from.x, dy: point.y - from.y)
        let lineLen = hypot(lineVec.dx, lineVec.dy)
        if lineLen == 0 { return hypot(pointVec.dx, pointVec.dy) }
        
        // Parametric position along the segment clamped to [0, 1]
        let clampedT = max(0, min(1, (pointVec.dx * lineVec.dx + pointVec.dy * lineVec.dy) / (lineLen * lineLen)))
        let proj = CGPoint(x: from.x + clampedT * lineVec.dx, y: from.y + clampedT * lineVec.dy)
        return hypot(point.x - proj.x, point.y - proj.y)
    }
}
--------------------------------------------------
