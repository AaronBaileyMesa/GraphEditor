## Focused Project Concatenation
This file includes only UI, interactivity, model, and core logic files.
Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
Current date: 2025-08-22 22:49:00
Table of Contents:
1. GraphEditorShared/Sources/GraphEditorShared/PersistenceManager.swift
2. GraphEditorShared/Sources/GraphEditorShared/PhysicsEngine.swift
3. GraphEditorShared/Sources/GraphEditorShared/PositionUpdater.swift
4. GraphEditorShared/Sources/GraphEditorShared/Protocols.swift
5. GraphEditorShared/Sources/GraphEditorShared/Quadtree.swift
6. GraphEditorShared/Sources/GraphEditorShared/RepulsionCalculator.swift
7. GraphEditorShared/Sources/GraphEditorShared/ToggleNode.swift
8. GraphEditorShared/Sources/GraphEditorShared/Utilities.swift
9. GraphEditorWatch/GraphEditorWatch.swift
10. GraphEditorWatch/Models/AppConstants.swift--------------------------------------------------
File: PersistenceManager.swift
Path: GraphEditorShared/Sources/GraphEditorShared/PersistenceManager.swift
Last modified: 2025-08-22 14:38:51

Contents:
// Sources/GraphEditorShared/PersistenceManager.swift

import Foundation
import os.log

private let logger = OSLog(subsystem: "io.handcart.GraphEditor", category: "storage")

@available(iOS 13.0, watchOS 6.0, *)
/// Error types for graph storage operations.
public enum GraphStorageError: Error {
    case encodingFailed(Error)
    case writingFailed(Error)
    case loadingFailed(Error)
    case decodingFailed(Error)
    case inconsistentFiles(String)  // Retained for potential future multi-file use
}

/// File-based JSON persistence conforming to GraphStorage.
@available(iOS 13.0, watchOS 6.0, *)
public class PersistenceManager: GraphStorage {
    private let fileName = "graphState.json"
    private let fileURL: URL
    
    public init() {
        let documents = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        fileURL = documents.appendingPathComponent(fileName)
    }
    
    struct SavedState: Codable {
        let version: Int = 1
        let nodes: [NodeWrapper]
        let edges: [GraphEdge]
        let viewState: ViewState?  // Embed view state (optional)
    }
    
    public func save(nodes: [any NodeProtocol], edges: [GraphEdge]) throws {
        let wrapped = nodes.map { node in
            if let n = node as? Node {
                return NodeWrapper.node(n)
            } else if let tn = node as? ToggleNode {
                return NodeWrapper.toggleNode(tn)
            } else {
                os_log("Unsupported node type: %{public}s", log: logger, type: .error, String(describing: type(of: node)))
                fatalError("Unsupported node type: \(type(of: node))")
            }
        }
        let state = SavedState(nodes: wrapped, edges: edges, viewState: nil)  // Populate viewState if needed from params
        do {
            let data = try JSONEncoder().encode(state)
            try data.write(to: fileURL)
        } catch let error as EncodingError {
            os_log("Encoding failed: %{public}s", log: logger, type: .error, error.localizedDescription)
            throw GraphStorageError.encodingFailed(error)
        } catch {
            os_log("Writing failed: %{public}s", log: logger, type: .error, error.localizedDescription)
            throw GraphStorageError.writingFailed(error)
        }
    }
    
    public func load() throws -> (nodes: [any NodeProtocol], edges: [GraphEdge]) {
        let fm = FileManager.default
        guard fm.fileExists(atPath: fileURL.path) else { return ([], []) }
        do {
            let data = try Data(contentsOf: fileURL)
            let state = try JSONDecoder().decode(SavedState.self, from: data)
            if state.version != 1 {
                throw GraphStorageError.decodingFailed(NSError(domain: "Invalid version \(state.version)", code: 0))
            }
            let loadedNodes = state.nodes.map { $0.value }
            return (loadedNodes, state.edges)
        } catch let error as DecodingError {
            os_log("Decoding failed: %{public}s", log: logger, type: .error, error.localizedDescription)
            throw GraphStorageError.decodingFailed(error)
        } catch {
            os_log("Loading failed: %{public}s", log: logger, type: .error, error.localizedDescription)
            throw GraphStorageError.loadingFailed(error)
        }
    }
    
    public func clear() throws {
        let fm = FileManager.default
        if fm.fileExists(atPath: fileURL.path) {
            try fm.removeItem(at: fileURL)
        }
    }

    // Updated helper struct
    struct ViewState: Codable {
        let offset: CGPoint
        let zoomScale: CGFloat
        let selectedNodeID: UUID?  // NodeID is UUID from GraphTypes.swift
        let selectedEdgeID: UUID?  // Matches @Published in GraphViewModel
    }

    // Updated save method
    public func saveViewState(offset: CGPoint, zoomScale: CGFloat, selectedNodeID: UUID?, selectedEdgeID: UUID?) throws {
        let state = ViewState(offset: offset, zoomScale: zoomScale, selectedNodeID: selectedNodeID, selectedEdgeID: selectedEdgeID)
        let data = try JSONEncoder().encode(state)
        UserDefaults.standard.set(data, forKey: "graphViewState")
        UserDefaults.standard.synchronize()  // Ensure immediate write
    }

    // Updated load method
    public func loadViewState() throws -> (offset: CGPoint, zoomScale: CGFloat, selectedNodeID: UUID?, selectedEdgeID: UUID?)? {
        guard let data = UserDefaults.standard.data(forKey: "graphViewState") else { return nil }
        let state = try JSONDecoder().decode(ViewState.self, from: data)
        return (offset: state.offset, zoomScale: state.zoomScale, selectedNodeID: state.selectedNodeID, selectedEdgeID: state.selectedEdgeID)
    }
}
----------------------------------------------------------------------------------------------------
File: PhysicsEngine.swift
Path: GraphEditorShared/Sources/GraphEditorShared/PhysicsEngine.swift
Last modified: 2025-08-22 14:30:27

Contents:
//
//  PhysicsEngine.swift
//  GraphEditorShared
//
//  Created by handcart on 8/1/25.
//

import os.log
import SwiftUI
import Foundation
import CoreGraphics

@available(iOS 13.0, *)
@available(watchOS 9.0, *)
public class PhysicsEngine {
    private let physicsLogger = OSLog(subsystem: "io.handcart.GraphEditor", category: "physics")
    let simulationBounds: CGSize
    private var stepCount: Int = 0
    private let maxNodesForQuadtree = 200
    private let symmetricFactor: CGFloat = 0.5
    internal let repulsionCalculator: RepulsionCalculator
    internal let attractionCalculator: AttractionCalculator
    internal let centeringCalculator: CenteringCalculator
    internal let positionUpdater: PositionUpdater
    
    public init(simulationBounds: CGSize) {
        self.simulationBounds = simulationBounds
        self.repulsionCalculator = RepulsionCalculator(maxNodesForQuadtree: 200, simulationBounds: simulationBounds)
        self.attractionCalculator = AttractionCalculator(useAsymmetricAttraction: self.useAsymmetricAttraction, symmetricFactor: self.symmetricFactor)
        self.centeringCalculator = CenteringCalculator(simulationBounds: simulationBounds)
        self.positionUpdater = PositionUpdater(simulationBounds: simulationBounds)  // Added missing arg
    }
    
    private var simulationSteps = 0
    
    public func resetSimulation() {
        simulationSteps = 0
        stepCount = 0
    }
    
    public var useAsymmetricAttraction: Bool = false  // Default to false for stability
    public var isPaused: Bool = false
    
    @discardableResult
        public func simulationStep(nodes: [any NodeProtocol], edges: [GraphEdge]) -> ([any NodeProtocol], Bool) {
            if isPaused || stepCount > Constants.Physics.maxSimulationSteps { return (nodes, false) }
            stepCount += 1
            
            let (forces, quadtree) = repulsionCalculator.computeRepulsions(nodes: nodes)
            var updatedForces = attractionCalculator.applyAttractions(forces: forces, edges: edges, nodes: nodes)
            updatedForces = centeringCalculator.applyCentering(forces: updatedForces, nodes: nodes)
            
            let (updatedNodes, isActive) = positionUpdater.updatePositionsAndVelocities(nodes: nodes, forces: updatedForces, edges: edges, quadtree: quadtree)
            
            // New: Reset velocities if stable
            let resetNodes = isActive ? updatedNodes : updatedNodes.map { $0.with(position: $0.position, velocity: .zero) }
            
            if stepCount % 10 == 0 {  // Reduced logging frequency
                let totalVel = resetNodes.reduce(0.0) { $0 + $1.velocity.magnitude }
                os_log("Step %d: Total velocity = %.2f", log: physicsLogger, type: .debug, stepCount, totalVel)
            }
            
            return (resetNodes, isActive)
        }
    
    public func boundingBox(nodes: [any NodeProtocol]) -> CGRect {
        guard !nodes.isEmpty else { return .zero }
        var minX = nodes[0].position.x, minY = nodes[0].position.y
        var maxX = nodes[0].position.x, maxY = nodes[0].position.y
        for node in nodes {
            minX = min(minX, node.position.x - node.radius)
            minY = min(minY, node.position.y - node.radius)
            maxX = max(maxX, node.position.x + node.radius)
            maxY = max(maxY, node.position.y + node.radius)
        }
        return CGRect(x: minX, y: minY, width: maxX - minX, height: maxY - minY)
    }
    
    public func centerNodes(nodes: [any NodeProtocol], around center: CGPoint? = nil) -> [any NodeProtocol] {
        guard !nodes.isEmpty else { return [] }
        let targetCenter = center ?? CGPoint(x: simulationBounds.width / 2, y: simulationBounds.height / 2)
        
        // Compute current centroid
        let totalX = nodes.reduce(0.0) { $0 + $1.position.x }
        let totalY = nodes.reduce(0.0) { $0 + $1.position.y }
        let centroid = CGPoint(x: totalX / CGFloat(nodes.count), y: totalY / CGFloat(nodes.count))
        
        // Create updated nodes with translation
        let dx = targetCenter.x - centroid.x
        let dy = targetCenter.y - centroid.y
        return nodes.map { node in
            let newPosition = CGPoint(x: node.position.x + dx, y: node.position.y + dy)
            return node.with(position: newPosition, velocity: node.velocity)
        }
    }
}
----------------------------------------------------------------------------------------------------
File: PositionUpdater.swift
Path: GraphEditorShared/Sources/GraphEditorShared/PositionUpdater.swift
Last modified: 2025-08-19 11:36:48

Contents:
//
//  PositionUpdater.swift
//  GraphEditorShared
//
//  Created by handcart on 8/12/25.
//

import Foundation
import CoreGraphics

struct PositionUpdater {
    let simulationBounds: CGSize
    
    init(simulationBounds: CGSize) {
        self.simulationBounds = simulationBounds
    }
    
    func updatePositionsAndVelocities(nodes: [any NodeProtocol], forces: [NodeID: CGPoint], edges: [GraphEdge], quadtree: Quadtree?) -> ([any NodeProtocol], Bool) {
        var tentativeUpdates: [NodeID: (position: CGPoint, velocity: CGPoint)] = [:]
        for node in nodes {
            let force = forces[node.id] ?? .zero
            var newVelocity = CGPoint(x: node.velocity.x + force.x * Constants.Physics.timeStep, y: node.velocity.y + force.y * Constants.Physics.timeStep)
            newVelocity = CGPoint(x: newVelocity.x * Constants.Physics.damping, y: newVelocity.y * Constants.Physics.damping)
            var newPosition = CGPoint(x: node.position.x + newVelocity.x * Constants.Physics.timeStep, y: node.position.y + newVelocity.y * Constants.Physics.timeStep)
            
            // Tentative bounds clamp and softer bounce
            let oldPosition = newPosition
            newPosition.x = max(0, min(simulationBounds.width, newPosition.x))
            newPosition.y = max(0, min(simulationBounds.height, newPosition.y))
            if newPosition.x != oldPosition.x {
                newVelocity.x = -newVelocity.x * 0.8
            }
            if newPosition.y != oldPosition.y {
                newVelocity.y = -newVelocity.y * 0.8
            }
            
            // Insert anti-collision separation here
            let minDist: CGFloat = 35.0  // Or Constants.Physics.minCollisionDist if defined
            if let qt = quadtree {
                let nearby = qt.queryNearby(position: newPosition, radius: minDist)
                for other in nearby where other.id != node.id {
                    let delta = newPosition - other.position
                    let d = hypot(delta.x, delta.y)
                    if d < minDist && d > 0 {
                        newPosition += (delta / d) * (minDist - d) / 2
                    }
                }
            } else {
                // Fallback to original O(n^2) for small graphs
                for other in nodes where other.id != node.id {
                    let delta = newPosition - other.position
                    let d = hypot(delta.x, delta.y)
                    if d < minDist && d > 0 {
                        newPosition += (delta / d) * (minDist - d) / 2
                    }
                }
            }
            
            // FIXED: Store the computed values (this was missing, causing nil in second loop)
            tentativeUpdates[node.id] = (position: newPosition, velocity: newVelocity)
        }
        
        // Build multi-parent map: child -> [parents]
        var parentMap = [NodeID: [NodeID]]()
        for edge in edges {
            parentMap[edge.to, default: []].append(edge.from)
        }
        
        // Second pass: Apply clamping using tentative parent updates and create final updated nodes
        var updatedNodes: [any NodeProtocol] = []
        var totalVelocity: CGFloat = 0.0
        for node in nodes {
            var newPosition = tentativeUpdates[node.id]!.position
            var newVelocity = tentativeUpdates[node.id]!.velocity
            
            if let parents = parentMap[node.id], !parents.isEmpty {
                let collapsedParents = parents.filter { parentID in
                    nodes.first(where: { $0.id == parentID })?.isExpanded == false
                }
                if !collapsedParents.isEmpty {
                    // Average tentative positions of collapsed parents
                    var avgPos = CGPoint.zero
                    for parentID in collapsedParents {
                        avgPos = avgPos + tentativeUpdates[parentID]!.position
                    }
                    avgPos = avgPos / CGFloat(collapsedParents.count)
                    newPosition = avgPos
                    newVelocity = .zero
                }
            }
            
            let updatedNode = node.with(position: newPosition, velocity: newVelocity)
            updatedNodes.append(updatedNode)
            totalVelocity += hypot(newVelocity.x, newVelocity.y)
        }
        
        // Check if stable based on total velocity
        let isActive = totalVelocity >= Constants.Physics.velocityThreshold * CGFloat(nodes.count)
        
        return (updatedNodes, isActive)
    }
}
----------------------------------------------------------------------------------------------------
File: Protocols.swift
Path: GraphEditorShared/Sources/GraphEditorShared/Protocols.swift
Last modified: 2025-08-15 13:19:34

Contents:
//
//  GraphStorage.swift
//  GraphEditorShared
//
//  Created by handcart on 8/1/25.
//

import SwiftUI
// Sources/GraphEditorShared/Protocols.swift

@available(iOS 13.0, watchOS 6.0, *)
public protocol GraphStorage {
    /// Saves the graph nodes and edges, throwing on failure (e.g., encoding or writing errors).
    func save(nodes: [any NodeProtocol], edges: [GraphEdge]) throws
    /// Loads the graph nodes and edges, throwing on failure (e.g., file not found or decoding errors).
    func load() throws -> (nodes: [any NodeProtocol], edges: [GraphEdge])
    func clear() throws  // Unchanged
    func saveViewState(offset: CGPoint, zoomScale: CGFloat, selectedNodeID: UUID?, selectedEdgeID: UUID?) throws
    func loadViewState() throws -> (offset: CGPoint, zoomScale: CGFloat, selectedNodeID: UUID?, selectedEdgeID: UUID?)?
}

// In GraphEditorShared/Sources/GraphEditorShared/Protocols.swift (add inside protocol GraphStorage)



// Add a protocol extension for defaults (at bottom of file)
extension GraphStorage {
    func saveViewState(offset: CGPoint, zoomScale: CGFloat, selectedNodeID: UUID?, selectedEdgeID: UUID?) throws {
        // Default: Do nothing (for storages that don't support view state)
    }
    
    func loadViewState() throws -> (offset: CGPoint, zoomScale: CGFloat, selectedNodeID: UUID?, selectedEdgeID: UUID?)? {
        return nil  // Default: No state
    }
}
----------------------------------------------------------------------------------------------------
File: Quadtree.swift
Path: GraphEditorShared/Sources/GraphEditorShared/Quadtree.swift
Last modified: 2025-08-18 10:52:44

Contents:
// Sources/GraphEditorShared/Quadtree.swift

import Foundation
import CoreGraphics

@available(iOS 13.0, *)
@available(watchOS 9.0, *)
public class Quadtree {  // Made public for consistency/test access
    let bounds: CGRect
    public var centerOfMass: CGPoint = .zero
    public var totalMass: CGFloat = 0
    public var children: [Quadtree]? = nil
    var nodes: [any NodeProtocol] = []  // Updated: Existential array
    
    public init(bounds: CGRect) {
        self.bounds = bounds
    }
    
    public func insert(_ node: any NodeProtocol, depth: Int = 0) {
        guard bounds.width >= Constants.Physics.minQuadSize && bounds.height >= Constants.Physics.minQuadSize else {
            nodes.append(node)
            updateCenterOfMass(with: node)
            return
        }
        guard depth <= Constants.Physics.maxQuadtreeDepth else {
            nodes.append(node)
            updateCenterOfMass(with: node)
            return
        }
        
        if let children = children {
            // Existing subdivided quad: Insert into child
            let quadrant = getQuadrant(for: node.position)
            children[quadrant].insert(node, depth: depth + 1)
            aggregateFromChildren()  // Update aggregates post-insert
        } else if !nodes.isEmpty {
            // Leaf with nodes: Subdivide and redistribute
            subdivide()
            guard let children = children else {
                // Failed to subdivide (too small); append to leaf
                nodes.append(node)
                updateCenterOfMass(with: node)
                return
            }
            for existing in nodes {
                let quadrant = getQuadrant(for: existing.position)
                children[quadrant].insert(existing, depth: depth + 1)
            }
            nodes = []
            let quadrant = getQuadrant(for: node.position)
            children[quadrant].insert(node, depth: depth + 1)
            aggregateFromChildren()
        } else {
            // Empty leaf: Append
            nodes.append(node)
            updateCenterOfMass(with: node)
        }
    }
    
    public func batchInsert(_ batchNodes: [any NodeProtocol], depth: Int = 0) {
        guard depth <= Constants.Physics.maxQuadtreeDepth,
              bounds.width >= Constants.Physics.minQuadSize,
              bounds.height >= Constants.Physics.minQuadSize else {
            nodes.append(contentsOf: batchNodes)
            for node in batchNodes {
                updateCenterOfMass(with: node)  // Incremental updates
            }
            return
        }
        
        if let children = children {
            // Existing subdivided quad: Distribute to children, defer aggregation
            var childBatches: [[any NodeProtocol]] = Array(repeating: [], count: 4)
            for node in batchNodes {
                let quadrant = getQuadrant(for: node.position)
                childBatches[quadrant].append(node)
            }
            for i in 0..<4 {
                if !childBatches[i].isEmpty {
                    children[i].batchInsert(childBatches[i], depth: depth + 1)
                }
            }
            aggregateFromChildren()  // Aggregate once after all inserts
        } else if !nodes.isEmpty || !batchNodes.isEmpty {
            // Leaf: If needs subdivide, do so and redistribute all
            let allNodes = nodes + batchNodes
            if allNodes.count > 1 {  // Subdivide threshold (e.g., >1 for batch)
                subdivide()
                guard let children = children else {
                    // Failed: Append to leaf
                    nodes.append(contentsOf: batchNodes)
                    for node in batchNodes {
                        updateCenterOfMass(with: node)
                    }
                    return
                }
                var childBatches: [[any NodeProtocol]] = Array(repeating: [], count: 4)
                for node in allNodes {
                    let quadrant = getQuadrant(for: node.position)
                    childBatches[quadrant].append(node)
                }
                nodes = []
                for i in 0..<4 {
                    if !childBatches[i].isEmpty {
                        children[i].batchInsert(childBatches[i], depth: depth + 1)
                    }
                }
                aggregateFromChildren()  // Aggregate once
            } else {
                // No subdivide needed: Append and update
                nodes.append(contentsOf: batchNodes)
                for node in batchNodes {
                    updateCenterOfMass(with: node)
                }
            }
        }
    }

    private func aggregateFromChildren() {
        // Recompute totalMass and centerOfMass from children (bottom-up)
        centerOfMass = .zero
        totalMass = 0
        guard let children = children else { return }
        for child in children {
            if child.totalMass > 0 {
                centerOfMass = (centerOfMass * totalMass + child.centerOfMass * child.totalMass) / (totalMass + child.totalMass)
                totalMass += child.totalMass
            }
        }
    }
    
    private func subdivide() {
        let halfWidth = bounds.width / 2
        let halfHeight = bounds.height / 2
        if halfWidth < Constants.Physics.minQuadSize || halfHeight < Constants.Physics.minQuadSize {  // Use constant
            return  // Too small
        }
        children = [
            Quadtree(bounds: CGRect(x: bounds.minX, y: bounds.minY, width: halfWidth, height: halfHeight)),
            Quadtree(bounds: CGRect(x: bounds.minX + halfWidth, y: bounds.minY, width: halfWidth, height: halfHeight)),
            Quadtree(bounds: CGRect(x: bounds.minX, y: bounds.minY + halfHeight, width: halfWidth, height: halfHeight)),
            Quadtree(bounds: CGRect(x: bounds.minX + halfWidth, y: bounds.minY + halfHeight, width: halfWidth, height: halfHeight))
        ]
    }
    
    private func getQuadrant(for point: CGPoint) -> Int {
        let midX = bounds.midX
        let midY = bounds.midY
        if point.x < midX {
            if point.y < midY { return 0 }
            else { return 2 }
        } else {
            if point.y < midY { return 1 }
            else { return 3 }
        }
    }
    
    private func updateCenterOfMass(with node: any NodeProtocol) {
        // Incremental update (works for both leaves and internals); assume mass=1 per node
        centerOfMass = (centerOfMass * totalMass + node.position) / (totalMass + 1)
        totalMass += 1
    }
    
    public func computeForce(on queryNode: any NodeProtocol, theta: CGFloat = 0.5) -> CGPoint {
        guard totalMass > 0 else { return .zero }
        if !nodes.isEmpty {
            // Leaf: Exact repulsion for each node in array
            var force: CGPoint = .zero
            for leafNode in nodes where leafNode.id != queryNode.id {
                force += repulsionForce(from: leafNode.position, to: queryNode.position)
            }
            return force
        }
        // Internal: Approximation
        let delta = centerOfMass - queryNode.position
        let dist = max(delta.magnitude, Constants.Physics.distanceEpsilon)  // Updated
        if bounds.width / dist < theta || children == nil {
            return repulsionForce(from: centerOfMass, to: queryNode.position, mass: totalMass)
        } else {
            var force: CGPoint = .zero
            if let children = children {
                for child in children {
                    force += child.computeForce(on: queryNode, theta: theta)
                }
            }
            return force
        }
    }
    
    public func queryNearby(position: CGPoint, radius: CGFloat) -> [any NodeProtocol] {
        var results: [any NodeProtocol] = []
        func traverse(qt: Quadtree) {
            // Check if quad intersects circle
            let closestX = max(qt.bounds.minX, min(position.x, qt.bounds.maxX))
            let closestY = max(qt.bounds.minY, min(position.y, qt.bounds.maxY))
            let distToQuad = hypot(closestX - position.x, closestY - position.y)
            if distToQuad > radius + hypot(qt.bounds.width/2, qt.bounds.height/2) { return }  // No intersection
            
            if let children = qt.children {
                for child in children {
                    traverse(qt: child)
                }
            } else {
                for node in qt.nodes {
                    let delta = node.position - position
                    if hypot(delta.x, delta.y) < radius {
                        results.append(node)
                    }
                }
            }
        }
        traverse(qt: self)
        return results
    }
    
    private func repulsionForce(from: CGPoint, to: CGPoint, mass: CGFloat = 1) -> CGPoint {
        let deltaX = to.x - from.x
        let deltaY = to.y - from.y
        let distSquared = deltaX * deltaX + deltaY * deltaY
        if distSquared < Constants.Physics.distanceEpsilon * Constants.Physics.distanceEpsilon {  // Updated
            // Jitter slightly to avoid zero
            return CGPoint(x: CGFloat.random(in: -0.01...0.01), y: CGFloat.random(in: -0.01...0.01)) * Constants.Physics.repulsion * mass
        }
        let dist = sqrt(distSquared)
        let forceMagnitude = Constants.Physics.repulsion * mass / distSquared
        return CGPoint(x: deltaX / dist * forceMagnitude, y: deltaY / dist * forceMagnitude)
    }
}
----------------------------------------------------------------------------------------------------
File: RepulsionCalculator.swift
Path: GraphEditorShared/Sources/GraphEditorShared/RepulsionCalculator.swift
Last modified: 2025-08-18 11:12:14

Contents:
//
//  RepulsionCalculator.swift
//  GraphEditorShared
//
//  Created by handcart on 8/12/25.
//

import Foundation
import CoreGraphics

struct RepulsionCalculator {
    private let maxNodesForQuadtree: Int
    private let simulationBounds: CGSize

    init(maxNodesForQuadtree: Int, simulationBounds: CGSize) {
        self.maxNodesForQuadtree = maxNodesForQuadtree
        self.simulationBounds = simulationBounds
    }

    func computeRepulsions(nodes: [any NodeProtocol]) -> ([NodeID: CGPoint], Quadtree?) {
        var forces: [NodeID: CGPoint] = [:]
        let useQuadtree = nodes.count > maxNodesForQuadtree && simulationBounds.width >= Constants.Physics.minQuadSize && simulationBounds.height >= Constants.Physics.minQuadSize
        let quadtree: Quadtree? = useQuadtree ? buildQuadtree(nodes: nodes) : nil

        for node in nodes {
            var repulsion: CGPoint = .zero
            if let quadtree = quadtree {
                let dynamicTheta: CGFloat = nodes.count > 100 ? 1.5 : (nodes.count > 50 ? 1.2 : 0.8)
                repulsion = quadtreeRepulsion(for: node, quadtree: quadtree, theta: dynamicTheta)  // Updated call
            } else {
                for otherNode in nodes where otherNode.id != node.id {
                    repulsion += repulsionForce(repellerPosition: otherNode.position, queryPosition: node.position)
                }
            }
            forces[node.id] = (forces[node.id] ?? .zero) + repulsion
        }
        return (forces, quadtree)  // New: Return tuple
    }

    public func buildQuadtree(nodes: [any NodeProtocol]) -> Quadtree {
        let boundingBox = boundingBox(nodes: nodes)  // Calls local func
        let quadtree = Quadtree(bounds: boundingBox)
        for node in nodes {
            quadtree.insert(node)
        }
        return quadtree
        // Removed duplicated block
    }

    private func repulsionForce(repellerPosition: CGPoint, queryPosition: CGPoint, mass: CGFloat = 1.0) -> CGPoint {
        let dx = queryPosition.x - repellerPosition.x
        let dy = queryPosition.y - repellerPosition.y
        let distanceSquared = max(dx * dx + dy * dy, Constants.Physics.distanceEpsilon)
        let distance = sqrt(distanceSquared)
        let forceMagnitude = Constants.Physics.repulsion * mass / distanceSquared
        return CGPoint(x: (dx / distance) * forceMagnitude, y: (dy / distance) * forceMagnitude)
    }
    
    private func quadtreeRepulsion(for node: any NodeProtocol, quadtree: Quadtree, theta: CGFloat) -> CGPoint {  // Added theta
        var force = CGPoint.zero
        func calculateRepulsion(qt: Quadtree) {
            if qt.children == nil {
                for other in qt.nodes where other.id != node.id {
                    force += repulsionForce(repellerPosition: other.position, queryPosition: node.position, mass: 1.0)
                }
                return
            }

            let dx = qt.centerOfMass.x - node.position.x
            let dy = qt.centerOfMass.y - node.position.y
            let distance = hypot(dx, dy)
            let width = qt.bounds.width

            if width / distance < theta && distance > 0 {  // Use theta
                let approxForce = repulsionForce(repellerPosition: qt.centerOfMass, queryPosition: node.position, mass: qt.totalMass)
                force += approxForce
            } else {
                if let children = qt.children {
                    calculateRepulsion(qt: children[0])
                    calculateRepulsion(qt: children[1])
                    calculateRepulsion(qt: children[2])
                    calculateRepulsion(qt: children[3])
                }
            }
        }

        calculateRepulsion(qt: quadtree)
        return force
    }

    // Added missing boundingBox func
    private func boundingBox(nodes: [any NodeProtocol]) -> CGRect {
        guard !nodes.isEmpty else { return .zero }
        var minX = nodes[0].position.x, minY = nodes[0].position.y
        var maxX = nodes[0].position.x, maxY = nodes[0].position.y
        for node in nodes {
            minX = min(minX, node.position.x - node.radius)
            minY = min(minY, node.position.y - node.radius)
            maxX = max(maxX, node.position.x + node.radius)
            maxY = max(maxY, node.position.y + node.radius)
        }
        return CGRect(x: minX, y: minY, width: maxX - minX, height: maxY - minY)
    }
}
----------------------------------------------------------------------------------------------------
File: ToggleNode.swift
Path: GraphEditorShared/Sources/GraphEditorShared/ToggleNode.swift
Last modified: 2025-08-13 13:47:33

Contents:
// Sources/GraphEditorShared/ToggleNode.swift

import SwiftUI
import Foundation

@available(iOS 13.0, *)
@available(watchOS 9.0, *)
public struct ToggleNode: NodeProtocol {
    public let id: NodeID
    public let label: Int
    public var position: CGPoint
    public var velocity: CGPoint = .zero
    public var radius: CGFloat = 10.0
    public var isExpanded: Bool = true  // Default to expanded
    public var fillColor: Color { isExpanded ? .green : .red }

    public init(id: NodeID = NodeID(), label: Int, position: CGPoint, velocity: CGPoint = .zero, radius: CGFloat = 10.0, isExpanded: Bool = true) {
        self.id = id
        self.label = label
        self.position = position
        self.velocity = velocity
        self.radius = radius
        self.isExpanded = isExpanded
    }

    public func with(position: CGPoint, velocity: CGPoint) -> Self {
        ToggleNode(id: id, label: label, position: position, velocity: velocity, radius: radius, isExpanded: isExpanded)
    }

    // In ToggleNode.swift, replace handlingTap with:
    public func handlingTap() -> Self {
        print("ToggleNode \(label) tapped. Expansion state before: \(isExpanded), after: \(!isExpanded)")
        var updated = self
        updated.isExpanded.toggle()
        return updated
    }

    // Override: Custom draw with +/- icon
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    public func draw(in context: GraphicsContext, at position: CGPoint, zoomScale: CGFloat, isSelected: Bool) {
        let scaledRadius = radius * zoomScale
        let borderWidth: CGFloat = isSelected ? 4 * zoomScale : 0
        let borderRadius = scaledRadius + borderWidth / 2

        if borderWidth > 0 {
            let borderPath = Path(ellipseIn: CGRect(x: position.x - borderRadius, y: position.y - borderRadius, width: 2 * borderRadius, height: 2 * borderRadius))
            context.stroke(borderPath, with: .color(.yellow), lineWidth: borderWidth)
        }

        let innerPath = Path(ellipseIn: CGRect(x: position.x - scaledRadius, y: position.y - scaledRadius, width: 2 * scaledRadius, height: 2 * scaledRadius))
        context.fill(innerPath, with: .color(fillColor))  // Use self.fillColor (e.g., .green if expanded, .red if collapsed)
        
        // Draw +/- icon
        let iconText = isExpanded ? "-" : "+"
        let fontSize = max(8.0, 12.0 * zoomScale)  // Readable min size
        let text = Text(iconText).foregroundColor(.white).font(.system(size: fontSize, weight: .bold))
        let resolved = context.resolve(text)
        context.draw(resolved, at: position, anchor: .center)  // Center in node

        // Draw label above (as in protocol default)
        let labelFontSize = max(8.0, 12.0 * zoomScale)
        let labelText = Text("\(label)").foregroundColor(.white).font(.system(size: labelFontSize))
        let labelResolved = context.resolve(labelText)
        let labelPosition = CGPoint(x: position.x, y: position.y - (scaledRadius + 10 * zoomScale))
        context.draw(labelResolved, at: labelPosition, anchor: .center)
    }

    // Codable conformance (for persistence)
    enum CodingKeys: String, CodingKey {
        case id, label, radius, isExpanded
        case positionX, positionY
        case velocityX, velocityY
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(NodeID.self, forKey: .id)
        label = try container.decode(Int.self, forKey: .label)
        radius = try container.decodeIfPresent(CGFloat.self, forKey: .radius) ?? 10.0
        isExpanded = try container.decodeIfPresent(Bool.self, forKey: .isExpanded) ?? true
        let posX = try container.decode(CGFloat.self, forKey: .positionX)
        let posY = try container.decode(CGFloat.self, forKey: .positionY)
        position = CGPoint(x: posX, y: posY)
        let velX = try container.decode(CGFloat.self, forKey: .velocityX)
        let velY = try container.decode(CGFloat.self, forKey: .velocityY)
        velocity = CGPoint(x: velX, y: velY)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(label, forKey: .label)
        try container.encode(radius, forKey: .radius)
        try container.encode(isExpanded, forKey: .isExpanded)
        try container.encode(position.x, forKey: .positionX)
        try container.encode(position.y, forKey: .positionY)
        try container.encode(velocity.x, forKey: .velocityX)
        try container.encode(velocity.y, forKey: .velocityY)
    }
}
----------------------------------------------------------------------------------------------------
File: Utilities.swift
Path: GraphEditorShared/Sources/GraphEditorShared/Utilities.swift
Last modified: 2025-08-21 08:05:59

Contents:
import Foundation
import CoreGraphics

public extension Double {
    func clamped(to range: ClosedRange<Double>) -> Double {
        max(range.lowerBound, min(self, range.upperBound))
    }
}

public extension CGFloat {
    func clamped(to range: ClosedRange<CGFloat>) -> CGFloat {
        Swift.max(range.lowerBound, Swift.min(self, range.upperBound))
    }
}

public extension CGFloat {
    func rounded(to decimalPlaces: Int) -> CGFloat {
        let divisor = pow(10.0, CGFloat(decimalPlaces))
        return (self * divisor).rounded() / divisor
    }
}

public extension CGPoint {
    func normalized() -> CGPoint {
            let len = hypot(x, y)
            return len > 0 ? self / len : .zero
        }
    
    static func + (lhs: CGPoint, rhs: CGPoint) -> CGPoint {
        CGPoint(x: lhs.x + rhs.x, y: lhs.y + rhs.y)
    }
    
    static func - (lhs: CGPoint, rhs: CGPoint) -> CGPoint {
        CGPoint(x: lhs.x - rhs.x, y: lhs.y - rhs.y)
    }
    
    static func * (lhs: CGPoint, rhs: CGFloat) -> CGPoint {
        CGPoint(x: lhs.x * rhs, y: lhs.y * rhs)
    }
    
    static func / (lhs: CGPoint, rhs: CGFloat) -> CGPoint {
        CGPoint(x: lhs.x / rhs, y: lhs.y / rhs)
    }
    
    static func += (lhs: inout CGPoint, rhs: CGPoint) {
        lhs = lhs + rhs
    }
    
    static func -= (lhs: inout CGPoint, rhs: CGPoint) {
        lhs = lhs - rhs
    }
    
    static func *= (lhs: inout CGPoint, rhs: CGFloat) {
        lhs = lhs * rhs
    }
    
    static func + (lhs: CGPoint, rhs: CGSize) -> CGPoint {
        CGPoint(x: lhs.x + rhs.width, y: lhs.y + rhs.height)
    }
    
    static func += (lhs: inout CGPoint, rhs: CGSize) {
        lhs = lhs + rhs
    }
    
    var magnitude: CGFloat {
        hypot(x, y)
    }
}

public extension CGSize {
    static func / (lhs: CGSize, rhs: CGFloat) -> CGSize {
        CGSize(width: lhs.width / rhs, height: lhs.height / rhs)
    }
    
    static func + (lhs: CGSize, rhs: CGSize) -> CGSize {
        CGSize(width: lhs.width + rhs.width, height: lhs.height + rhs.height)
    }
    
    static func += (lhs: inout CGSize, rhs: CGSize) {
        lhs = lhs + rhs
    }
}

// Shared utility functions
public func distance(_ a: CGPoint, _ b: CGPoint) -> CGFloat {
    hypot(a.x - b.x, a.y - b.y)
}
----------------------------------------------------------------------------------------------------
File: GraphEditorWatch.swift
Path: GraphEditorWatch/GraphEditorWatch.swift
Last modified: 2025-08-22 12:19:13

Contents:
//
//  GraphEditorWatch.swift
//  GraphEditorWatch Watch App
//
//  Created by handcart on 8/1/25.
//

import SwiftUI
import WatchKit
import GraphEditorShared

// In GraphEditorWatch.swift
@main
struct GraphEditorWatch: App {
    var body: some Scene {
        WindowGroup {
            let physicsEngine = PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))  // Mock bounds; adjust as needed
            let model = GraphModel(storage: PersistenceManager(), physicsEngine: physicsEngine)
            let viewModel = GraphViewModel(model: model)  // Create viewModel here
            ContentView(viewModel: viewModel)  // <-- Pass viewModel to ContentView init
        }
    }
}
----------------------------------------------------------------------------------------------------
File: AppConstants.swift
Path: GraphEditorWatch/Models/AppConstants.swift
Last modified: 2025-08-07 18:42:52

Contents:
//
//  AppConstants.swift
//  GraphEditor
//
//  Created by handcart on 8/3/25.
//


import CoreGraphics

struct AppConstants {
    // Graph visuals
    static let nodeModelRadius: CGFloat = 10.0
    static let hitScreenRadius: CGFloat = 30.0
    static let tapThreshold: CGFloat = 10.0
    
    // Zooming
    static let numZoomLevels = 10
    static let defaultMinZoom: CGFloat = 0.2
    static let defaultMaxZoom: CGFloat = 5.0
}
--------------------------------------------------
