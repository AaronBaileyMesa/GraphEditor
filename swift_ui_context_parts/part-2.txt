## Focused Project Concatenation
This file includes only UI, interactivity, model, and core logic files.
Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
Current date: 2025-10-07 00:27:38
Table of Contents:
1. GraphEditorShared/Sources/GraphEditorShared/GraphSimulator.swift
2. GraphEditorShared/Sources/GraphEditorShared/GraphTypes.swift
3. GraphEditorShared/Sources/GraphEditorShared/HitTestContext.swift
4. GraphEditorShared/Sources/GraphEditorShared/NodeProtocol.swift
5. GraphEditorShared/Sources/GraphEditorShared/PersistenceManager.swift
6. GraphEditorShared/Sources/GraphEditorShared/PhysicsEngine.swift--------------------------------------------------
File: GraphSimulator.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphSimulator.swift
Last modified: 2025-09-28 19:10:01

Contents:
// Sources/GraphEditorShared/GraphSimulator.swift

import Foundation
import os.log  // For logging if needed

#if os(watchOS)
import WatchKit  // Only if using haptics; otherwise remove
#endif

@available(iOS 16.0, watchOS 6.0, *)
/// Manages physics simulation loops for graph updates.
class GraphSimulator {
    var simulationTask: Task<Void, Never>?  // Exposed for testing
    internal var recentVelocities: [CGFloat] = []  // Explicit internal for test access    
    let velocityChangeThreshold: CGFloat
    let velocityHistoryCount: Int
    let baseInterval: TimeInterval  // Now configurable
    
    let physicsEngine: PhysicsEngine
    private let getVisibleNodes: () -> [any NodeProtocol]
    private let getVisibleEdges: () -> [GraphEdge]
    
    internal let getNodes: () -> [any NodeProtocol]  // Changed from private to internal
    private let setNodes: ([any NodeProtocol]) -> Void  // Updated: Polymorphic
    private let getEdges: () -> [GraphEdge]
    private let onStable: (() -> Void)?  // New: Optional callback
    
    init(getNodes: @escaping () -> [any NodeProtocol],
         setNodes: @escaping ([any NodeProtocol]) -> Void,
         getEdges: @escaping () -> [GraphEdge],
         getVisibleNodes: @escaping () -> [any NodeProtocol],
         getVisibleEdges: @escaping () -> [GraphEdge],
         physicsEngine: PhysicsEngine,
         onStable: (() -> Void)? = nil,
         baseInterval: TimeInterval = 1.0 / 30.0,  // Default value
         velocityChangeThreshold: CGFloat = 0.01,
         velocityHistoryCount: Int = 5) {
        self.getNodes = getNodes
        self.setNodes = setNodes
        self.getEdges = getEdges
        self.physicsEngine = physicsEngine
        self.onStable = onStable
        
        self.getVisibleNodes = getVisibleNodes
        self.getVisibleEdges = getVisibleEdges
        
        self.baseInterval = baseInterval
        self.velocityChangeThreshold = velocityChangeThreshold
        self.velocityHistoryCount = velocityHistoryCount
    }
    
    struct SimulationStepResult {
        let updatedNodes: [any NodeProtocol]
        let shouldContinue: Bool
        let totalVelocity: CGFloat
    }
    
    @MainActor
    func startSimulation() async {
#if os(watchOS)
        guard WKApplication.shared().applicationState == .active else { return }
#endif
        physicsEngine.resetSimulation()
        recentVelocities.removeAll()
        
        let nodeCount = getNodes().count
        if nodeCount < 5 {
            onStable?()  // NEW: Call here to handle "already stable" cases
            return
        }
        
        var adjustedInterval = baseInterval
        if nodeCount >= 20 {
            adjustedInterval = nodeCount < 50 ? 1.0 / 15.0 : 1.0 / 10.0
        }
        if ProcessInfo.processInfo.isLowPowerModeEnabled {
            adjustedInterval *= 2.0
        }
        
        simulationTask = Task {
            await self.runSimulationLoop(baseInterval: adjustedInterval, nodeCount: nodeCount)
        }
        await simulationTask?.value
    }
    
    internal func runSimulationLoop(baseInterval: TimeInterval, nodeCount: Int) async {
        print("Starting sim loop with nodeCount: \(nodeCount), maxIterations: 500")  // NEW: Confirm entry
        var iterations = 0
        let maxIterations = 500
        while !Task.isCancelled && iterations < maxIterations {
            let shouldContinue = await performSimulationStep(baseInterval: baseInterval, nodeCount: nodeCount)
            iterations += 1
            print("Iteration \(iterations): shouldContinue = \(shouldContinue)")  // NEW: Per-iter log
            if !shouldContinue {
                print("Simulation stabilized after \(iterations) iterations")
                break
            }
        }
        if iterations >= maxIterations {
            print("Simulation timed out after \(iterations) iterations; recent velocities: \(recentVelocities)")
        }
        self.onStable?()
    }
    
    private func performSimulationStep(baseInterval: TimeInterval, nodeCount: Int) async -> Bool {
#if os(watchOS)
        if await WKApplication.shared().applicationState != .active { return false }
#endif
        
        let result: SimulationStepResult = await Task.detached {
            return self.computeSimulationStep()
        }.value
        print("Step: Total velocity = \(result.totalVelocity)")
        self.setNodes(result.updatedNodes)
        
        if self.shouldStopSimulation(result: result, nodeCount: nodeCount) {
            return false
        }
        
        try? await Task.sleep(for: .seconds(baseInterval))
        return true
    }
    
    nonisolated func computeSimulationStep() -> SimulationStepResult {
        let nodes = self.getNodes()
        let visibleNodes = self.getVisibleNodes()
        let visibleEdges = self.getVisibleEdges()
        let (forces, quadtree) = self.physicsEngine.repulsionCalculator.computeRepulsions(nodes: visibleNodes)
        var updatedForces = forces
        updatedForces = self.physicsEngine.attractionCalculator.applyAttractions(forces: updatedForces, edges: visibleEdges, nodes: visibleNodes)
        updatedForces = self.physicsEngine.centeringCalculator.applyCentering(forces: updatedForces, nodes: visibleNodes)
        
        var tempNodes = nodes
        var stepActive = false
        let subSteps = nodes.count < 5 ? 2 : (nodes.count < 10 ? 5 : (nodes.count < 30 ? 3 : 1))
        for _ in 0..<subSteps {
            let (updated, active) = self.physicsEngine.positionUpdater.updatePositionsAndVelocities(nodes: tempNodes, forces: updatedForces, edges: self.getEdges(), quadtree: quadtree)
            tempNodes = updated
            stepActive = stepActive || active
        }
        
        let totalVel = tempNodes.reduce(0.0) { $0 + hypot($1.velocity.x, $1.velocity.y) }
        return SimulationStepResult(updatedNodes: tempNodes, shouldContinue: stepActive, totalVelocity: totalVel)
    }
    
    func shouldStopSimulation(result: SimulationStepResult, nodeCount: Int) -> Bool {
        print("Check stop: totalVel = \(result.totalVelocity), threshold = \(Constants.Physics.velocityThreshold * CGFloat(nodeCount)), shouldContinue = \(result.shouldContinue)")  // NEW
        if !result.shouldContinue || result.totalVelocity < Constants.Physics.velocityThreshold * CGFloat(nodeCount) {
            return true
        }
        
        recentVelocities.append(result.totalVelocity)
        if recentVelocities.count > velocityHistoryCount {
            recentVelocities.removeFirst()
        }
        
        if recentVelocities.count == velocityHistoryCount {
            let maxVel = recentVelocities.max() ?? 1.0
            let minVel = recentVelocities.min() ?? 0.0
            let relativeChange = (maxVel > 0) ? (maxVel - minVel) / maxVel : 0.0  // Guard zero-divide
            print("Relative change: \(relativeChange) (threshold: \(velocityChangeThreshold))")  // NEW
            if relativeChange < velocityChangeThreshold {
                return true
            }
        }
        
        return false
    }
    
    func stopSimulation() async {
        simulationTask?.cancel()
        await simulationTask?.value  // Await to ensure clean stop
        simulationTask = nil
    }
}
----------------------------------------------------------------------------------------------------
File: GraphTypes.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphTypes.swift
Last modified: 2025-10-05 15:51:03

Contents:
//
//  GraphTypes.swift
//  GraphEditorShared
//
//  Created by handcart on 2025-09-19 13:45:29

import SwiftUI
import Foundation

public typealias NodeID = UUID

@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public struct Node: NodeProtocol, Equatable {
    public let id: NodeID
    public let label: Int
    public var position: CGPoint
    public var velocity: CGPoint = .zero
    public var radius: CGFloat = 10.0
    public var isExpanded: Bool = true  // Satisfy protocol (always true for basic Node)
    public var content: NodeContent?
    public var fillColor: Color { .red }  // Explicit red for basic nodes

    // Init with all params
    public init(id: NodeID = NodeID(), label: Int, position: CGPoint, velocity: CGPoint = .zero, radius: CGFloat = 10.0, isExpanded: Bool = true, content: NodeContent? = nil) {
        self.id = id
        self.label = label
        self.position = position
        self.velocity = velocity
        self.radius = radius
        self.isExpanded = isExpanded
        self.content = content
    }
    
    public func with(position: CGPoint, velocity: CGPoint) -> Self {
        Node(id: id, label: label, position: position, velocity: velocity, radius: radius, isExpanded: isExpanded, content: content)
    }
}

// New: EdgeType enum
public enum EdgeType: String, Codable {
    case hierarchy  // DAG-enforced, directed
    case association  // Allows cycles, symmetric/undirected feel
}

// Represents an edge connecting two nodes.
public struct GraphEdge: Identifiable, Equatable, Codable {
    public let id: NodeID
    public let from: NodeID
    public let target: NodeID
    public let type: EdgeType  // Required type
    
    enum CodingKeys: String, CodingKey {
        case id, from, target, type
    }
    
    public init(id: NodeID = NodeID(), from: NodeID, target: NodeID, type: EdgeType = .association) {
        self.id = id
        self.from = from
        self.target = target
        self.type = type
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(NodeID.self, forKey: .id)
        from = try container.decode(NodeID.self, forKey: .from)
        target = try container.decode(NodeID.self, forKey: .target)
        type = try container.decode(EdgeType.self, forKey: .type)
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(from, forKey: .from)
        try container.encode(target, forKey: .target)
        try container.encode(type, forKey: .type)
    }
    
    public static func == (lhs: GraphEdge, rhs: GraphEdge) -> Bool {
        lhs.id == rhs.id && lhs.from == rhs.from && lhs.target == rhs.target && lhs.type == rhs.type
    }
}

// Snapshot of the graph state for undo/redo.
@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public struct GraphState {
    public let nodes: [any NodeProtocol]
    public let edges: [GraphEdge]
    
    public init(nodes: [any NodeProtocol], edges: [GraphEdge]) {
        self.nodes = nodes
        self.edges = edges
    }
}

@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public enum NodeWrapper: Codable {
    case node(Node)
    case toggleNode(ToggleNode)
    
    enum CodingKeys: String, CodingKey {
        case type, data
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(String.self, forKey: .type)
        switch type {
        case "node":
            let data = try container.decode(Node.self, forKey: .data)
            self = .node(data)
        case "toggleNode":
            let data = try container.decode(ToggleNode.self, forKey: .data)
            self = .toggleNode(data)
        default:
            throw DecodingError.dataCorruptedError(forKey: .type, in: container, debugDescription: "Unknown node type")
        }
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
        case .node(let node):
            try container.encode("node", forKey: .type)
            try container.encode(node, forKey: .data)
        case .toggleNode(let toggleNode):
            try container.encode("toggleNode", forKey: .type)
            try container.encode(toggleNode, forKey: .data)
        }
    }
    
    public var value: any NodeProtocol {
        switch self {
        case .node(let node): return node
        case .toggleNode(let toggleNode): return toggleNode
        }
    }
}
----------------------------------------------------------------------------------------------------
File: HitTestContext.swift
Path: GraphEditorShared/Sources/GraphEditorShared/HitTestContext.swift
Last modified: 2025-09-26 10:18:51

Contents:
// GraphEditorShared/Sources/GraphEditorShared/HitTestHelper.swift

import CoreGraphics
import os.log  // For standardized logging

private let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "hit_test")

/// Context for hit testing (matches GestureContext from GraphGesturesModifier).
public struct HitTestContext {
    public init(zoomScale: CGFloat, offset: CGSize, viewSize: CGSize, effectiveCentroid: CGPoint) {
          self.zoomScale = zoomScale
          self.offset = offset
          self.viewSize = viewSize
          self.effectiveCentroid = effectiveCentroid
      }
    
    public let zoomScale: CGFloat
    public let offset: CGSize
    public let viewSize: CGSize
    public let effectiveCentroid: CGPoint
}

/// Helper for performing hit tests on nodes and edges in screen space.
public struct HitTestHelper {
    
    /// Finds the closest node to a screen position, if within hit radius.
    /// - Returns: The closest node, or nil if none hit.
    public static func closestNode(at screenPos: CGPoint, visibleNodes: [any NodeProtocol], context: HitTestContext) -> (any NodeProtocol)? {
        var closest: (node: (any NodeProtocol)?, dist: CGFloat) = (nil, .infinity)
        let minHitRadius: CGFloat = 10.0  // Minimum tappable radius in screen points
        let padding: CGFloat = 5.0  // Extra forgiveness
        
        for node in visibleNodes {
            let safeZoom = max(context.zoomScale, 0.1)
            let nodeScreenPos = CoordinateTransformer.modelToScreen(
                node.position,
                effectiveCentroid: context.effectiveCentroid,
                zoomScale: safeZoom,
                offset: context.offset,
                viewSize: context.viewSize
            )
            let dist = hypot(screenPos.x - nodeScreenPos.x, screenPos.y - nodeScreenPos.y)
            let visibleRadius = node.radius * safeZoom
            let nodeHitRadius = max(minHitRadius, visibleRadius) + padding
            
            if dist <= nodeHitRadius && dist < closest.dist {
                closest = (node, dist)
            }
        }
        
        #if DEBUG
        if let node = closest.node {
            logger.debug("Hit closest node \(node.label) at dist \(closest.dist)")
        } else {
            logger.debug("No node hit at screen pos \(String(describing: screenPos))")
        }
        #endif
        
        return closest.node
    }
    
    /// Finds the closest edge to a screen position, if within hit radius.
    /// - Returns: The closest edge, or nil if none hit.
    public static func closestEdge(at screenPos: CGPoint, visibleEdges: [GraphEdge], visibleNodes: [any NodeProtocol], context: HitTestContext) -> GraphEdge? {
        var closest: (edge: GraphEdge?, dist: CGFloat) = (nil, .infinity)
        let hitScreenRadius: CGFloat = 10.0  // Adjustable; smaller for edges to avoid node overlap
        
        for edge in visibleEdges {
            guard let fromNode = visibleNodes.first(where: { $0.id == edge.from }),
                  let toNode = visibleNodes.first(where: { $0.id == edge.target }) else { continue }
            
            let safeZoom = max(context.zoomScale, 0.1)
            let fromScreen = CoordinateTransformer.modelToScreen(
                fromNode.position,
                effectiveCentroid: context.effectiveCentroid,
                zoomScale: safeZoom,
                offset: context.offset,
                viewSize: context.viewSize
            )
            let toScreen = CoordinateTransformer.modelToScreen(
                toNode.position,
                effectiveCentroid: context.effectiveCentroid,
                zoomScale: safeZoom,
                offset: context.offset,
                viewSize: context.viewSize
            )
            
            let dist = pointToLineDistance(point: screenPos, from: fromScreen, target: toScreen)
            
            if dist <= hitScreenRadius && dist < closest.dist {
                closest = (edge, dist)
            }
        }
        
        #if DEBUG
        if let edge = closest.edge {
            logger.debug("Hit closest edge \(edge.id.uuidString.prefix(8)) at dist \(closest.dist)")
        } else {
            logger.debug("No edge hit at screen pos \(String(describing: screenPos))")
        }
        #endif
        
        return closest.edge
    }
    
    // Helper: Distance from point to line segment (extracted for clarity; add if not already in utilities)
    public static func pointToLineDistance(point: CGPoint, from: CGPoint, target: CGPoint) -> CGFloat {
        let lineVec = CGVector(dx: target.x - from.x, dy: target.y - from.y)
        let pointVec = CGVector(dx: point.x - from.x, dy: point.y - from.y)
        let lineLen = hypot(lineVec.dx, lineVec.dy)
        if lineLen == 0 { return hypot(pointVec.dx, pointVec.dy) }
        
        // Parametric position along the segment clamped to [0, 1]
        let clampedT = max(0, min(1, (pointVec.dx * lineVec.dx + pointVec.dy * lineVec.dy) / (lineLen * lineLen)))
        let proj = CGPoint(x: from.x + clampedT * lineVec.dx, y: from.y + clampedT * lineVec.dy)
        return hypot(point.x - proj.x, point.y - proj.y)
    }
}
----------------------------------------------------------------------------------------------------
File: NodeProtocol.swift
Path: GraphEditorShared/Sources/GraphEditorShared/NodeProtocol.swift
Last modified: 2025-09-25 11:53:46

Contents:
// Sources/GraphEditorShared/NodeProtocol.swift

import SwiftUI
import Foundation

@available(iOS 15.0, *)
private var nodeTextCache: [String: GraphicsContext.ResolvedText] = [:]
private let maxCacheSize = 100  // Arbitrary limit; adjust based on testing
private let nodeCacheQueue = DispatchQueue(label: "nodeTextCache", attributes: .concurrent)
private var insertionOrder: [String] = []  // New: Track order

/// Protocol for graph nodes, enabling polymorphism for types like standard or toggleable nodes.
/// Conformers must provide core properties; defaults are available for common behaviors.
@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public protocol NodeProtocol: Identifiable, Equatable, Codable where ID == NodeID {
    /// Unique identifier for the node.
    var id: NodeID { get }
    
    /// Permanent label for the node (e.g., for display and accessibility).
    var label: Int { get }
    
    /// Current position in the graph canvas.
    var position: CGPoint { get set }
    
    /// Velocity vector for physics simulation.
    var velocity: CGPoint { get set }
    
    /// Radius for rendering and hit detection.
    var radius: CGFloat { get set }
    
    /// Expansion state for hierarchical nodes (e.g., true shows children).
    var isExpanded: Bool { get set }
    
    // Data payload for the node
    var content: NodeContent? { get set }
    
    /// Creates a copy with updated position and velocity.
    func with(position: CGPoint, velocity: CGPoint) -> Self
    
    func with(position: CGPoint, velocity: CGPoint, content: NodeContent?) -> Self
    
    /// Renders the node as a SwiftUI view, customizable by zoom and selection.
    /// - Parameters:
    ///   - zoomScale: Current zoom level of the canvas.
    ///   - isSelected: Whether the node is selected (e.g., for border highlight).
    /// - Returns: A SwiftUI view representing the node.
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    func renderView(zoomScale: CGFloat, isSelected: Bool) -> AnyView
    
    /// Handles tap gestures, returning a mutated copy (immutable pattern).
    /// - Returns: Updated node after tap (e.g., toggled state).
    func handlingTap() -> Self
    
    /// Indicates if the node is visible in the graph.
    var isVisible: Bool { get }
    
    /// Configurable fill color for the node's roundel.
    var fillColor: Color { get }
    
    /// Determines if child nodes (via outgoing edges) should be hidden.
    /// - Returns: True if children should be hidden (e.g., collapsed toggle).
    func shouldHideChildren() -> Bool
    
    /// Draws the node in a GraphicsContext for efficient Canvas rendering.
    /// - Parameters:
    ///   - context: The GraphicsContext to draw into.
    ///   - position: Center position for drawing.
    ///   - zoomScale: Current zoom level.
    ///   - isSelected: Whether to draw selection highlights.
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    func draw(in context: GraphicsContext, at position: CGPoint, zoomScale: CGFloat, isSelected: Bool)
}

public enum NodeContent: Codable, Equatable {
    case string(String)
    case date(Date)
    case number(Double)

    public var displayText: String {
        switch self {
        case .string(let str): return str.prefix(10) + (str.count > 10 ? "â€¦" : "")
        case .date(let date):
            let formatter = DateFormatter()
            formatter.dateStyle = .short
            formatter.timeStyle = .none
            formatter.timeZone = TimeZone(secondsFromGMT: 0)  // Use UTC for consistency
            formatter.locale = Locale(identifier: "en_US")  // Set locale for consistent output
            return formatter.string(from: date)
        case .number(let num): return String(format: "%.1f", num)
        }
    }
}

/// Extension providing default implementations for non-rendering behaviors.
/// These can be overridden in conformers for custom logic.
@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public extension NodeProtocol {
    /// Default: No change on tap.
    func handlingTap() -> Self { self }
    
    /// Default: Node is always visible.
    var isVisible: Bool { true }
    
    var fillColor: Color { .red }  // Default to red for all nodes
    
    var isExpanded: Bool {
        true  // Default: Always expanded (non-toggle nodes ignore)
    }
    
    func shouldHideChildren() -> Bool {
        !isExpanded  // Default: Hide if not expanded
    }
    
    var content: NodeContent? {
       nil
    }
    
    func with(position: CGPoint, velocity: CGPoint, content: NodeContent?) -> Self {
        with(position: position, velocity: velocity)  // Default: Ignore content
    }
    
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    func renderView(zoomScale: CGFloat, isSelected: Bool) -> AnyView {
        AnyView(Text("Node \(label)"))  // Default simple view
    }
    
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    func draw(in context: GraphicsContext, at position: CGPoint, zoomScale: CGFloat, isSelected: Bool) {
        let scaledRadius = radius * zoomScale
        let borderWidth: CGFloat = isSelected ? max(3.0, 4 * zoomScale) : 0
        let borderRadius = scaledRadius + borderWidth / 2

        // Draw border if selected
        if borderWidth > 0 {
            let borderPath = Path(ellipseIn: CGRect(x: position.x - borderRadius, y: position.y - borderRadius, width: 2 * borderRadius, height: 2 * borderRadius))
            context.stroke(borderPath, with: .color(.yellow), lineWidth: borderWidth)
        }

        // Draw node circle
        let innerPath = Path(ellipseIn: CGRect(x: position.x - scaledRadius, y: position.y - scaledRadius, width: 2 * scaledRadius, height: 2 * scaledRadius))
        context.fill(innerPath, with: .color(fillColor))

        // Draw label above node
        let labelFontSize = max(8.0, 12.0 * zoomScale)
        let labelResolved = context.resolve(Text("\(label)").foregroundColor(.white).font(.system(size: labelFontSize)))
        let labelPosition = CGPoint(x: position.x, y: position.y - (scaledRadius + 10 * zoomScale))
        context.draw(labelResolved, at: labelPosition, anchor: .center)

        // Draw content below node if present and zoomed in
        if let content = content, zoomScale > 0.5 {
            let contentKey = "\(content.displayText)-\(zoomScale)"
            let contentResolved: GraphicsContext.ResolvedText
            if let cached = nodeTextCache[contentKey] {
                contentResolved = cached
            } else {
                let text = Text(content.displayText).foregroundColor(.gray).font(.system(size: max(6.0, 8.0 * zoomScale)))
                let resolved = context.resolve(text)
                nodeCacheQueue.async(flags: .barrier) {
                    nodeTextCache[contentKey] = resolved
                    insertionOrder.append(contentKey)
                    if nodeTextCache.count > maxCacheSize {
                        let oldestKey = insertionOrder.removeFirst()
                        nodeTextCache.removeValue(forKey: oldestKey)
                    }
                }
                contentResolved = resolved
            }
            let contentPosition = CGPoint(x: position.x, y: position.y + (scaledRadius + 5 * zoomScale))
            context.draw(contentResolved, at: contentPosition, anchor: .center)
        }
    }
}
@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public struct AnyNode: NodeProtocol {
    private var base: any NodeProtocol  // var for mutability
    
    public var content: NodeContent? {
        get { base.content }
        set { base.content = newValue }
    }
    
    public var unwrapped: any NodeProtocol { base }
    
    public var id: NodeID { base.id }
    public var label: Int { base.label }
    public var position: CGPoint {
        get { base.position }
        set { base.position = newValue }
    }
    public var velocity: CGPoint {
        get { base.velocity }
        set { base.velocity = newValue }
    }
    public var radius: CGFloat {
        get { base.radius }
        set { base.radius = newValue }
    }
    public var isExpanded: Bool {
        get { base.isExpanded }
        set { base.isExpanded = newValue }
    }
    public var isVisible: Bool { base.isVisible }
    public var fillColor: Color { base.fillColor }
    
    public init(_ base: any NodeProtocol) {
        self.base = base
    }
    
    public func with(position: CGPoint, velocity: CGPoint) -> Self {
        var newBase = base
        newBase.position = position
        newBase.velocity = velocity
        return AnyNode(newBase)
    }
    
    public func with(position: CGPoint, velocity: CGPoint, content: NodeContent? = nil) -> AnyNode {
        var newBase = base
        newBase.position = position
        newBase.velocity = velocity
        if let content = content {
            newBase.content = content
        }
        return AnyNode(newBase)
    }
    
    public func handlingTap() -> Self {
        AnyNode(base.handlingTap())
    }
    
    public func shouldHideChildren() -> Bool {
        base.shouldHideChildren()
    }
    
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    public func renderView(zoomScale: CGFloat, isSelected: Bool) -> AnyView {
        base.renderView(zoomScale: zoomScale, isSelected: isSelected)
    }
    
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    public func draw(in context: GraphicsContext, at position: CGPoint, zoomScale: CGFloat, isSelected: Bool) {
        #if DEBUG
        print("Drawing node \(label) at \(position), isSelected: \(isSelected), zoom: \(zoomScale)")
        #endif
        base.draw(in: context, at: position, zoomScale: zoomScale, isSelected: isSelected)
    }
    
    public static func == (lhs: AnyNode, rhs: AnyNode) -> Bool {
        lhs.id == rhs.id && lhs.position == rhs.position && lhs.velocity == rhs.velocity &&
        lhs.isExpanded == rhs.isExpanded && lhs.content == rhs.content
    }
    
    public init(from decoder: Decoder) throws {
        let wrapper = try NodeWrapper(from: decoder)
        self.base = wrapper.value
    }
    
    public func encode(to encoder: Encoder) throws {
        let wrapper: NodeWrapper
        if let node = base as? Node {
            wrapper = .node(node)
        } else if let toggleNode = base as? ToggleNode {
            wrapper = .toggleNode(toggleNode)
        } else {
            throw EncodingError.invalidValue(base, EncodingError.Context(codingPath: [], debugDescription: "Unsupported node type"))
        }
        try wrapper.encode(to: encoder)
    }
}
----------------------------------------------------------------------------------------------------
File: PersistenceManager.swift
Path: GraphEditorShared/Sources/GraphEditorShared/PersistenceManager.swift
Last modified: 2025-10-02 20:55:48

Contents:
// Sources/GraphEditorShared/PersistenceManager.swift

import Foundation
import os  // For Logger

@available(iOS 16.0, watchOS 6.0, *)
private let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "storage")

/// Error types for graph storage operations.
public enum GraphStorageError: Error {
    case encodingFailed(Error)
    case writingFailed(Error)
    case loadingFailed(Error)
    case decodingFailed(Error)
    case inconsistentFiles(String)  // Retained for potential future multi-file use
    case graphExists(String)  // New: For createNewGraph duplicates
    case graphNotFound(String)  // New: For load/delete misses
}

/// File-based JSON persistence conforming to GraphStorage.
@available(iOS 16.0, watchOS 6.0, *)
public class PersistenceManager: GraphStorage {
    private let directory: URL
    private let defaultGraphName = "default"
    
    public init(directoryName: String = "graphs") {
        let documents = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        self.directory = documents.appendingPathComponent(directoryName)
        createDirectoryIfNeeded()
    }
    
    private func createDirectoryIfNeeded() {
        do {
            try FileManager.default.createDirectory(at: directory, withIntermediateDirectories: true)
        } catch {
            logger.error("Failed to create directory: \(error.localizedDescription)")
        }
    }
    
    private func fileURL(for name: String) -> URL {
        directory.appendingPathComponent("graph-\(name).json")
    }
    
    private func viewStateKey(for name: String) -> String {
        "graphViewState_\(name)"
    }
    
    struct SavedState: Codable {
        var version: Int = 1
        let nodes: [NodeWrapper]
        let edges: [GraphEdge]
    }
    
    // MARK: - Default (Single-Graph) Methods (Unchanged Behavior)
    
    public func save(nodes: [any NodeProtocol], edges: [GraphEdge]) async throws {
        try await save(nodes: nodes, edges: edges, for: defaultGraphName)
    }
    
    public func load() async throws -> (nodes: [any NodeProtocol], edges: [GraphEdge]) {
        try await load(for: defaultGraphName)
    }
    
    public func clear() async throws {
        try await deleteGraph(name: defaultGraphName)
    }
    
    public func saveViewState(_ viewState: ViewState) async throws {
        try saveViewState(viewState, for: defaultGraphName)
    }
    
    public func loadViewState() async throws -> ViewState? {
        try loadViewState(for: defaultGraphName)
    }
    
    // MARK: - Multi-Graph Methods
    
    public func listGraphNames() async throws -> [String] {
        do {
            let contents = try FileManager.default.contentsOfDirectory(at: directory, includingPropertiesForKeys: nil)
            let names = contents
                .filter { $0.lastPathComponent.hasPrefix("graph-") && $0.pathExtension == "json" }
                .map { String($0.deletingPathExtension().lastPathComponent.dropFirst(6)) }  // Drop "graph-"
                .sorted()
            logger.debug("Listed \(names.count) graphs: \(names)")
            return names
        } catch {
            logger.error("Listing failed: \(error.localizedDescription)")
            throw GraphStorageError.loadingFailed(error)
        }
    }
    
    public func createNewGraph(name: String) async throws {
        let url = fileURL(for: name)
        if FileManager.default.fileExists(atPath: url.path) {
            logger.warning("Graph '\(name)' already exists")
            throw GraphStorageError.graphExists(name)
        }
        // Create empty graph
        let emptyNodes: [any NodeProtocol] = []
        let emptyEdges: [GraphEdge] = []
        try await save(nodes: emptyNodes, edges: emptyEdges, for: name)
        logger.debug("Created new graph: \(name)")
    }
    
    public func save(nodes: [any NodeProtocol], edges: [GraphEdge], for name: String) async throws {
        let wrapped = nodes.compactMap { node -> NodeWrapper? in
            if let plainNode = node as? Node { return .node(plainNode) } else if let toggleNode = node as? ToggleNode { return .toggleNode(toggleNode) } else {
                logger.error("Unsupported node type: \(String(describing: type(of: node))); skipping.")
                return nil  // Skip instead of fatalError
            }
        }
        let state = SavedState(nodes: wrapped, edges: edges)
        do {
            let data = try JSONEncoder().encode(state)
            try data.write(to: fileURL(for: name), options: .atomic)  // Ensures full overwrite
            logger.debug("Saved \(wrapped.count) nodes and \(edges.count) edges for graph '\(name)'")
        } catch let error as EncodingError {
            logger.error("Encoding failed for '\(name)': \(error.localizedDescription)")
            throw GraphStorageError.encodingFailed(error)
        } catch {
            logger.error("Writing failed for '\(name)': \(error.localizedDescription)")
            throw GraphStorageError.writingFailed(error)
        }
    }
    
    public func load(for name: String) async throws -> (nodes: [any NodeProtocol], edges: [GraphEdge]) {
        let url = fileURL(for: name)
        guard FileManager.default.fileExists(atPath: url.path) else {
            logger.debug("No saved file for '\(name)'; throwing not found")
            throw GraphStorageError.graphNotFound(name)
        }
        do {
            let data = try Data(contentsOf: url)
            let state = try JSONDecoder().decode(SavedState.self, from: data)
            if state.version != 1 {
                throw GraphStorageError.decodingFailed(NSError(domain: "Invalid version \(state.version) for '\(name)'", code: 0))
            }
            let loadedNodes = state.nodes.map { $0.value }
            logger.debug("Loaded \(loadedNodes.count) nodes and \(state.edges.count) edges for graph '\(name)'")
            return (loadedNodes, state.edges)
        } catch let error as DecodingError {
            logger.error("Decoding failed for '\(name)': \(error.localizedDescription)")
            throw GraphStorageError.decodingFailed(error)
        } catch {
            logger.error("Loading failed for '\(name)': \(error.localizedDescription)")
            throw GraphStorageError.loadingFailed(error)
        }
    }
    
    public func deleteGraph(name: String) async throws {
        let url = fileURL(for: name)
        if FileManager.default.fileExists(atPath: url.path) {
            try FileManager.default.removeItem(at: url)
            // Also clear associated view state
            UserDefaults.standard.removeObject(forKey: viewStateKey(for: name))
            UserDefaults.standard.synchronize()
            logger.debug("Deleted graph '\(name)'")
        } else {
            logger.warning("Graph '\(name)' not found for deletion")
            throw GraphStorageError.graphNotFound(name)
        }
    }
    
    // MARK: - View State (Per-Graph)
    
    public func saveViewState(_ viewState: ViewState, for name: String) throws {
        let data = try JSONEncoder().encode(viewState)
        UserDefaults.standard.set(data, forKey: viewStateKey(for: name))
        UserDefaults.standard.synchronize()  // Ensure immediate write
        logger.debug("Saved view state for '\(name)'")
    }
    
    public func loadViewState(for name: String) throws -> ViewState? {
        guard let data = UserDefaults.standard.data(forKey: viewStateKey(for: name)) else {
            logger.debug("No view state for '\(name)'")
            return nil
        }
        let decoded = try JSONDecoder().decode(ViewState.self, from: data)
        logger.debug("Loaded view state for '\(name)'")
        return decoded
    }
}
----------------------------------------------------------------------------------------------------
File: PhysicsEngine.swift
Path: GraphEditorShared/Sources/GraphEditorShared/PhysicsEngine.swift
Last modified: 2025-09-19 13:45:29

Contents:
//
//  PhysicsEngine.swift
//  GraphEditorShared
//
//  Created by handcart on 8/1/25.
//

import os.log
import SwiftUI
import Foundation
import CoreGraphics

@available(iOS 16.0, *)
@available(watchOS 9.0, *)
public class PhysicsEngine {
    private let physicsLogger = OSLog(subsystem: "io.handcart.GraphEditor", category: "physics")
    let simulationBounds: CGSize
    private var stepCount: Int = 0
    private let maxNodesForQuadtree = 200
    private let symmetricFactor: CGFloat = 0.5
    internal let repulsionCalculator: RepulsionCalculator
    private var dampingBoostSteps: Int = 0
    internal let attractionCalculator: AttractionCalculator
    internal let centeringCalculator: CenteringCalculator
    internal let positionUpdater: PositionUpdater
    public var useAsymmetricAttraction: Bool = false
    
    public init(simulationBounds: CGSize) {
        self.simulationBounds = simulationBounds
        self.repulsionCalculator = RepulsionCalculator(maxNodesForQuadtree: 200, simulationBounds: simulationBounds)
        self.attractionCalculator = AttractionCalculator(symmetricFactor: self.symmetricFactor, useAsymmetric: useAsymmetricAttraction)
        self.centeringCalculator = CenteringCalculator(simulationBounds: simulationBounds)
        self.positionUpdater = PositionUpdater(simulationBounds: simulationBounds)
    }
    
    public func temporaryDampingBoost(steps: Int = 20) {
        dampingBoostSteps = steps
    }
     
    private var simulationSteps = 0
    
    public func resetSimulation() {
        simulationSteps = 0
        stepCount = 0
    }
    
    public var isPaused: Bool = false
    
    @discardableResult
    public func simulationStep(nodes: [any NodeProtocol], edges: [GraphEdge]) -> ([any NodeProtocol], Bool) {
        if isPaused || stepCount > Constants.Physics.maxSimulationSteps { return (nodes, false) }
        stepCount += 1
        
        let (forces, quadtree) = repulsionCalculator.computeRepulsions(nodes: nodes)
        var updatedForces = attractionCalculator.applyAttractions(forces: forces, edges: edges, nodes: nodes)
        updatedForces = centeringCalculator.applyCentering(forces: updatedForces, nodes: nodes)
        
        let (tempNodes, isActive) = positionUpdater.updatePositionsAndVelocities(nodes: nodes, forces: updatedForces, edges: edges, quadtree: quadtree)
        var updatedNodes = tempNodes.map { node in
            var clamped = node
            if hypot(clamped.velocity.x, clamped.velocity.y) < 0.001 {
                clamped.velocity = .zero
            }
            return clamped
        }

        // New: Reset velocities if stable
        let resetNodes = isActive ? tempNodes : tempNodes.map { $0.with(position: $0.position, velocity: CGPoint.zero) }         // NEW: Apply boosted damping if active
//        var updatedNodes = resetNodes
        if dampingBoostSteps > 0 {
            let extraDamping = Constants.Physics.damping * 1.2  // 20% boost; adjust as needed
            updatedNodes = updatedNodes.map { node in
                var boostedNode = node
                boostedNode.velocity *= extraDamping
                return boostedNode
            }
            dampingBoostSteps -= 1
        }
        if stepCount % 10 == 0 {  // Reduced logging frequency
            let totalVel = resetNodes.reduce(0.0) { $0 + $1.velocity.magnitude }
            os_log("Step %d: Total velocity = %.2f", log: physicsLogger, type: .debug, stepCount, totalVel)
        }
        
        return (resetNodes, isActive)
    }
    
    // Add to PhysicsEngine class
    public func runSimulation(steps: Int, nodes: [any NodeProtocol], edges: [GraphEdge]) -> [any NodeProtocol] {
        var currentNodes = nodes
        for _ in 0..<steps {
            let (updatedNodes, isActive) = simulationStep(nodes: currentNodes, edges: edges)
            currentNodes = updatedNodes
            if !isActive { break }  // Early exit if stable
        }
        return currentNodes
    }
    
    public func boundingBox(nodes: [any NodeProtocol]) -> CGRect {
        guard !nodes.isEmpty else { return .zero }
        var minX = nodes[0].position.x, minY = nodes[0].position.y
        var maxX = nodes[0].position.x, maxY = nodes[0].position.y
        for node in nodes {
            minX = min(minX, node.position.x - node.radius)
            minY = min(minY, node.position.y - node.radius)
            maxX = max(maxX, node.position.x + node.radius)
            maxY = max(maxY, node.position.y + node.radius)
        }
        return CGRect(x: minX, y: minY, width: maxX - minX, height: maxY - minY)
    }
    
    public func centerNodes(nodes: [any NodeProtocol], around center: CGPoint? = nil) -> [any NodeProtocol] {
        guard !nodes.isEmpty else { return [] }
        let targetCenter = center ?? CGPoint(x: simulationBounds.width / 2, y: simulationBounds.height / 2)
        
        // Compute current centroid
        let totalX = nodes.reduce(0.0) { $0 + $1.position.x }
        let totalY = nodes.reduce(0.0) { $0 + $1.position.y }
        let centroid = CGPoint(x: totalX / CGFloat(nodes.count), y: totalY / CGFloat(nodes.count))
        
        // Create updated nodes with translation
        let deltaX = targetCenter.x - centroid.x
        let deltaY = targetCenter.y - centroid.y
        return nodes.map { node in
            let newPosition = CGPoint(x: node.position.x + deltaX, y: node.position.y + deltaY)
            return node.with(position: newPosition, velocity: node.velocity)
        }
    }
    
    public func queryNearby(position: CGPoint, radius: CGFloat, nodes: [any NodeProtocol]) -> [any NodeProtocol] {
        guard !nodes.isEmpty else { return [] }
        let quadtree = repulsionCalculator.buildQuadtree(nodes: nodes)
        return quadtree.queryNearby(position: position, radius: radius)
    }
}
--------------------------------------------------
