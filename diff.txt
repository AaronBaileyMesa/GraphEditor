diff --git a/GraphEditorShared b/GraphEditorShared
--- a/GraphEditorShared
+++ b/GraphEditorShared
@@ -1 +1 @@
-Subproject commit e0154e71eb1bf7b87c524b13f9b61e95781799ef
+Subproject commit e0154e71eb1bf7b87c524b13f9b61e95781799ef-dirty
diff --git a/GraphEditorWatch/Views/ContentView.swift b/GraphEditorWatch/Views/ContentView.swift
index f69fc5e..8413c3c 100644
--- a/GraphEditorWatch/Views/ContentView.swift
+++ b/GraphEditorWatch/Views/ContentView.swift
@@ -2,9 +2,7 @@
 //  GraphEditor
 //
 //  Created by handcart on 8/1/25.
-//
 
-// Views/ContentView.swift
 import SwiftUI
 import WatchKit
 import GraphEditorShared
@@ -20,8 +18,8 @@ struct ContentView: View {
     @State private var panStartOffset: CGSize? = nil
     @State private var showMenu = false
     @State private var showOverlays = false
-    @State private var minZoom: CGFloat = 0.2
-    @State private var maxZoom: CGFloat = 5.0
+    @State private var minZoom: CGFloat = 0.5  // Reduced range
+    @State private var maxZoom: CGFloat = 2.5  // Reduced range
     @State private var crownPosition: Double = 0.5
     @State private var viewSize: CGSize = .zero
     @State private var ignoreNextCrownChange: Bool = false
@@ -32,7 +30,7 @@ struct ContentView: View {
     @State private var resumeTimer: Timer? = nil
     @State private var logOffsetChanges = true  // Toggle for console logs
     @State private var isPanning: Bool = false  // New: Track panning to pause clamping/simulation
-    
+    @State private var zoomTimer: Timer? = nil  // For debouncing zoom resume
     
     // Fixed: Use unlabeled tuple to match compiler type
     @State private var previousSelection: (NodeID?, UUID?) = (nil, nil)
@@ -43,59 +41,104 @@ struct ContentView: View {
         _viewModel = StateObject(wrappedValue: GraphViewModel(model: model))
     }
     
+    // Moved function outside body
     private func recenterOn(position: CGPoint) {
         guard viewSize != .zero else { return }  // Avoid div-by-zero
         let viewCenter = CGPoint(x: viewSize.width / 2, y: viewSize.height / 2)
         let targetOffsetX = viewCenter.x - position.x * zoomScale
         let targetOffsetY = viewCenter.y - position.y * zoomScale
+        withAnimation {
+            offset = CGSize(width: targetOffsetX, height: targetOffsetY)
+        }
+    }
+    
+    // Example method for clampOffset (adapt from your code; broken up for type-checking)
+    private func clampOffset() {
+        let maxX = viewSize.width / 2
+        let minX = -maxX
+        let maxY = viewSize.height / 2
+        let minY = -maxY
         
-        // Dampen: Limit max change per animation to prevent jarring (50% of screen)
-        let maxDeltaX = viewSize.width * 0.5
-        let maxDeltaY = viewSize.height * 0.5
-        let deltaX = targetOffsetX - offset.width
-        let deltaY = targetOffsetY - offset.height
-        offset.width += deltaX.clamped(to: -maxDeltaX...maxDeltaX)
-        offset.height += deltaY.clamped(to: -maxDeltaY...maxDeltaY)
+        let clampedWidth = max(minX, min(offset.width, maxX))
+        let clampedHeight = max(minY, min(offset.height, maxY))
         
-        clampOffset()  // Apply your existing clamping after adjustment
+        offset = CGSize(width: clampedWidth, height: clampedHeight)
     }
     
-    
-    // Updated: Always recenter after updates unless panning
-    private var onUpdateZoomRanges: () -> Void {
-        return {
-            self.updateZoomRanges()
-            if !self.isPanning {
-                self.clampOffset()
-            }
-        }
-    }
+    // Other methods like updateZoomRanges, withSelectionsChange, etc., can be defined here similarly
     
     var body: some View {
-        let geoReader = FocusableView {  // Wrap with your custom FocusableView for reliable crown focus
+        FocusableView {
             GeometryReader { geo in
-                GraphCanvasView(
-                    viewModel: viewModel,
-                    zoomScale: $zoomScale,
-                    offset: $offset,
-                    draggedNode: $draggedNode,
-                    dragOffset: $dragOffset,
-                    potentialEdgeTarget: $potentialEdgeTarget,
-                    selectedNodeID: $viewModel.selectedNodeID,
-                    viewSize: geo.size,
-                    panStartOffset: $panStartOffset,
-                    showMenu: $showMenu,
-                    maxZoom: maxZoom,
-                    crownPosition: $crownPosition,
-                    onUpdateZoomRanges: onUpdateZoomRanges,
-                    selectedEdgeID: $viewModel.selectedEdgeID,
-                    showOverlays: $showOverlays
+                ZStack {
+                    GraphCanvasView(
+                        viewModel: viewModel,
+                        zoomScale: $zoomScale,
+                        offset: $offset,
+                        draggedNode: $draggedNode,
+                        dragOffset: $dragOffset,
+                        potentialEdgeTarget: $potentialEdgeTarget,
+                        selectedNodeID: $viewModel.selectedNodeID,
+                        viewSize: geo.size,
+                        panStartOffset: $panStartOffset,
+                        showMenu: $showMenu,
+                        maxZoom: maxZoom,
+                        crownPosition: $crownPosition,
+                        onUpdateZoomRanges: { /* Your onUpdateZoomRanges logic here; e.g., clampOffset() */ clampOffset() },
+                        selectedEdgeID: $viewModel.selectedEdgeID,
+                        showOverlays: $showOverlays
+                    )
+                }
+                .digitalCrownRotation(
+                    $crownPosition,
+                    from: 0.0,
+                    through: 1.0,
+                    sensitivity: .high,  // Increased for better response (from research)
+                    isContinuous: true,
+                    isHapticFeedbackEnabled: true
                 )
             }
-            .background(Color.black)  // Move inside wrapper if needed; keeps background on the GeometryReader
         }
-        .digitalCrownRotation($crownPosition, from: 0.0, through: 1.0, sensitivity: .low, isContinuous: false, isHapticFeedbackEnabled: true)  // Attach to wrapper
-
+        .onAppear {
+            viewSize = WKInterfaceDevice.current().screenBounds.size
+            viewModel.loadGraph()
+            viewModel.loadViewState()
+        }
+        .onChange(of: scenePhase) { phase in
+            if phase == .active {
+                viewModel.loadGraph()
+                viewModel.loadViewState()
+            }
+        }
+        .onChange(of: crownPosition) { oldValue, newValue in
+            let delta = abs(newValue - oldValue)
+            if delta < 0.01 || ignoreNextCrownChange {
+                ignoreNextCrownChange = false
+                return
+            }
+            
+            let normalized = max(0, min(1, CGFloat(newValue)))
+            let targetZoom = minZoom + (maxZoom - minZoom) * normalized
+            
+            withAnimation(.easeInOut(duration: 0.1)) {
+                zoomScale = targetZoom
+            }
+            
+            clampOffset()  // Or your onUpdateZoomRanges()
+            
+            isZooming = true
+            zoomTimer?.invalidate()
+            zoomTimer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: false) { _ in
+                self.isZooming = false
+                self.viewModel.model.startSimulation()
+            }
+            
+            previousCrownPosition = newValue
+        }
+        .ignoresSafeArea()
+    }
+}
+        
         let withIgnore = geoReader.ignoresSafeArea()
         
         let withSheet = withIgnore.sheet(isPresented: $showMenu) {
