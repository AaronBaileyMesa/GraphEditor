diff --git a/GraphEditor.xcodeproj/project.xcworkspace/xcuserdata/handcart.xcuserdatad/Bookmarks/bookmarks.plist b/GraphEditor.xcodeproj/project.xcworkspace/xcuserdata/handcart.xcuserdatad/Bookmarks/bookmarks.plist
index 7a83e35..7e12264 100644
--- a/GraphEditor.xcodeproj/project.xcworkspace/xcuserdata/handcart.xcuserdatad/Bookmarks/bookmarks.plist
+++ b/GraphEditor.xcodeproj/project.xcworkspace/xcuserdata/handcart.xcuserdatad/Bookmarks/bookmarks.plist
@@ -12,13 +12,13 @@
 					<key>EndingColumnNumber</key>
 					<string>0</string>
 					<key>EndingLineNumber</key>
-					<string>300</string>
+					<string>282</string>
 					<key>StartingColumnNumber</key>
 					<string>0</string>
 					<key>StartingLineNumber</key>
-					<string>300</string>
+					<string>282</string>
 					<key>Timestamp</key>
-					<string>781823614.2328171</string>
+					<string>782061903.026481</string>
 				</dict>
 				<key>rebasable-url</key>
 				<dict>
@@ -55,13 +55,13 @@
 					<key>EndingColumnNumber</key>
 					<string>0</string>
 					<key>EndingLineNumber</key>
-					<string>300</string>
+					<string>282</string>
 					<key>StartingColumnNumber</key>
 					<string>0</string>
 					<key>StartingLineNumber</key>
-					<string>300</string>
+					<string>282</string>
 					<key>Timestamp</key>
-					<string>781823614.232838</string>
+					<string>782061903.026507</string>
 				</dict>
 				<key>rebasable-url</key>
 				<dict>
diff --git a/GraphEditor.xcodeproj/xcshareddata/xcschemes/GraphEditorWatchTests.xcscheme b/GraphEditor.xcodeproj/xcshareddata/xcschemes/GraphEditorWatchTests.xcscheme
index 7df76b8..44d9a7f 100644
--- a/GraphEditor.xcodeproj/xcshareddata/xcschemes/GraphEditorWatchTests.xcscheme
+++ b/GraphEditor.xcodeproj/xcshareddata/xcschemes/GraphEditorWatchTests.xcscheme
@@ -72,6 +72,15 @@
       savedToolIdentifier = ""
       useCustomWorkingDirectory = "NO"
       debugDocumentVersioning = "YES">
+      <MacroExpansion>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "4EB112712E3EE09D001A8E1A"
+            BuildableName = "GraphEditorWatchTests.xctest"
+            BlueprintName = "GraphEditorWatchTests"
+            ReferencedContainer = "container:GraphEditor.xcodeproj">
+         </BuildableReference>
+      </MacroExpansion>
    </ProfileAction>
    <AnalyzeAction
       buildConfiguration = "Debug">
diff --git a/GraphEditor.xcodeproj/xcuserdata/handcart.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist b/GraphEditor.xcodeproj/xcuserdata/handcart.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist
index 16d580d..650d198 100644
--- a/GraphEditor.xcodeproj/xcuserdata/handcart.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist
+++ b/GraphEditor.xcodeproj/xcuserdata/handcart.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist
@@ -3,20 +3,4 @@
    uuid = "7801DA3E-5D2B-4F78-8910-C8C060B44300"
    type = "1"
    version = "2.0">
-   <Breakpoints>
-      <BreakpointProxy
-         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
-         <BreakpointContent
-            uuid = "D6228388-9131-4EC3-AB1A-159E42679629"
-            shouldBeEnabled = "Yes"
-            ignoreCount = "0"
-            continueAfterRunningActions = "No"
-            filePath = "../../../../var/folders/ts/8cyjcsyj7knfwpymchkp5psw0000gn/T/swift-generated-sources/@__swiftmacro_22GraphEditorSharedTests0033GraphEditorSharedTestsswift_DbGHjfMX285_8_6expectfMf_.swift"
-            startingColumnNumber = "9223372036854775807"
-            endingColumnNumber = "9223372036854775807"
-            startingLineNumber = "1"
-            endingLineNumber = "1">
-         </BreakpointContent>
-      </BreakpointProxy>
-   </Breakpoints>
 </Bucket>
diff --git a/GraphEditorShared b/GraphEditorShared
--- a/GraphEditorShared
+++ b/GraphEditorShared
@@ -1 +1 @@
-Subproject commit 5db67d0ba0d33b2df77443ff9648d7841c6b700a
+Subproject commit 5db67d0ba0d33b2df77443ff9648d7841c6b700a-dirty
diff --git a/GraphEditorWatch/ViewModels/GraphViewModel.swift b/GraphEditorWatch/ViewModels/GraphViewModel.swift
index 1967bdb..7854d71 100644
--- a/GraphEditorWatch/ViewModels/GraphViewModel.swift
+++ b/GraphEditorWatch/ViewModels/GraphViewModel.swift
@@ -156,31 +156,16 @@ import os  // Added for logging
     public func deleteNode(withID id: NodeID) async {
         await model.deleteNode(withID: id)
         if selectedNodeID == id { selectedNodeID = nil }
-        // Deleting a node may also invalidate an edge selection
-        selectedEdgeID = nil
-        await saveAfterDelay()
-    }
-    
-    public func clearGraph() async {
-        await model.clearGraph()
         await saveAfterDelay()
     }
     
-    public func pauseSimulation() async {
-        await model.pauseSimulation()
-    }
-    
-    public func resumeSimulation() async {
-        await model.resumeSimulation()
-    }
-    
     public func resumeSimulationAfterDelay() async {
         resumeTimer?.invalidate()
         resumeTimer = Timer.scheduledTimer(withTimeInterval: 0.3, repeats: false) { [weak self] _ in
-            Task { @MainActor in  // Hop to main for safe access
-                guard let self = self else { return }
+            Task { @MainActor in
+                guard let self else { return }
                 if WKApplication.shared().applicationState == .active {
-                    await self.model.resumeSimulation()  // Consistent async call
+                    await self.model.resumeSimulation()
                 }
             }
         }
@@ -191,7 +176,7 @@ import os  // Added for logging
         await model.pauseSimulation()
         
         #if DEBUG
-        logger.debug("Handling tap at model pos: x=\(modelPos.x), y=\(modelPos.y)")
+        self.logger.debug("Handling tap at model pos: x=\(modelPos.x), y=\(modelPos.y)")
         #endif
         
         // Efficient hit test with queryNearby
@@ -199,20 +184,22 @@ import os  // Added for logging
         let nearbyNodes = model.physicsEngine.queryNearby(position: modelPos, radius: hitRadius, nodes: model.visibleNodes())
         
         #if DEBUG
-        logger.debug("Nearby nodes found: \(nearbyNodes.count)")
+        self.logger.debug("Nearby nodes found: \(nearbyNodes.count)")
         #endif
         
         // Sort by distance to get closest (if multiple)
-        let sortedNearby = nearbyNodes.sorted {
-            hypot($0.position.x - modelPos.x, $0.position.y - modelPos.y) < hypot($1.position.x - modelPos.x, $1.position.y - modelPos.y)
+        let distances = nearbyNodes.map { node in
+            hypot(node.position.x - modelPos.x, node.position.y - modelPos.y)
         }
+        let sortedIndices = distances.indices.sorted { distances[$0] < distances[$1] }
+        let sortedNearby = sortedIndices.map { nearbyNodes[$0] }
         
         if let tappedNode = sortedNearby.first {
             selectedNodeID = (tappedNode.id == selectedNodeID) ? nil : tappedNode.id
             selectedEdgeID = nil
             
             #if DEBUG
-            logger.debug("Selected node \(tappedNode.label) (type: \(type(of: tappedNode)))")
+            self.logger.debug("Selected node \(tappedNode.label) (type: \(type(of: tappedNode)))")
             #endif
             
             model.objectWillChange.send()  // Trigger UI refresh
@@ -222,7 +209,7 @@ import os  // Added for logging
             selectedEdgeID = nil
             
             #if DEBUG
-            logger.debug("Tap missed; cleared selections")
+            self.logger.debug("Tap missed; cleared selections")
             #endif
         }
         
@@ -251,6 +238,41 @@ import os  // Added for logging
         offset = .zero
         objectWillChange.send()
     }
+    
+    public func moveDraggedNode(dragOffset: CGPoint, draggedID: NodeID) async {
+        guard let index = model.nodes.firstIndex(where: { $0.id == draggedID }) else { return }
+        let oldNode = model.nodes[index]
+        let unwrapped = oldNode.unwrapped
+        // FIXED: Clamp new position to simulation bounds for consistent offsets
+        let unclampedPos = unwrapped.position + dragOffset
+        let bounds = model.physicsEngine.simulationBounds
+        let newPos = CGPoint(
+            x: unclampedPos.x.clamped(to: 0...bounds.width),
+            y: unclampedPos.y.clamped(to: 0...bounds.height)
+        )
+        let updatedNode: AnyNode
+        if let concrete = unwrapped as? Node {
+            updatedNode = AnyNode(concrete.with(position: newPos, velocity: .zero))
+        } else if let concrete = unwrapped as? ToggleNode {
+            updatedNode = AnyNode(concrete.with(position: newPos, velocity: .zero))
+        } else {
+            logger.error("Unsupported node type for move: \(type(of: unwrapped))")
+            return
+        }
+        model.nodes[index] = updatedNode
+        
+        #if DEBUG
+        logger.debug("Clamped new position to x=\(newPos.x), y=\(newPos.y) within bounds \(bounds.width)x\(bounds.height)")
+        logger.debug("Moved node \(unwrapped.label) to new position x=\(newPos.x), y=\(newPos.y)")
+        #endif
+        
+        await model.startSimulation()
+    }
+    
+    public func clearGraph() async {
+        await model.clearGraph()
+        await saveAfterDelay()
+    }
 }
 
 extension GraphViewModel {
@@ -345,4 +367,8 @@ extension GraphViewModel {
             }
         }
     }
+    
+    public func resumeSimulation() async {
+        await model.resumeSimulation()
+    }
 }
diff --git a/GraphEditorWatch/Views/ContentView.swift b/GraphEditorWatch/Views/ContentView.swift
index 50fb3a4..8bf96c7 100644
--- a/GraphEditorWatch/Views/ContentView.swift
+++ b/GraphEditorWatch/Views/ContentView.swift
@@ -28,6 +28,9 @@ struct ContentView: View {
     @State private var isAddingEdge: Bool = false
     @State private var viewSize: CGSize = .zero
     @State private var isSimulating: Bool = false
+    @State private var isDragging: Bool = false  // Add this for drag state
+    @State private var isSyncingCrown: Bool = false  // (From previous fix; keep)
+    @State private var lastZoomRanges: (min: CGFloat, max: CGFloat)? = nil  // NEW: Cache to avoid redundant recalcs (minimal addition)
     
     // NEW: Custom Bindings to sync @State with ViewModel (two-way)
     private var selectedNodeIDBinding: Binding<NodeID?> {
@@ -51,7 +54,7 @@ struct ContentView: View {
     }
     
     var body: some View {
-        let geoView = GeometryReader { geo in
+        GeometryReader { geo in
             let baseView = mainContent(in: geo)
                 .onAppear {
                     Task { await viewModel.resumeSimulation() }
@@ -79,13 +82,6 @@ struct ContentView: View {
                 .onChange(of: viewModel.model.edges) { _, _ in
                     updateZoomRanges(for: viewSize)  // New: Use viewSize
                 }
-                .onChange(of: crownPosition) { oldValue, newValue in
-                    #if DEBUG
-                    logger.debug("Crown position changed in ContentView: from \(oldValue) to \(newValue)")
-                    #endif
-                    
-                    handleCrownRotation(newValue: newValue)
-                }
                 .onChange(of: canvasFocus) { oldValue, newValue in
                     #if DEBUG
                     logger.debug("ContentView canvas focus changed: from \(oldValue) to \(newValue)")
@@ -96,108 +92,88 @@ struct ContentView: View {
             
             let intermediateView = baseView
                 .onChange(of: zoomScale) { oldValue, newValue in
+                    guard !isSyncingCrown else { return }  // (From previous)
+                    
                     let normalized = (newValue - minZoom) / (maxZoom - minZoom)
                     let targetCrown = Double(AppConstants.crownZoomSteps) * Double(normalized).clamped(to: 0...1)
-                    if abs(targetCrown - crownPosition) > 0.01 {
+                    if abs(targetCrown - crownPosition) > 0.05 {  // NEW: Increased threshold to 0.05 for more anti-jitter (was 0.01)
+                        isSyncingCrown = true
                         crownPosition = targetCrown
                         
                         #if DEBUG
                         logger.debug("Zoom sync: zoomScale from \(oldValue) to \(newValue) -> crownPosition \(self.crownPosition)")
                         #endif
-                    }
-                }
-                .onChange(of: viewModel.selectedNodeID) { oldValue, newValue in
-                    #if DEBUG
-                    logger.debug("ContentView: ViewModel selectedNodeID changed from \(oldValue?.uuidString.prefix(8) ?? "nil") to \(newValue?.uuidString.prefix(8) ?? "nil")")
-                    #endif
-                    
-                    selectedNodeID = newValue  // Sync to local @State
-                    viewModel.objectWillChange.send()  // Force re-render if needed
-                }
-                .onChange(of: viewModel.selectedEdgeID) { oldValue, newValue in
-                    #if DEBUG
-                    logger.debug("ContentView: ViewModel selectedEdgeID changed from \(oldValue?.uuidString.prefix(8) ?? "nil") to \(newValue?.uuidString.prefix(8) ?? "nil")")
-                    #endif
-                    
-                    selectedEdgeID = newValue
-                    viewModel.objectWillChange.send()
-                }
-                .onReceive(viewModel.model.$isStable) { isStable in
-                    if isStable {
-                        #if DEBUG
-                        logger.debug("Simulation stable: Centering nodes")
-                        #endif
                         
-                        centerGraph()
-                    }
-                }
-                .onReceive(viewModel.model.$simulationError) { error in
-                    if let error = error {
-                        #if DEBUG
-                        logger.error("Simulation error: \(error.localizedDescription)")
-                        #endif
+                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {  // NEW: Slightly longer delay (0.1s) to let settle
+                            self.isSyncingCrown = false
+                        }
                     }
                 }
             
             intermediateView
+                .overlay(alignment: .bottom) {
+                    HStack(spacing: 20) {
+                        if wristSide == .left {
+                            addNodeButton(in: geo)
+                            menuButton(in: geo)
+                        } else {
+                            menuButton(in: geo)
+                            addNodeButton(in: geo)
+                        }
+                    }
+                    .padding(.bottom, 1)
+                    .padding(.horizontal, 15)
+                    .transition(.move(edge: .bottom))
+                }
         }
-        
-        let finalView = geoView
-            .ignoresSafeArea()
-            .focusable(true)  // Make the whole view focusable for crown
-            .focused($canvasFocus)  // Bind focus state
-            .digitalCrownRotation(  // Restored: Put back here for root-level handling
-                $crownPosition,
-                from: 0,
-                through: Double(AppConstants.crownZoomSteps),
-                sensitivity: .medium
-            )
-        
-        finalView
+        .digitalCrownRotation(  // NEW: Add this modifier to geoView for native crown handling (replaces custom onChange)
+            $crownPosition,
+            from: 0,
+            through: Double(AppConstants.crownZoomSteps),
+            sensitivity: .low,  // Low sensitivity to reduce jitter from small rotations
+            isContinuous: true,
+            isHapticFeedbackEnabled: true,
+            onChange: { event in
+                let newValue = event.offset
+                #if DEBUG
+                logger.debug("Crown position changed in ContentView to \(newValue)")
+                #endif
+                handleCrownRotation(newValue: newValue)  // Reuse your existing handler
+            }
+        )
+        // Removed .hidden() to ensure the content renders
     }
     
     private func mainContent(in geo: GeometryProxy) -> some View {
         ZStack {
-            InnerView(config: InnerViewConfig(
-                geo: geo,
+            GraphCanvasView(
                 viewModel: viewModel,
                 zoomScale: $zoomScale,
                 offset: $offset,
-                draggedNode: $draggedNode,
+                draggedNode: Binding(get: { draggedNode.node }, set: { draggedNode = NodeWrapper(node: $0) }),
                 dragOffset: $dragOffset,
-                potentialEdgeTarget: $potentialEdgeTarget,
+                potentialEdgeTarget: Binding(get: { potentialEdgeTarget.node }, set: { potentialEdgeTarget = NodeWrapper(node: $0) }),
+                selectedNodeID: selectedNodeIDBinding,
+                viewSize: geo.size,
                 panStartOffset: $panStartOffset,
                 showMenu: $showMenu,
-                showOverlays: $showOverlays,
                 maxZoom: maxZoom,
                 crownPosition: $crownPosition,
-                updateZoomRangesHandler: { size in updateZoomRanges(for: size) },
-                selectedNodeID: $selectedNodeID,
-                selectedEdgeID: $selectedEdgeID,
-                canvasFocus: _canvasFocus,
-                onCenterGraph: centerGraph,
+                onUpdateZoomRanges: { updateZoomRanges(for: geo.size) },
+                selectedEdgeID: selectedEdgeIDBinding,
+                showOverlays: $showOverlays,
                 isAddingEdge: $isAddingEdge,
-                isSimulatingBinding: $isSimulating  // FIXED: Pass actual binding instance from @State
-            ))
-        }
-        .overlay(alignment: .bottom) {
-            HStack(spacing: 20) {
-                if wristSide == .left {
-                    addNodeButton(in: geo)
-                    menuButton(in: geo)
-                } else {
-                    menuButton(in: geo)
-                    addNodeButton(in: geo)
-                }
-            }
-            .padding(.bottom, 1)
-            .padding(.horizontal, 15)
-            .transition(.move(edge: .bottom))
+                isDragging: $isDragging
+            )
         }
-        // Removed .hidden() to ensure the content renders
+        .focused($canvasFocus)
     }
     
     private func handleCrownRotation(newValue: Double) {
+        if isDragging { return }  // Ignore crown during drag to prevent zoom interference
+        
+        guard abs(newValue - crownPosition) > 0.2 else { return }  // NEW: Higher threshold (0.2) for even more anti-jitter; adjust down if too insensitive
+        
         #if DEBUG
         logger.debug("handleCrownRotation triggered with newValue: \(newValue)")
         #endif
@@ -205,11 +181,12 @@ struct ContentView: View {
         let normalized = newValue.clamped(to: 0...Double(AppConstants.crownZoomSteps)) / Double(AppConstants.crownZoomSteps)
         let targetZoom = minZoom + (maxZoom - minZoom) * CGFloat(normalized)
         
-        // New: Animate the zoom change for smoothness
         withAnimation(.easeInOut(duration: 0.1)) {
             zoomScale = targetZoom
         }
-        viewModel.centerGraph()  // Direct call
+        
+        // TEMP: Comment out to test if this reduces jiggle (it may trigger node changes -> zoom recalcs)
+        // viewModel.centerGraph()  // Direct call  // <-- Comment this line for now; re-enable if centering is essential during zoom
         
         #if DEBUG
         logger.debug("Updated zoomScale to: \(self.zoomScale)")
@@ -218,8 +195,13 @@ struct ContentView: View {
     
     private func updateZoomRanges(for viewSize: CGSize) {
         let ranges = viewModel.calculateZoomRanges(for: viewSize)
+        // NEW: Only update if meaningfully different (anti-recalc spam; epsilon for FP precision)
+        if let last = lastZoomRanges, abs(ranges.min - last.min) < 0.001 && abs(ranges.max - last.max) < 0.001 {
+            return  // Skip if unchanged
+        }
         minZoom = ranges.min
         maxZoom = ranges.max
+        lastZoomRanges = (min: minZoom, max: maxZoom)  // Cache
         zoomScale = zoomScale.clamped(to: minZoom...maxZoom)
     }
     
diff --git a/GraphEditorWatch/Views/GestureUtils.swift b/GraphEditorWatch/Views/GestureUtils.swift
new file mode 100644
index 0000000..d717279
--- /dev/null
+++ b/GraphEditorWatch/Views/GestureUtils.swift
@@ -0,0 +1,102 @@
+// GestureUtils.swift
+// Extracted utilities for hit testing and distance calculations
+
+import SwiftUI
+import GraphEditorShared
+
+struct GestureUtils {
+    static func closestNode(at screenPos: CGPoint, visibleNodes: [any NodeProtocol], context: GraphEditorShared.HitTestContext) -> (any NodeProtocol)? {
+        var closest: (any NodeProtocol)?
+        var minDist: CGFloat = .infinity
+        let adjustedRadius = AppConstants.hitScreenRadius / max(1.0, context.zoomScale) * 2.0  // Double boost at zoom >1; tune to 3.0 if needed
+        #if os(watchOS)
+        let boostedRadius = adjustedRadius * 2.0  // Extra for watch touch (fingers obscure)
+        #endif
+        for node in visibleNodes {
+            let nodeScreen = CoordinateTransformer.modelToScreen(
+                node.position,
+                effectiveCentroid: context.effectiveCentroid,
+                zoomScale: context.zoomScale,
+                offset: context.offset,
+                viewSize: context.viewSize
+            )
+            let dist = hypot(screenPos.x - nodeScreen.x, screenPos.y - nodeScreen.y)
+            if dist < boostedRadius && dist < minDist {
+                minDist = dist
+                closest = node
+            }
+        }
+        return closest
+    }
+    
+    static func closestEdge(at screenPos: CGPoint, visibleEdges: [GraphEdge], visibleNodes: [any NodeProtocol], context: HitTestContext) -> GraphEdge? {
+        var closestEdge: GraphEdge?
+        var minDist: CGFloat = .infinity
+        for edge in visibleEdges {
+            guard let fromNode = visibleNodes.first(where: { $0.id == edge.from }),
+                  let targetNode = visibleNodes.first(where: { $0.id == edge.target }) else { continue }
+            
+            let fromScreen = CoordinateTransformer.modelToScreen(
+                fromNode.position,
+                effectiveCentroid: context.effectiveCentroid,
+                zoomScale: context.zoomScale,
+                offset: context.offset,
+                viewSize: context.viewSize
+            )
+            let toScreen = CoordinateTransformer.modelToScreen(
+                targetNode.position,
+                effectiveCentroid: context.effectiveCentroid,
+                zoomScale: context.zoomScale,
+                offset: context.offset,
+                viewSize: context.viewSize
+            )
+            
+            let dist = pointToLineDistance(point: screenPos, from: fromScreen, to: toScreen)
+            let hitThreshold: CGFloat = 20.0
+            if dist < hitThreshold && dist < minDist {
+                minDist = dist
+                closestEdge = edge
+            }
+        }
+        return closestEdge
+    }
+    
+    static func pointToLineDistance(point: CGPoint, from startPoint: CGPoint, to endPoint: CGPoint) -> CGFloat {
+        let pointX = Double(point.x), pointY = Double(point.y)
+        let startX = Double(startPoint.x), startY = Double(startPoint.y)
+        let endX = Double(endPoint.x), endY = Double(endPoint.y)
+        
+        let lineVecX = endX - startX
+        let lineVecY = endY - startY
+        let lineLen = hypot(lineVecX, lineVecY)
+        
+        if lineLen == 0 {
+            return hypot(point.x - startPoint.x, point.y - startPoint.y)
+        }
+        
+        let pointVecX = pointX - startX
+        let pointVecY = pointY - startY
+        let dot = pointVecX * lineVecX + pointVecY * lineVecY
+        let denom = lineLen * lineLen
+        let projectionParam = dot / denom
+        let clampedParam = max(0.0, min(1.0, projectionParam))
+        
+        let projX = startX + lineVecX * clampedParam
+        let projY = startY + lineVecY * clampedParam
+        
+        let proj = CGPoint(x: CGFloat(projX), y: CGFloat(projY))
+        return hypot(point.x - proj.x, point.y - proj.y)
+    }
+    
+    static func modelToScreen(_ modelPos: CGPoint, context: HitTestContext) -> CGPoint {
+        return CoordinateTransformer.modelToScreen(
+            modelPos,
+            effectiveCentroid: context.effectiveCentroid,
+            zoomScale: context.zoomScale,
+            offset: context.offset,
+            viewSize: context.viewSize
+        )
+    }
+    
+    // Add any other utility functions extracted from the original file here
+}
diff --git a/GraphEditorWatch/Views/GraphCanvasView.swift b/GraphEditorWatch/Views/GraphCanvasView.swift
index 4325ae2..62e38a3 100644
--- a/GraphEditorWatch/Views/GraphCanvasView.swift
+++ b/GraphEditorWatch/Views/GraphCanvasView.swift
@@ -1,43 +1,9 @@
+// GraphCanvasView.swift
 import SwiftUI
 import WatchKit
 import GraphEditorShared
 import os  // Added for logging
 
-// Reverted: Custom wrapper for reliable crown focus (without crown—handled in ContentView now)
-struct FocusableView<Content: View>: View {
-    private static var logger: Logger {
-        Logger(subsystem: "io.handcart.GraphEditor", category: "focusableview")  // Changed to computed static
-    }
-    
-    let content: Content
-    @FocusState private var isFocused: Bool
-    
-    init(@ViewBuilder content: () -> Content) {
-        self.content = content()
-    }
-    
-    var body: some View {
-        content
-            .id("CrownFocusableCanvas")
-            .focused($isFocused)
-            .onAppear {
-                isFocused = true
-                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
-                    isFocused = true  // Double-focus for WatchOS reliability
-                }
-            }
-            .onChange(of: isFocused) { oldValue, newValue in
-                #if DEBUG
-                Self.logger.debug("Canvas focus changed: from \(oldValue) to \(newValue)")
-                #endif
-                
-                if !newValue {
-                    isFocused = true  // Auto-recover focus loss
-                }
-            }
-    }
-}
-
 struct GraphCanvasView: View {
     private static var logger: Logger {
         Logger(subsystem: "io.handcart.GraphEditor", category: "graphcanvasview")  // Changed to computed static for consistency
@@ -61,6 +27,7 @@ struct GraphCanvasView: View {
     @Binding var selectedEdgeID: UUID?
     @Binding var showOverlays: Bool
     @Binding var isAddingEdge: Bool
+    @Binding var isDragging: Bool
     
     init(
         viewModel: GraphViewModel,
@@ -78,7 +45,8 @@ struct GraphCanvasView: View {
         onUpdateZoomRanges: @escaping () -> Void,
         selectedEdgeID: Binding<UUID?>,
         showOverlays: Binding<Bool>,
-        isAddingEdge: Binding<Bool>
+        isAddingEdge: Binding<Bool>,
+        isDragging: Binding<Bool>  // Add this new parameter
     ) {
         self.viewModel = viewModel
         self._zoomScale = zoomScale
@@ -96,6 +64,7 @@ struct GraphCanvasView: View {
         self._selectedEdgeID = selectedEdgeID
         self._showOverlays = showOverlays
         self._isAddingEdge = isAddingEdge
+        self._isDragging = isDragging  // Add this
     }
     
     private var boundingBoxOverlay: some View {
@@ -122,111 +91,7 @@ struct GraphCanvasView: View {
             .opacity(0.5)
     }
     
-    private var accessibleCanvas: some View {
-        ZStack {
-            Canvas { context, size in
-                // Define visibleNodes and visibleEdges
-                let visibleNodes = viewModel.model.visibleNodes()
-                let visibleEdges = viewModel.model.visibleEdges()  // Fix: Use visibleEdges() instead of all edges
-                
-                #if DEBUG
-                Self.logger.debug("Visible: \(visibleNodes.count)")
-                #endif
-                
-                let effectiveCentroid = viewModel.effectiveCentroid
-                
-                // Draw edges (Pass 1: Lines only)
-                drawEdges(in: context, size: size, visibleEdges: visibleEdges, visibleNodes: visibleNodes, effectiveCentroid: effectiveCentroid)
-                
-                // Draw nodes
-                for node in visibleNodes {
-                    let nodeScreen = CoordinateTransformer.modelToScreen(
-                        node.position,
-                        effectiveCentroid: effectiveCentroid,
-                        zoomScale: zoomScale,
-                        offset: offset,
-                        viewSize: size
-                    )
-                    let nodeRadius = Constants.App.nodeModelRadius * zoomScale
-                    
-                    let isSelected = node.id == selectedNodeID
-                    let nodeColor: Color = isSelected ? .red : .blue
-                    let nodePath = Circle().path(in: CGRect(center: nodeScreen, size: CGSize(width: nodeRadius * 2, height: nodeRadius * 2)))
-                    context.fill(nodePath, with: .color(nodeColor))
-                    
-                    // Draw label
-                    let labelText = Text("\(node.label)").font(.system(size: 12 * zoomScale))
-                    context.draw(labelText, at: nodeScreen, anchor: .center)
-                }
-                
-                // Draw arrows (Pass 2: Over lines)
-                drawArrows(in: context, size: size, visibleEdges: visibleEdges, visibleNodes: visibleNodes, effectiveCentroid: effectiveCentroid)
-                
-                // Draw dragged node and potential edge
-                drawDraggedNodeAndPotentialEdge(in: context, size: size, effectiveCentroid: effectiveCentroid)
-            }
-            .frame(width: viewSize.width, height: viewSize.height)
-            .accessibilityLabel(accessibilityLabel())
-            .accessibilityIdentifier("GraphCanvas")
-            
-            if showOverlays {
-                boundingBoxOverlay
-            }
-        }
-    }
-    
-    var body: some View {
-        FocusableView {
-            accessibleCanvas
-                .modifier(GraphGesturesModifier(
-                    viewModel: viewModel,
-                    zoomScale: $zoomScale,
-                    offset: $offset,
-                    draggedNode: $draggedNode,
-                    dragOffset: $dragOffset,
-                    potentialEdgeTarget: $potentialEdgeTarget,
-                    selectedNodeID: $selectedNodeID,
-                    selectedEdgeID: $selectedEdgeID,
-                    viewSize: viewSize,
-                    panStartOffset: $panStartOffset,
-                    showMenu: $showMenu,
-                    maxZoom: maxZoom,
-                    crownPosition: $crownPosition,
-                    onUpdateZoomRanges: onUpdateZoomRanges,
-                    isAddingEdge: $isAddingEdge
-                ))
-        }
-    }
-    
-    private func accessibilityLabel() -> String {
-        let nodeCount = viewModel.model.nodes.count
-        let edgeCount = viewModel.model.edges.count
-
-        // Selected node label
-        let selectedNodeLabel: String = {
-            guard let id = selectedNodeID,
-                  let node = viewModel.model.nodes.first(where: { $0.id == id })
-            else { return "No node selected" }
-            return "Node \(node.label) selected"
-        }()
-
-        // Selected edge label
-        let selectedEdgeLabel: String = {
-            guard let id = selectedEdgeID,
-                  let edge = viewModel.model.edges.first(where: { $0.id == id })
-            else { return "No edge selected" }
-            let fromLabel = viewModel.model.nodes.first(where: { $0.id == edge.from })?.label
-            let toLabel = viewModel.model.nodes.first(where: { $0.id == edge.target })?.label
-            let fromText = fromLabel.map { String(describing: $0) } ?? "?"
-            let toText = toLabel.map { String(describing: $0) } ?? "?"
-            return "Edge from \(fromText) to \(toText) selected"
-        }()
-
-        return "Graph with \(nodeCount) nodes and \(edgeCount) edges. \(selectedNodeLabel). \(selectedEdgeLabel)."
-    }
-    
-    // Extracted: Draw edges (lines only)
-    func drawEdges(in context: GraphicsContext, size: CGSize, visibleEdges: [GraphEdge], visibleNodes: [any NodeProtocol], effectiveCentroid: CGPoint) {
+    private func drawEdges(in context: GraphicsContext, size: CGSize, visibleEdges: [GraphEdge], visibleNodes: [any NodeProtocol], effectiveCentroid: CGPoint) {
         for edge in visibleEdges {
             guard let fromNode = visibleNodes.first(where: { $0.id == edge.from }),
                   let toNode = visibleNodes.first(where: { $0.id == edge.target }) else { continue }
@@ -246,26 +111,17 @@ struct GraphCanvasView: View {
                 viewSize: size
             )
             
-            let linePath = Path { path in
-                path.move(to: fromScreen)
-                path.addLine(to: toScreen)
-            }
+            var path = Path()
+            path.move(to: fromScreen)
+            path.addLine(to: toScreen)
             
             let isSelected = edge.id == selectedEdgeID
             let edgeColor: Color = isSelected ? .red : .gray
-            let lineWidth: CGFloat = 2.0
-            
-            context.stroke(linePath, with: .color(edgeColor), lineWidth: lineWidth)
-            
-            #if DEBUG
-            Self.logger.debug("Drawing edge from x=\(fromScreen.x), y=\(fromScreen.y) to x=\(toScreen.x), y=\(toScreen.y) with color \(edgeColor.description)")
-            #endif
+            context.stroke(path, with: .color(edgeColor), lineWidth: 2 * zoomScale)
         }
     }
     
-    // Extracted: Draw arrows (over lines)
-    func drawArrows(in context: GraphicsContext, size: CGSize, visibleEdges: [GraphEdge], visibleNodes: [any NodeProtocol], effectiveCentroid: CGPoint) {
-        // Pass 2: Draw arrows (over lines)
+    private func drawArrows(in context: GraphicsContext, size: CGSize, visibleEdges: [GraphEdge], visibleNodes: [any NodeProtocol], effectiveCentroid: CGPoint) {
         for edge in visibleEdges {
             guard let fromNode = visibleNodes.first(where: { $0.id == edge.from }),
                   let toNode = visibleNodes.first(where: { $0.id == edge.target }) else { continue }
@@ -285,58 +141,37 @@ struct GraphCanvasView: View {
                 viewSize: size
             )
             
-            let direction = CGVector(dx: toScreen.x - fromScreen.x, dy: toScreen.y - fromScreen.y)
-            let length = hypot(direction.dx, direction.dy)
-            if length <= 0 { continue }
-            
-            let unitDx = direction.dx / length
-            let unitDy = direction.dy / length
-            let toRadiusScreen = toNode.radius * zoomScale
-            let boundaryPoint = CGPoint(x: toScreen.x - unitDx * toRadiusScreen,
-                                        y: toScreen.y - unitDy * toRadiusScreen)
-            
-            let lineAngle = atan2(unitDy, unitDx)
-            let arrowLength: CGFloat = 10.0
-            let arrowAngle: CGFloat = .pi / 6
-            let arrowPoint1 = CGPoint(
-                x: boundaryPoint.x - arrowLength * cos(lineAngle - arrowAngle),
-                y: boundaryPoint.y - arrowLength * sin(lineAngle - arrowAngle)
-            )
-            let arrowPoint2 = CGPoint(
-                x: boundaryPoint.x - arrowLength * cos(lineAngle + arrowAngle),
-                y: boundaryPoint.y - arrowLength * sin(lineAngle + arrowAngle)
-            )
+            let arrowSize = 10 * zoomScale
+            let delta = toScreen - fromScreen
+            let length = hypot(delta.x, delta.y)
+            if length == 0 { continue }
+            let unitDelta = delta / length
+            let arrowPoint = toScreen - unitDelta * (toNode.radius * zoomScale)
             
+            let perpX = -unitDelta.y
+            let perpY = unitDelta.x
             let arrowPath = Path { path in
-                path.move(to: boundaryPoint)
-                path.addLine(to: arrowPoint1)
-                path.move(to: boundaryPoint)
-                path.addLine(to: arrowPoint2)
+                path.move(to: arrowPoint)
+                path.addLine(to: arrowPoint - unitDelta * arrowSize + CGPoint(x: perpX * arrowSize / 2, y: perpY * arrowSize / 2))
+                path.move(to: arrowPoint)
+                path.addLine(to: arrowPoint - unitDelta * arrowSize - CGPoint(x: perpX * arrowSize / 2, y: perpY * arrowSize / 2))
             }
-            
-            let isSelected = edge.id == selectedEdgeID
-            let arrowColor: Color = isSelected ? .red : .gray
-            let arrowLineWidth: CGFloat = 3.0
-            
-            context.stroke(arrowPath, with: .color(arrowColor), lineWidth: arrowLineWidth)
-            
-            #if DEBUG
-            Self.logger.debug("Drawing arrow for edge \(edge.id.uuidString.prefix(8)) to boundary x=\(boundaryPoint.x), y=\(boundaryPoint.y)")
-            #endif
+            context.stroke(arrowPath, with: .color(.gray), lineWidth: 1 * zoomScale)
         }
     }
     
-    func drawDraggedNodeAndPotentialEdge(in context: GraphicsContext, size: CGSize, effectiveCentroid: CGPoint) {
-        // Draw dragged node and potential edge
+    private func drawDraggedNodeAndPotentialEdge(in context: GraphicsContext, size: CGSize, effectiveCentroid: CGPoint) {
         if let dragged = draggedNode {
             let draggedScreen = CoordinateTransformer.modelToScreen(
-                dragged.position + dragOffset,
-                effectiveCentroid: effectiveCentroid,
+                draggedNode?.position ?? .zero + dragOffset,  // Virtual position
+                effectiveCentroid: effectiveCentroid,  // Use virtual
                 zoomScale: zoomScale,
                 offset: offset,
                 viewSize: size
             )
-            context.fill(Circle().path(in: CGRect(center: draggedScreen, size: CGSize(width: Constants.App.nodeModelRadius * 2 * zoomScale, height: Constants.App.nodeModelRadius * 2 * zoomScale))), with: .color(.green))
+            let draggedRadius = Constants.App.nodeModelRadius * zoomScale
+            let draggedPath = Circle().path(in: CGRect(center: draggedScreen, size: CGSize(width: draggedRadius * 2, height: draggedRadius * 2)))
+            context.fill(draggedPath, with: .color(.green.opacity(0.5)))
             
             if let target = potentialEdgeTarget {
                 let targetScreen = CoordinateTransformer.modelToScreen(
@@ -346,33 +181,99 @@ struct GraphCanvasView: View {
                     offset: offset,
                     viewSize: size
                 )
-                let tempLinePath = Path { path in
-                    path.move(to: draggedScreen)
-                    path.addLine(to: targetScreen)
-                }
-                context.stroke(tempLinePath, with: .color(.green), lineWidth: 2.0)
+                var potentialPath = Path()
+                potentialPath.move(to: draggedScreen)
+                potentialPath.addLine(to: targetScreen)
+                context.stroke(potentialPath, with: .color(.green), style: StrokeStyle(lineWidth: 2 * zoomScale, dash: [5 * zoomScale]))
             }
         }
     }
-}
-
-struct Line: Shape, Animatable {
-    var from: CGPoint
-    var end: CGPoint
     
-    var animatableData: AnimatablePair<CGPoint.AnimatableData, CGPoint.AnimatableData> {
-        get { AnimatablePair(from.animatableData, end.animatableData) }
-        set {
-            from.animatableData = newValue.first
-            end.animatableData = newValue.second
+    private func drawNodes(in context: GraphicsContext, size: CGSize, visibleNodes: [any NodeProtocol], effectiveCentroid: CGPoint) {
+        for node in visibleNodes {
+            let nodeScreen = CoordinateTransformer.modelToScreen(
+                node.position,
+                effectiveCentroid: effectiveCentroid,
+                zoomScale: zoomScale,
+                offset: offset,
+                viewSize: size
+            )
+            let nodeRadius = Constants.App.nodeModelRadius * zoomScale
+            
+            let isSelected = node.id == selectedNodeID
+            let nodeColor: Color = isSelected ? .red : .blue
+            let nodePath = Circle().path(in: CGRect(center: nodeScreen, size: CGSize(width: nodeRadius * 2, height: nodeRadius * 2)))
+            context.fill(nodePath, with: .color(nodeColor))
+            
+            // Draw label
+            let labelText = Text("\(node.label)").font(.system(size: 12 * zoomScale))
+            context.draw(labelText, at: nodeScreen, anchor: .center)
+        }
+    }
+    
+    private var accessibleCanvas: some View {
+        ZStack {
+            Canvas { context, size in
+                // Define visibleNodes and visibleEdges
+                let visibleNodes = viewModel.model.visibleNodes()
+                let visibleEdges = viewModel.model.visibleEdges()  // Fix: Use visibleEdges() instead of all edges
+                
+#if DEBUG
+                Self.logger.debug("Visible: \(visibleNodes.count)")
+#endif
+                
+                let effectiveCentroid = viewModel.effectiveCentroid
+                
+                // Draw edges (Pass 1: Lines only)
+                drawEdges(in: context, size: size, visibleEdges: visibleEdges, visibleNodes: visibleNodes, effectiveCentroid: effectiveCentroid)
+                
+                // Draw nodes
+                drawNodes(in: context, size: size, visibleNodes: visibleNodes, effectiveCentroid: effectiveCentroid)
+                
+                // Draw arrows (Pass 2: Over lines)
+                drawArrows(in: context, size: size, visibleEdges: visibleEdges, visibleNodes: visibleNodes, effectiveCentroid: effectiveCentroid)
+                
+                // Draw dragged node and potential edge
+                drawDraggedNodeAndPotentialEdge(in: context, size: size, effectiveCentroid: effectiveCentroid)
+            }
+            .frame(width: viewSize.width, height: viewSize.height)
+            .accessibilityLabel(accessibilityLabel())
+            .accessibilityIdentifier("GraphCanvas")
+            
+            if showOverlays {
+                boundingBoxOverlay
+            }
         }
     }
     
-    func path(in rect: CGRect) -> Path {
-        var path = Path()
-        path.move(to: from)
-        path.addLine(to: end)
-        return path
+    var body: some View {
+        accessibleCanvas
+            .modifier(GraphGesturesModifier(
+                viewModel: viewModel,
+                zoomScale: $zoomScale,
+                offset: $offset,
+                draggedNode: $draggedNode,
+                dragOffset: $dragOffset,
+                potentialEdgeTarget: $potentialEdgeTarget,
+                selectedNodeID: $selectedNodeID,
+                selectedEdgeID: $selectedEdgeID,
+                viewSize: viewSize,
+                panStartOffset: $panStartOffset,
+                showMenu: $showMenu,
+                maxZoom: maxZoom,
+                crownPosition: $crownPosition,
+                onUpdateZoomRanges: onUpdateZoomRanges,
+                isAddingEdge: $isAddingEdge,
+                isDragging: $isDragging  // Add this to pass down the binding
+            ))
+    }
+    
+    private func accessibilityLabel() -> String {
+        let nodeCount = viewModel.model.visibleNodes().count
+        let edgeCount = viewModel.model.visibleEdges().count
+        let selectedNodeLabel = selectedNodeID.flatMap { id in viewModel.model.nodes.first(where: { $0.id == id })?.label }?.description ?? "none"
+        let selectedEdgeLabel = selectedEdgeID.flatMap { id in viewModel.model.edges.first(where: { $0.id == id }).map { "\($0.from) to \($0.target)" } } ?? "none"
+        return "Graph with \(nodeCount) nodes and \(edgeCount) edges. Selected node: \(selectedNodeLabel), selected edge: \(selectedEdgeLabel)."
     }
 }
 
@@ -381,3 +282,48 @@ extension CGRect {
         self.init(x: center.x - size.width / 2, y: center.y - size.height / 2, width: size.width, height: size.height)
     }
 }
+
+extension CGPoint {
+    static func - (lhs: CGPoint, rhs: CGPoint) -> CGPoint {
+        CGPoint(x: lhs.x - rhs.x, y: lhs.y - rhs.y)
+    }
+    
+    static func / (lhs: CGPoint, rhs: CGFloat) -> CGPoint {
+        CGPoint(x: lhs.x / rhs, y: lhs.y / rhs)
+    }
+}
+
+extension GraphCanvasView {
+    func moveDraggedNode() async {
+        guard let dragged = draggedNode else { return }
+        let modelDragOffset = dragOffset / zoomScale
+        if let index = viewModel.model.nodes.firstIndex(where: { $0.id == dragged.id }) {
+            let oldNode = viewModel.model.nodes[index]
+            let unwrapped = oldNode.unwrapped
+            let tentativePos = unwrapped.position + dragOffset
+            let bounds = viewModel.model.physicsEngine.simulationBounds
+            let newPos = CGPoint(
+                x: max(0, min(tentativePos.x, bounds.width)),
+                y: max(0, min(tentativePos.y, bounds.height))
+            )
+            let updatedNode: AnyNode
+            if let concrete = unwrapped as? Node {
+                let concreteUpdated = concrete.with(position: newPos, velocity: .zero)
+                updatedNode = AnyNode(concreteUpdated)
+            } else if let concrete = unwrapped as? ToggleNode {
+                let concreteUpdated = concrete.with(position: newPos, velocity: .zero)
+                updatedNode = AnyNode(concreteUpdated)
+            } else {
+                Self.logger.error("Unsupported node type for move: \(type(of: unwrapped))")
+                return
+            }
+            viewModel.model.nodes[index] = updatedNode
+            
+#if DEBUG
+            Self.logger.debug("Moved node \(unwrapped.label) to new position x=\(newPos.x), y=\(newPos.y)")
+#endif
+            
+            Task { await viewModel.model.startSimulation() }
+        }
+    }
+}
diff --git a/GraphEditorWatch/Views/GraphGesturesModifier.swift b/GraphEditorWatch/Views/GraphGesturesModifier.swift
index 959c857..b72729b 100644
--- a/GraphEditorWatch/Views/GraphGesturesModifier.swift
+++ b/GraphEditorWatch/Views/GraphGesturesModifier.swift
@@ -1,18 +1,8 @@
-//
-//  GraphGesturesModifier.swift
-//  GraphEditorWatch
-//
-//  Created by handcart on 2025-08-16
+// GraphGesturesModifier.swift
+// Reduced length by extracting utilities and heavy methods to extensions/utils
 
 import SwiftUI
-import WatchKit
 import GraphEditorShared
-import os.log  // Added for optimized logging
-
-enum HitType {
-    case node
-    case edge
-}
 
 struct GestureContext {
     let zoomScale: CGFloat
@@ -21,12 +11,6 @@ struct GestureContext {
     let effectiveCentroid: CGPoint
 }
 
-struct NodeDistanceInfo {
-    let label: Int
-    let screenPos: CGPoint
-    let dist: CGFloat
-}
-
 struct GraphGesturesModifier: ViewModifier {
     let viewModel: GraphViewModel
     @Binding var zoomScale: CGFloat
@@ -43,356 +27,206 @@ struct GraphGesturesModifier: ViewModifier {
     @Binding var crownPosition: Double
     let onUpdateZoomRanges: () -> Void
     @Binding var isAddingEdge: Bool
+    @Binding var isDragging: Bool
+    @State private var longPressLocation: CGPoint?
+    @State private var longPressTimer: Timer?
     
-    @State private var dragStartNode: (any NodeProtocol)?
-    @State private var isMovingSelectedNode: Bool = false
-    @State private var gestureStartCentroid: CGPoint = .zero
-    @State private var startLocation: CGPoint?
-    
-    private let dragStartThreshold: CGFloat = 10.0  // Increased for better tap vs. drag distinction
-    
-    // Optimized logger
-    private let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "gestures")
+    private let minDragDistance: CGFloat = 10.0
+    private let longPressDuration: TimeInterval = 0.5
     
     func body(content: Content) -> some View {
-        let dragGesture = DragGesture(minimumDistance: 0, coordinateSpace: .local)  // Zero for immediate detection
-            .onChanged { value in
-                let visibleNodes = viewModel.model.visibleNodes()  // Or viewModel.model.nodes if no visibleNodes()
-                let effectiveCentroid = viewModel.effectiveCentroid  // From ViewModel
-                let context = GestureContext(zoomScale: zoomScale, offset: offset, viewSize: viewSize, effectiveCentroid: effectiveCentroid)
-                handleDragChanged(value: value, visibleNodes: visibleNodes, context: context)
+        content
+            .digitalCrownRotation(
+                $crownPosition,
+                from: 0,
+                through: Double(AppConstants.crownZoomSteps),
+                sensitivity: .high,
+                isContinuous: true,
+                isHapticFeedbackEnabled: true
+            )
+            .onChange(of: crownPosition) { oldValue, newValue in
+                handleCrownRotation(oldValue: oldValue, newValue: newValue)
             }
-            .onEnded { value in
+            .onTapGesture { location in
+                let context = GestureContext(zoomScale: zoomScale, offset: offset, viewSize: viewSize, effectiveCentroid: viewModel.effectiveCentroid)
                 let visibleNodes = viewModel.model.visibleNodes()
-                let visibleEdges = viewModel.model.visibleEdges()  // NEW: Get visible edges (assume method exists; use model.edges if not)
-                let effectiveCentroid = viewModel.effectiveCentroid
-                let context = GestureContext(zoomScale: zoomScale, offset: offset, viewSize: viewSize, effectiveCentroid: effectiveCentroid)
-                handleDragEnded(value: value, visibleNodes: visibleNodes, visibleEdges: visibleEdges, context: context)
+                let visibleEdges = viewModel.model.visibleEdges()
+                handleTap(at: location, visibleNodes: visibleNodes, visibleEdges: visibleEdges, context: context)
             }
-        content
-            .highPriorityGesture(dragGesture)
+            .gesture(dragGesture)
+            .gesture(longPressGesture)
+            .simultaneousGesture(panGesture)
     }
-}
-
-extension GraphGesturesModifier {
     
-    /*
-    // Screen-space hit test for nodes (consistent usability)
-    func hitTestNodesInScreenSpace(at screenPos: CGPoint, visibleNodes: [any NodeProtocol], context: GestureContext) -> (any NodeProtocol)? {
-        var closestNode: (any NodeProtocol)?
-        var minScreenDist: CGFloat = .infinity
-        let minHitRadius: CGFloat = 10.0  // Minimum tappable radius in screen points for small zooms
-        let padding: CGFloat = 5.0  // Extra padding in screen points for forgiveness
-
-    #if DEBUG
-        var nodeDistances: [NodeDistanceInfo] = []  // For logging
-        logger.debug("Using centroid: \(String(describing: context.effectiveCentroid)) for this gesture")
-    #endif
-
-        for node in visibleNodes {
-            let safeZoom = max(context.zoomScale, 0.1)
-            let nodeScreenPos = CoordinateTransformer.modelToScreen(node.position, effectiveCentroid: context.effectiveCentroid, zoomScale: safeZoom, offset: context.offset, viewSize: context.viewSize)
-            let dist = distance(screenPos, nodeScreenPos)
-
-            let visibleRadius = node.radius * safeZoom
-            let nodeHitRadius = max(minHitRadius, visibleRadius) + padding  // Matches visible size, with min and padding
-
-    #if DEBUG
-            nodeDistances.append(NodeDistanceInfo(label: node.label, screenPos: nodeScreenPos, dist: dist))
-            // Optional: Log per-node hit radius for debugging
-            logger.debug("Node \(node.label): visibleRadius \(visibleRadius), nodeHitRadius \(nodeHitRadius)")
-    #endif
-
-            if dist <= nodeHitRadius && dist < minScreenDist {
-                minScreenDist = dist
-                closestNode = node
-            }
-        }
-
-    #if DEBUG
-        // Log sorted by distance for verification
-        nodeDistances.sort { $0.dist < $1.dist }
-        logger.debug("Hit Test Diagnostics: Tap at screen \(String(describing: screenPos))")
-        for info in nodeDistances.prefix(5) {  // Limit to top 5 closest
-            logger.debug("Node \(info.label): screen pos \(String(describing: info.screenPos)), dist \(info.dist)")
-        }
-        if let closest = closestNode {
-            logger.debug("Hit: Node \(closest.label) (dist \(minScreenDist))")
-        } else {
-            logger.debug("Miss: Closest dist \(nodeDistances.first?.dist ?? .infinity)")
+    private var dragGesture: some Gesture {
+            DragGesture(minimumDistance: minDragDistance)
+                .onChanged { value in
+                    // If handleDragChanged has async calls, it's fine as long as they're wrapped in Task inside it
+                    handleDragChanged(value: value)
+                }
+                .onEnded { value in
+                    handleDragEnded(value: value)
+                }
         }
-    #endif
-        return closestNode
+    
+    private var longPressGesture: some Gesture {
+        LongPressGesture(minimumDuration: longPressDuration)
+            .onEnded { _ in
+                handleLongPressEnded()
+            }
     }
     
-    // Screen-space hit test for edges (for consistency with nodes)
-    func hitTestEdgesInScreenSpace(at screenPos: CGPoint, visibleEdges: [GraphEdge], visibleNodes: [any NodeProtocol], context: GestureContext) -> GraphEdge? {
-        var closestEdge: GraphEdge?
-        var minScreenDist: CGFloat = .infinity
-        let hitScreenRadius: CGFloat = Constants.App.hitScreenRadius / 2  // Smaller for edges to avoid overlapping node taps
-        
-#if DEBUG
-        var edgeDistances: [(id: UUID, dist: CGFloat)] = []  // For logging
-#endif
-        
-        for edge in visibleEdges {
-            guard let fromNode = visibleNodes.first(where: { $0.id == edge.from }),
-                  let toNode = visibleNodes.first(where: { $0.id == edge.target }) else { continue }
-            
-            let safeZoom = max(context.zoomScale, 0.1)
-            let fromScreen = CoordinateTransformer.modelToScreen(fromNode.position, effectiveCentroid: context.effectiveCentroid, zoomScale: safeZoom, offset: context.offset, viewSize: context.viewSize)
-            let toScreen = CoordinateTransformer.modelToScreen(toNode.position, effectiveCentroid: context.effectiveCentroid, zoomScale: safeZoom, offset: context.offset, viewSize: context.viewSize)
-            let dist = pointToLineDistance(point: screenPos, from: fromScreen, endPoint: toScreen)
-            
-#if DEBUG
-            edgeDistances.append((edge.id, dist))
-#endif
-            
-            if dist < minScreenDist && dist <= hitScreenRadius {
-                minScreenDist = dist
-                closestEdge = edge
+    private var panGesture: some Gesture {
+        DragGesture()
+            .onChanged { value in
+                handlePanChanged(value: value)
+            }
+            .onEnded { value in
+                handlePanEnded(value: value)
             }
-        }
-        
-#if DEBUG
-        // Log sorted by distance
-        edgeDistances.sort { $0.dist < $1.dist }
-        logger.debug("Edge Hit Test at screen \(String(describing: screenPos))")
-        for (id, dist) in edgeDistances.prefix(3) {
-            logger.debug("Edge \(id): dist \(dist)")
-        }
-        if let closest = closestEdge {
-            logger.debug("Hit: Edge \(closest.id) (dist \(minScreenDist) <= \(hitScreenRadius))")
-        } else {
-            logger.debug("Miss: Closest dist \(edgeDistances.first?.dist ?? .infinity) > \(hitScreenRadius)")
-        }
-#endif
-        return closestEdge
     }
-    */
-     
-    private func resetGestureState() {
-        dragStartNode = nil
-        isMovingSelectedNode = false
-        draggedNode = nil
-        dragOffset = .zero
-        potentialEdgeTarget = nil
-        panStartOffset = nil
-        startLocation = nil
-        isAddingEdge = false
+    
+    private func handleCrownRotation(oldValue: Double, newValue: Double) {
+        let delta = newValue - oldValue
+        let zoomDelta = delta / Double(AppConstants.crownZoomSteps) * (maxZoom - 1.0)
+        zoomScale = (zoomScale + zoomDelta).clamped(to: 0.2...maxZoom)
         onUpdateZoomRanges()
-        gestureStartCentroid = .zero
     }
     
-    func handleTap(at location: CGPoint, visibleNodes: [any NodeProtocol], visibleEdges: [GraphEdge], context: GestureContext) -> Bool {
-    #if DEBUG
-        logger.debug("Hit Test Diagnostics: Tap at screen \(String(describing: location))")
-        logger.debug("Visible Nodes Count: \(visibleNodes.count)")
-        logger.debug("--------------------------------")
-    #endif
-      
-        // Pause simulation first (mimics handleTap)
-        Task { await viewModel.model.pauseSimulation() }
-      
-        let hitContext = HitTestContext(zoomScale: context.zoomScale, offset: context.offset, viewSize: context.viewSize, effectiveCentroid: context.effectiveCentroid)
-        let hitNode = HitTestHelper.closestNode(at: location, visibleNodes: visibleNodes, context: hitContext)
-        if let node = hitNode {
-            // Node hit: Handle toggle or selection (replicates viewModel.handleTap logic)
-            if let toggleNode = node as? ToggleNode {
-                // Toggle without selection
-                let updated = toggleNode.handlingTap()
-                if let index = viewModel.model.nodes.firstIndex(where: { $0.id == toggleNode.id }) {
-                    viewModel.model.nodes[index] = AnyNode(updated)
-                }
-                selectedNodeID = nil
-                selectedEdgeID = nil
-                logger.debug("Toggled ToggleNode \(toggleNode.label)")
-            } else {
-                // Select regular node (toggle off if already)
-                selectedNodeID = (node.id == selectedNodeID) ? nil : node.id
-                selectedEdgeID = nil
-                logger.debug("Selected regular Node \(node.label)")
-            }
-            // Sync with ViewModel (triggers onChange in ContentView)
-            viewModel.objectWillChange.send()
-          
-            // Resume simulation after delay (mimics handleTap)
-            Task { await viewModel.resumeSimulationAfterDelay() }
-            return true  // Hit occurred
-        } else {
-            // No node: Check edges
-            let hitEdge = HitTestHelper.closestEdge(at: location, visibleEdges: visibleEdges, visibleNodes: visibleNodes, context: hitContext)
-            if let edge = hitEdge {
-                // Select edge, clear node
-                selectedEdgeID = edge.id
-                selectedNodeID = nil
-                logger.debug("Tap selected Edge \(edge.id.uuidString.prefix(8))")
-              
-                // Sync with ViewModel (triggers onChange in ContentView)
-                viewModel.objectWillChange.send()
-              
-                // Resume simulation after delay (mimics handleTap)
-                Task { await viewModel.resumeSimulationAfterDelay() }
-                return true  // Hit occurred
-            } else {
-                // Miss: Clear all
-                selectedNodeID = nil
-                selectedEdgeID = nil
-                logger.debug("Tap missed; cleared selections")
-              
-                // Sync with ViewModel (triggers onChange in ContentView)
-                viewModel.objectWillChange.send()
-              
-                // Resume simulation after delay (mimics handleTap)
-                Task { await viewModel.resumeSimulationAfterDelay() }
-                return false  // No hit
-            }
+    private var currentCentroid: CGPoint {
+        if let node = draggedNode {
+            return node.position + dragOffset  // Virtual for single selected node drag
         }
+        return viewModel.effectiveCentroid
     }
-  
-    private func handleDragChanged(value: DragGesture.Value, visibleNodes: [any NodeProtocol], context: GestureContext) {
-        let location = value.location
-        let translation = value.translation
-        let dragMagnitude = distance(.zero, CGPoint(x: translation.width, y: translation.height))
-      
-        // Initial hit if no dragStartNode (start of drag)
-        if dragStartNode == nil {
-            let hitContext = HitTestContext(zoomScale: context.zoomScale, offset: context.offset, viewSize: context.viewSize, effectiveCentroid: context.effectiveCentroid)
-            let hitNode = HitTestHelper.closestNode(at: location, visibleNodes: visibleNodes, context: hitContext)
-            if let node = hitNode {
-                dragStartNode = node
-                draggedNode = node
-                dragOffset = .zero
-                isAddingEdge = true  // Enter edge creation mode
-                logger.debug("Drag of \(dragMagnitude) started from Node \(node.label)")
-            } else {
-                // Pan the canvas instead
-                if panStartOffset == nil {
-                    panStartOffset = offset
-                }
-                let delta = CGSize(width: translation.width, height: translation.height)
-                offset = panStartOffset! + delta
+}
+
+extension GraphGesturesModifier {
+    func handleTap(at screenPos: CGPoint, visibleNodes: [any NodeProtocol], visibleEdges: [GraphEdge], context: GestureContext) {
+        _ = CoordinateTransformer.screenToModel(screenPos, effectiveCentroid: context.effectiveCentroid, zoomScale: context.zoomScale, offset: context.offset, viewSize: context.viewSize)
+        
+        let hitContext = HitTestContext(zoomScale: context.zoomScale, offset: context.offset, viewSize: context.viewSize, effectiveCentroid: context.effectiveCentroid)
+        let hitNode = GestureUtils.closestNode(at: screenPos, visibleNodes: visibleNodes, context: hitContext)
+        
+        if let node = hitNode {
+            selectedNodeID = node.id
+            selectedEdgeID = nil
+            if isAddingEdge, let from = draggedNode {
+                addEdge(from: from.id, to: node.id)
             }
-            startLocation = location  // For tap threshold in onEnded
-            gestureStartCentroid = context.effectiveCentroid
             return
         }
-      
-        // Ongoing drag: Update drag offset and check for potential target
-        if let node = draggedNode {
-            dragOffset = CGPoint(x: translation.width / zoomScale, y: translation.height / zoomScale)
-            let hitContext = HitTestContext(zoomScale: context.zoomScale, offset: context.offset, viewSize: context.viewSize, effectiveCentroid: context.effectiveCentroid)
-            let potential = HitTestHelper.closestNode(at: location, visibleNodes: visibleNodes, context: hitContext)
-            potentialEdgeTarget = (potential?.id != node.id) ? potential : nil  // Avoid self-edges
-            if let target = potentialEdgeTarget {
-                logger.debug("Potential edge target: Node \(target.label)")
-            }
+        
+        let hitEdge = GestureUtils.closestEdge(at: screenPos, visibleEdges: visibleEdges, visibleNodes: visibleNodes, context: hitContext)
+        if let edge = hitEdge {
+            selectedEdgeID = edge.id
+            selectedNodeID = nil
+            return
         }
+        
+        selectedNodeID = nil
+        selectedEdgeID = nil
     }
     
-    private func handleDragEnded(value: DragGesture.Value, visibleNodes: [any NodeProtocol], visibleEdges: [GraphEdge], context: GestureContext) {
-        let location = value.location
-        let translation = value.translation
-        let dragMagnitude = distance(.zero, CGPoint(x: translation.width, y: translation.height))
-        
-        // Defer cleanup (ensures reset even on errors/taps)
-        defer { resetGestureState() }
-        
-        // Early exit for taps (short drag) - enhanced for node/edge selection
-        if let start = startLocation, dragMagnitude < dragStartThreshold, distance(start, location) < dragStartThreshold {
-            let wasHit = handleTap(at: location, visibleNodes: visibleNodes, visibleEdges: visibleEdges, context: context)
-            if wasHit {
-                WKInterfaceDevice.current().play(.click)  // Subtler haptic feedback (short tick/tap) on successful hit
-            }
-            return  // Exit early
-        }
+    // Keep this sync; wrap async inside Task
+    private func handleDragChanged(value: DragGesture.Value) {
+        isDragging = true
+        let screenPos = value.location
+        let context = HitTestContext(zoomScale: zoomScale, offset: offset, viewSize: viewSize, effectiveCentroid: currentCentroid)
         
-        print("Processing as drag: magnitude \(dragMagnitude), translation \(translation)")
+        var localDraggedNode: (any NodeProtocol)? = draggedNode  // Local to handle immediate set
         
-        if let dragged = draggedNode {
-            Task { await viewModel.model.snapshot() }
-            let modelDragOffset = CGPoint(x: translation.width / zoomScale, y: translation.height / zoomScale)
-            print("Drag offset in model: \(modelDragOffset)")
+        if localDraggedNode == nil {
+            let visibleNodes = viewModel.model.visibleNodes()
+            print("Drag start: Visible nodes count = \(visibleNodes.count)")  // Debug: Confirm nodes
             
-            if let target = potentialEdgeTarget, target.id != dragged.id, isAddingEdge {
-                handleEdgeCreation(from: dragged, to: target, translation: translation)
+            if let closest = GestureUtils.closestNode(at: screenPos, visibleNodes: visibleNodes, context: context) {
+                print("Node hit: ID \(closest.id.uuidString)")  // Debug: Confirm hit (fixed UUID to String)
+                draggedNode = closest  // Set state
+                localDraggedNode = closest  // Update local immediately
+                dragOffset = .zero
+                viewModel.selectedNodeID = closest.id
+                
+                // Wrap async call
+                Task {
+                    await viewModel.model.pauseSimulation()
+                    print("Drag started: Simulation paused")  // Confirm in console
+                }
+            } else if let _ = GestureUtils.closestEdge(at: screenPos, visibleEdges: viewModel.model.visibleEdges(), visibleNodes: viewModel.model.visibleNodes(), context: context) {
+                // Handle edge drag if needed (add Task if async)
             } else {
-                handleNodeMovement(for: dragged, with: modelDragOffset)
+                print("No node hit; falling back to pan")  // Debug: Why pan?
+                panStartOffset = offset
             }
         }
-        withAnimation(.spring(duration: 0.3, bounce: 0.2)) {
-            onUpdateZoomRanges()
+        
+        if let node = localDraggedNode {
+            let modelDelta = CGPoint(x: value.translation.width / zoomScale, y: value.translation.height / zoomScale)
+            dragOffset = modelDelta
+            isAddingEdge = distance(value.predictedEndLocation, value.startLocation) > 30.0  // Uses global distance func
+            if isAddingEdge {
+                if let target = GestureUtils.closestNode(at: value.predictedEndLocation, visibleNodes: viewModel.model.visibleNodes().filter { $0.id != node.id }, context: context) {
+                    potentialEdgeTarget = target
+                } else {
+                    potentialEdgeTarget = nil
+                }
+            }
+        } else if let startOffset = panStartOffset {
+            offset = startOffset + CGSize(width: value.translation.width, height: value.translation.height)
         }
     }
-    
-    private func handleEdgeCreation(from dragged: any NodeProtocol, to target: any NodeProtocol, translation: CGSize) {
-        // Duplicate check with logging
-        let exists = viewModel.model.edges.contains { edge in
-            (edge.from == dragged.id && edge.target == target.id) || (edge.from == target.id && edge.target == dragged.id)
+
+    // Keep this sync; wrap async inside Task
+    private func handleDragEnded(value: DragGesture.Value) {
+        guard let node = draggedNode else {
+            print("Drag end: No draggedNode (likely pan mode)")  // Debug: Why skipped?
+            panStartOffset = nil
+            isDragging = false
+            return
         }
-        if !exists {
-            print("No duplicate; adding edge")
-            // Heuristic: Downward = hierarchy
-            let type = (translation.height > 0) ? .hierarchy : viewModel.pendingEdgeType
-            viewModel.pendingEdgeType = type  // Update for UI
-            Task {
-                await viewModel.addEdge(from: dragged.id, to: target.id, type: type)  // Async call
+        
+        let modelDelta = CGPoint(x: value.translation.width / zoomScale, y: value.translation.height / zoomScale)
+        
+        // Wrap all async + state clearing to ensure order
+        Task {
+            await viewModel.model.updateNodePosition(id: node.id, delta: modelDelta)
+            if let target = potentialEdgeTarget, isAddingEdge {
+                print("Adding edge from \(node.id.uuidString) to \(target.id.uuidString)")  // Debug: Confirm add (fixed UUID to String)
+                await viewModel.addEdge(from: node.id, to: target.id, type: viewModel.pendingEdgeType)
+            } else {
+                print("No edge added: target=\(potentialEdgeTarget?.id.uuidString ?? "nil"), isAddingEdge=\(isAddingEdge)")  // Debug: Why not? (fixed UUID to String)
             }
-            print("Created edge of type \(type.rawValue) from node \(dragged.label) to \(target.label)")
+            await viewModel.model.resumeSimulation()
+            print("Drag ended: Simulation resumed")
+            
+            // Clear states after async completes (prevents premature clearing)
+            draggedNode = nil
+            dragOffset = .zero
+            potentialEdgeTarget = nil
             isAddingEdge = false
-        } else {
-            print("Duplicate edge ignored between \(dragged.label) and \(target.label)")
+            panStartOffset = nil
+            isDragging = false
         }
     }
     
-    private func handleNodeMovement(for dragged: any NodeProtocol, with modelDragOffset: CGPoint) {
-        // No target: Move the node (with casts for .with, as it's not on protocol)
-        if let index = viewModel.model.nodes.firstIndex(where: { $0.id == dragged.id }) {
-            let oldNode = viewModel.model.nodes[index]
-            let unwrapped = oldNode.unwrapped
-            let newPos = unwrapped.position + modelDragOffset
-            let updatedNode: AnyNode
-            if let concrete = unwrapped as? Node {
-                let concreteUpdated = concrete.with(position: newPos, velocity: .zero)
-                updatedNode = AnyNode(concreteUpdated)
-            } else if let concrete = unwrapped as? ToggleNode {
-                let concreteUpdated = concrete.with(position: newPos, velocity: .zero)
-                updatedNode = AnyNode(concreteUpdated)
-            } else {
-                logger.error("Unsupported node type for move: \(type(of: unwrapped))")
-                return
-            }
-            viewModel.model.nodes[index] = updatedNode
-            print("Moved node \(unwrapped.label) to new position \(newPos)")
-            Task { await viewModel.model.startSimulation() }
+    private func handleLongPressEnded() {
+        showMenu = true
+    }
+    
+    private func handlePanChanged(value: DragGesture.Value) {
+        if panStartOffset == nil {
+            panStartOffset = offset
         }
+        offset = CGSize(width: panStartOffset!.width + value.translation.width, height: panStartOffset!.height + value.translation.height)
     }
-}
-extension GraphGesturesModifier {
-    public func pointToLineDistance(point: CGPoint, from startPoint: CGPoint, endPoint: CGPoint) -> CGFloat {
-        let pointX = Double(point.x), pointY = Double(point.y)
-        let startX = Double(startPoint.x), startY = Double(startPoint.y)
-        let endX = Double(endPoint.x), endY = Double(endPoint.y)
-        
-        let lineVecX = endX - startX
-        let lineVecY = endY - startY
-        let lineLen = hypot(lineVecX, lineVecY)
-        
-        if lineLen == 0 {
-            return distance(point, startPoint)
+    
+    private func handlePanEnded(value: DragGesture.Value) {
+        panStartOffset = nil
+    }
+    
+    private func addEdge(from fromID: NodeID, to targetID: NodeID) {
+        Task {
+            await viewModel.addEdge(from: fromID, to: targetID, type: viewModel.pendingEdgeType)
         }
-        
-        let pointVecX = pointX - startX
-        let pointVecY = pointY - startY
-        let dot = pointVecX * lineVecX + pointVecY * lineVecY
-        let denom = lineLen * lineLen
-        let projectionParam = dot / denom
-        let clampedParam = max(0.0, min(1.0, projectionParam))
-        
-        let projX = startX + lineVecX * clampedParam
-        let projY = startY + lineVecY * clampedParam
-        
-        let proj = CGPoint(x: CGFloat(projX), y: CGFloat(projY))
-        return distance(point, proj)
     }
 }
diff --git a/GraphEditorWatch/Views/GraphUtilities.swift b/GraphEditorWatch/Views/GraphUtilities.swift
index a022d6c..d14d060 100644
--- a/GraphEditorWatch/Views/GraphUtilities.swift
+++ b/GraphEditorWatch/Views/GraphUtilities.swift
@@ -48,6 +48,7 @@ struct InnerViewConfig {
     let onCenterGraph: () -> Void
     let isAddingEdge: Binding<Bool>
     let isSimulatingBinding: Binding<Bool>
+    let isDragging: Binding<Bool>
     
     init(
         geo: GeometryProxy,
@@ -68,7 +69,8 @@ struct InnerViewConfig {
         canvasFocus: FocusState<Bool>,
         onCenterGraph: @escaping () -> Void,
         isAddingEdge: Binding<Bool>,
-        isSimulatingBinding: Binding<Bool>  // NEW: Add this param
+        isSimulatingBinding: Binding<Bool>,  // NEW: Add this param
+        isDragging: Binding<Bool>
     ) {
         self.geo = geo
         self.viewModel = viewModel
@@ -89,5 +91,6 @@ struct InnerViewConfig {
         self.onCenterGraph = onCenterGraph
         self.isAddingEdge = isAddingEdge
         self.isSimulatingBinding = isSimulatingBinding  // NEW: Assign it
+        self.isDragging = isDragging
     }
 }
diff --git a/GraphEditorWatch/Views/InnerView.swift b/GraphEditorWatch/Views/InnerView.swift
index 7c61afa..9cb8271 100644
--- a/GraphEditorWatch/Views/InnerView.swift
+++ b/GraphEditorWatch/Views/InnerView.swift
@@ -39,7 +39,8 @@ struct InnerView: View {
             onUpdateZoomRanges: { config.updateZoomRangesHandler(config.geo.size) },
             selectedEdgeID: config.selectedEdgeID,
             showOverlays: config.showOverlays,
-            isAddingEdge: config.isAddingEdge
+            isAddingEdge: config.isAddingEdge,
+            isDragging: config.isDragging
         )
             .accessibilityIdentifier("GraphCanvas")
             .focused(config.canvasFocus.projectedValue)
diff --git a/GraphEditorWatchTests/GraphGesturesModifierTests.swift b/GraphEditorWatchTests/GraphGesturesModifierTests.swift
index fff736a..0d7a483 100644
--- a/GraphEditorWatchTests/GraphGesturesModifierTests.swift
+++ b/GraphEditorWatchTests/GraphGesturesModifierTests.swift
@@ -1,20 +1,12 @@
-//
-//  GraphGesturesModifierTests.swift
-//  GraphEditorWatch
-//
-//  Created by handcart on 9/25/25.
-//
 import Testing
 import SwiftUI
 @testable import GraphEditorWatch
-@testable import GraphEditorShared
+@testable import GraphEditorShared  // Ensure shared module is imported for types if needed
 
 struct GraphGesturesModifierTests {
-    private func setupViewModel() async -> GraphViewModel {
-        let storage = MockGraphStorage()
-        let physicsEngine = PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
-        let model = await MainActor.run { GraphModel(storage: storage, physicsEngine: physicsEngine) }
-        return await MainActor.run { GraphViewModel(model: model) }
+    @MainActor private func setupViewModel() async -> GraphViewModel {
+        let model = GraphModel(storage: MockGraphStorage(), physicsEngine: PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300)))
+        return GraphViewModel(model: model)
     }
     
     private func createModifier(viewModel: GraphViewModel,
@@ -35,37 +27,35 @@ struct GraphGesturesModifierTests {
             maxZoom: 5.0,
             crownPosition: .constant(0.0),
             onUpdateZoomRanges: {},
-            isAddingEdge: .constant(false)
+            isAddingEdge: .constant(false),
+            isDragging: .constant(false)
         )
     }
     
     @MainActor @Test func testHitTestNodesInScreenSpace() async {
         let viewModel = await setupViewModel()
         _ = createModifier(viewModel: viewModel,
-                                      selectedNodeID: .constant(nil),
-                                      selectedEdgeID: .constant(nil))
+                           selectedNodeID: .constant(nil),
+                           selectedEdgeID: .constant(nil))
         
         let nodes = [AnyNode(Node(label: 1, position: CGPoint(x: 100, y: 100)))]
-        let context = GestureContext(zoomScale: 1.0, offset: CGSize.zero, viewSize: CGSize(width: 300, height: 300), effectiveCentroid: CGPoint.zero)
+        let context = GraphEditorShared.HitTestContext(zoomScale: 1.0, offset: CGSize.zero, viewSize: CGSize(width: 300, height: 300), effectiveCentroid: CGPoint.zero)
         // Compute screen pos: viewCenter (150,150) + zoom * (model - centroid) + offset = (150,150) + 1*(100-0,100-0) + (0,0) = (250,250)
         let screenTapPos = CGPoint(x: 250, y: 250)
-        let hitContext = HitTestContext(zoomScale: context.zoomScale, offset: context.offset, viewSize: context.viewSize, effectiveCentroid: context.effectiveCentroid)
-        let hitNode = HitTestHelper.closestNode(at: screenTapPos, visibleNodes: nodes, context: hitContext)
+        let hitContext = GraphEditorShared.HitTestContext(zoomScale: context.zoomScale, offset: context.offset, viewSize: context.viewSize, effectiveCentroid: context.effectiveCentroid)
+        let hitNode = GestureUtils.closestNode(at: screenTapPos, visibleNodes: nodes, context: hitContext)  // Use GestureUtils (assuming it's where closestNode is now)
         #expect(hitNode != nil, "Should hit node within radius")
     }
     
     @Test func testPointToLineDistance() async {
         let viewModel = await setupViewModel()
-        let modifier = createModifier(viewModel: viewModel,
-                                      selectedNodeID: .constant(nil),
-                                      selectedEdgeID: .constant(nil))
         let dist = await MainActor.run {
-            modifier.pointToLineDistance(point: CGPoint(x: 0, y: 1), from: CGPoint.zero, endPoint: CGPoint(x: 2, y: 0))
+            GestureUtils.pointToLineDistance(point: CGPoint(x: 0, y: 1), from: CGPoint.zero, to: CGPoint(x: 2, y: 0))  // Updated to static call on GestureUtils
         }
         #expect(dist == 1.0, "Perpendicular distance to line")
     }
     
-    @Test func testHandleTap() async {
+    @MainActor @Test func testHandleTap() async {
         let viewModel = await setupViewModel()
         var testSelectedNodeID: NodeID?
         var testSelectedEdgeID: UUID?
diff --git a/swift_ui_context_parts/part-1.txt b/swift_ui_context_parts/part-1.txt
index a417f88..7784cf4 100644
--- a/swift_ui_context_parts/part-1.txt
+++ b/swift_ui_context_parts/part-1.txt
@@ -1,7 +1,7 @@
 ## Focused Project Concatenation
 This file includes only UI, interactivity, model, and core logic files.
 Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
-Current date: 2025-10-10 13:25:45
+Current date: 2025-10-12 10:03:03
 Table of Contents:
 1. GraphEditorShared/Sources/GraphEditorShared/AttractionCalculator.swift
 2. GraphEditorShared/Sources/GraphEditorShared/CenteringCalculator.swift
@@ -167,7 +167,7 @@ public enum Constants {
 ----------------------------------------------------------------------------------------------------
 File: CoordinateTransformer.swift
 Path: GraphEditorShared/Sources/GraphEditorShared/CoordinateTransformer.swift
-Last modified: 2025-09-26 08:05:37
+Last modified: 2025-10-11 18:46:49
 
 Contents:
 //
@@ -179,10 +179,13 @@ Contents:
 
 import CoreGraphics
 import SwiftUI  // For GeometryProxy if enabled
+import os  // Added for Logger
 
 /// Utility for converting between model (graph) coordinates and screen (view) coordinates.
 public struct CoordinateTransformer {
     
+    private static let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "coordinate")  // Added for structured logging
+    
     /// Converts a model position to screen coordinates.
     /// - Parameters:
     ///   - modelPos: The position in model space.
@@ -204,17 +207,7 @@ public struct CoordinateTransformer {
         let relativePos = modelPos - effectiveCentroid
         let scaledPos = relativePos * zoomScale
         let screenPos = viewCenter + scaledPos + CGPoint(x: offset.width, y: offset.height)
-        
-        // Optional: Adjust for safe areas (symmetric to screenToModel)
-        // if let geo = geometry {
-        //     screenPos.x += geo.safeAreaInsets.leading
-        //     screenPos.y += geo.safeAreaInsets.top
-        // }
-        
-        #if DEBUG
-        print("modelToScreen: Model \(modelPos) -> Screen \(screenPos), Zoom \(zoomScale), Offset \(offset), Centroid \(effectiveCentroid), ViewSize \(viewSize)")
-        #endif
-        
+              
         return screenPos
     }
     
@@ -251,7 +244,7 @@ public struct CoordinateTransformer {
         let modelPos = effectiveCentroid + unscaled
         
         #if DEBUG
-        print("screenToModel: Screen \(screenPos) -> Model \(modelPos), Zoom \(safeZoom), Offset \(panOffset), Centroid \(effectiveCentroid), ViewSize \(viewSize)")
+        logger.debug("screenToModel: Screen \(screenPos.x), \(screenPos.y) -> Model \(modelPos.x), \(modelPos.y), Zoom \(safeZoom), Offset \(panOffset.x), \(panOffset.y), Centroid \(effectiveCentroid.x), \(effectiveCentroid.y), ViewSize \(viewSize.width), \(viewSize.height)")
         #endif
         
         // Round to 3 decimals to eliminate floating-point drift
@@ -405,7 +398,7 @@ private let logger = OSLog(subsystem: "io.handcart.GraphEditor", category: "stor
 ----------------------------------------------------------------------------------------------------
 File: GraphModel+EdgesNodes.swift
 Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+EdgesNodes.swift
-Last modified: 2025-10-03 14:29:35
+Last modified: 2025-10-11 16:13:22
 
 Contents:
 //
@@ -539,6 +532,18 @@ extension GraphModel {
         objectWillChange.send()
         await resumeSimulation()
     }
+    
+    public func updateNodePosition(id: NodeID, delta: CGPoint) async {
+            // Implementation from docs: Find node, update position, snapshot, resume sim
+            await snapshot()
+            if let index = nodes.firstIndex(where: { $0.id == id }) {
+                var updated = nodes[index].unwrapped
+                updated.position += delta
+                nodes[index] = AnyNode(updated)
+            }
+            objectWillChange.send()
+            await resumeSimulation()
+        }
 }
 ----------------------------------------------------------------------------------------------------
 File: GraphModel+Helpers.swift
@@ -664,7 +669,7 @@ extension GraphModel {
 ----------------------------------------------------------------------------------------------------
 File: GraphModel+Simulation.swift
 Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel+Simulation.swift
-Last modified: 2025-10-07 16:16:49
+Last modified: 2025-10-12 09:49:31
 
 Contents:
 //
@@ -678,24 +683,30 @@ import Foundation
 @available(iOS 16.0, watchOS 6.0, *)
 extension GraphModel {
     public func startSimulation() async {
-        await stopSimulation()  // Cancel any ongoing
-        isSimulating = true
-        isStable = false
-        await simulator.startSimulation()
-    }
-    
-    public func pauseSimulation() async {
-        await stopSimulation()
-    }
-    
-    public func resumeSimulation() async {
-        await startSimulation()
-    }
-    
-    public func stopSimulation() async {
-        await simulator.stopSimulation()
-        isSimulating = false
-    }
+            await stopSimulation()  // Cancel any ongoing
+            isSimulating = true
+            isStable = false
+            await simulator.startSimulation()
+        }
+        
+        public func pauseSimulation() async {
+            physicsEngine.isPaused = true  // NEW: Set flag to skip steps in simulator loop (no cancel)
+            isSimulating = false  // Update state (optional: keeps UI consistent)
+        }
+        
+        public func resumeSimulation() async {
+            physicsEngine.isPaused = false  // NEW: Unset flag to resume computations
+            isSimulating = true
+            // NEW: If task ended naturally while paused, restart it
+            if simulator.simulationTask == nil {
+                await startSimulation()
+            }
+        }
+        
+        public func stopSimulation() async {
+            await simulator.stopSimulation()
+            isSimulating = false
+        }
 }
 ----------------------------------------------------------------------------------------------------
 File: GraphModel+Storage.swift
diff --git a/swift_ui_context_parts/part-2.txt b/swift_ui_context_parts/part-2.txt
index 653da1d..8a1757d 100644
--- a/swift_ui_context_parts/part-2.txt
+++ b/swift_ui_context_parts/part-2.txt
@@ -1,7 +1,7 @@
 ## Focused Project Concatenation
 This file includes only UI, interactivity, model, and core logic files.
 Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
-Current date: 2025-10-10 13:25:45
+Current date: 2025-10-12 10:03:03
 Table of Contents:
 1. GraphEditorShared/Sources/GraphEditorShared/GraphSimulator.swift
 2. GraphEditorShared/Sources/GraphEditorShared/GraphTypes.swift
@@ -11,7 +11,7 @@ Table of Contents:
 6. GraphEditorShared/Sources/GraphEditorShared/PhysicsEngine.swift--------------------------------------------------
 File: GraphSimulator.swift
 Path: GraphEditorShared/Sources/GraphEditorShared/GraphSimulator.swift
-Last modified: 2025-10-08 15:39:06
+Last modified: 2025-10-12 09:50:46
 
 Contents:
 //
@@ -111,14 +111,19 @@ class GraphSimulator {
     }
     
     internal func runSimulationLoop(baseInterval: TimeInterval, nodeCount: Int) async {
-        print("Starting sim loop with nodeCount: \(nodeCount), maxIterations: 500")  // NEW: Confirm entry
+        print("Starting sim loop with nodeCount: \(nodeCount), maxIterations: 500")
         var iterations = 0
         let maxIterations = 500
         while !Task.isCancelled && iterations < maxIterations {
+            if physicsEngine.isPaused {  // NEW: Skip if paused, but keep loop alive (aligns with test subclass)
+                try? await Task.sleep(for: .milliseconds(20))  // Short sleep to avoid CPU spin
+                continue
+            }
+            
             let shouldContinue = await performSimulationStep(baseInterval: baseInterval, nodeCount: nodeCount)
-            physicsEngine.alpha *= (1 - Constants.Physics.alphaDecay)  // New: Decay alpha
+            physicsEngine.alpha *= (1 - Constants.Physics.alphaDecay)
             iterations += 1
-            print("Iteration \(iterations): shouldContinue = \(shouldContinue)")  // NEW: Per-iter log
+            // print("Iteration \(iterations): shouldContinue = \(shouldContinue)")
             if !shouldContinue {
                 print("Simulation stabilized after \(iterations) iterations")
                 break
@@ -129,18 +134,18 @@ class GraphSimulator {
         }
         self.onStable?()
     }
-    
+
     internal func performSimulationStep(baseInterval: TimeInterval, nodeCount: Int) async -> Bool {
-#if os(watchOS)
+    #if os(watchOS)
         if await WKApplication.shared().applicationState != .active { return false }
-#endif
-        
-        if physicsEngine.isPaused { return false } // Added: Stop loop if paused to prevent infinite loop
-        
+    #endif
+            
+        // REMOVED: if physicsEngine.isPaused { return false }  // Now handled in loop to skip without breaking
+            
         let result: SimulationStepResult = await Task.detached {
             await self.computeSimulationStep()
         }.value
-        print("Step: Total velocity = \(result.totalVelocity)")
+        // print("Step: Total velocity = \(result.totalVelocity)")
         await self.setNodes(result.updatedNodes)
         
         recentVelocities.append(result.totalVelocity)
@@ -919,7 +924,7 @@ public class PersistenceManager: GraphStorage {
 ----------------------------------------------------------------------------------------------------
 File: PhysicsEngine.swift
 Path: GraphEditorShared/Sources/GraphEditorShared/PhysicsEngine.swift
-Last modified: 2025-10-08 15:39:06
+Last modified: 2025-10-11 12:15:40
 
 Contents:
 //
@@ -938,7 +943,7 @@ import CoreGraphics
 @available(watchOS 9.0, *)
 public class PhysicsEngine {
     private let physicsLogger = OSLog(subsystem: "io.handcart.GraphEditor", category: "physics")
-    var simulationBounds: CGSize
+    public var simulationBounds: CGSize
     private var stepCount: Int = 0
     private let maxNodesForQuadtree = 200
     private let symmetricFactor: CGFloat = 0.5
diff --git a/swift_ui_context_parts/part-3.txt b/swift_ui_context_parts/part-3.txt
index 35cdec1..42bc86b 100644
--- a/swift_ui_context_parts/part-3.txt
+++ b/swift_ui_context_parts/part-3.txt
@@ -1,7 +1,7 @@
 ## Focused Project Concatenation
 This file includes only UI, interactivity, model, and core logic files.
 Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
-Current date: 2025-10-10 13:25:45
+Current date: 2025-10-12 10:03:04
 Table of Contents:
 1. GraphEditorShared/Sources/GraphEditorShared/PositionUpdater.swift
 2. GraphEditorShared/Sources/GraphEditorShared/Protocols.swift
@@ -715,7 +715,7 @@ public struct ToggleNode: NodeProtocol, Equatable {
 ----------------------------------------------------------------------------------------------------
 File: Utilities.swift
 Path: GraphEditorShared/Sources/GraphEditorShared/Utilities.swift
-Last modified: 2025-09-26 07:55:10
+Last modified: 2025-10-11 12:11:56
 
 Contents:
 // Utilities.swift (Updated with rounding in screenToModel)
@@ -741,6 +741,10 @@ public extension CGPoint {
             return len > 0 ? self / len : .zero
         }
     
+    func clamped(toModelBounds bounds: CGSize) -> CGPoint {
+            CGPoint(x: x.clamped(to: 0...bounds.width), y: y.clamped(to: 0...bounds.height))
+        }
+    
     static func + (lhs: CGPoint, rhs: CGPoint) -> CGPoint {
         CGPoint(x: lhs.x + rhs.x, y: lhs.y + rhs.y)
     }
diff --git a/swift_ui_context_parts/part-4.txt b/swift_ui_context_parts/part-4.txt
index a5da358..06a748f 100644
--- a/swift_ui_context_parts/part-4.txt
+++ b/swift_ui_context_parts/part-4.txt
@@ -1,16 +1,17 @@
 ## Focused Project Concatenation
 This file includes only UI, interactivity, model, and core logic files.
 Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
-Current date: 2025-10-10 13:25:46
+Current date: 2025-10-12 10:03:04
 Table of Contents:
 1. GraphEditorWatch/ViewModels/GraphViewModel.swift
 2. GraphEditorWatch/Views/AddSection.swift
 3. GraphEditorWatch/Views/ContentView.swift
 4. GraphEditorWatch/Views/EditContentSheet.swift
-5. GraphEditorWatch/Views/EditSection.swift--------------------------------------------------
+5. GraphEditorWatch/Views/EditSection.swift
+6. GraphEditorWatch/Views/GestureUtils.swift--------------------------------------------------
 File: GraphViewModel.swift
 Path: GraphEditorWatch/ViewModels/GraphViewModel.swift
-Last modified: 2025-10-10 13:16:11
+Last modified: 2025-10-11 16:07:42
 
 Contents:
 //
@@ -23,8 +24,11 @@ Contents:
 import Combine
 import GraphEditorShared
 import WatchKit  // For WKApplication
+import os  // Added for logging
 
 @MainActor public class GraphViewModel: ObservableObject {
+    private let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "viewmodel")  // Added for consistent logging
+    
     @Published public var model: GraphModel
     @Published public var selectedEdgeID: UUID?
     @Published public var pendingEdgeType: EdgeType = .association
@@ -110,7 +114,11 @@ import WatchKit  // For WKApplication
         let calculatedMin = min(fitWidth, fitHeight)
         let minZoom = max(calculatedMin, 0.5)
         let maxZoom = minZoom * Constants.App.maxZoom  // Now higher (e.g., *5)
-        print("Calculated zoom ranges: min=\(minZoom), max=\(maxZoom), based on bounds \(graphBounds)")  // Enhanced log
+        
+        #if DEBUG
+        logger.debug("Calculated zoom ranges: min=\(minZoom), max=\(maxZoom), based on bounds x=\(graphBounds.origin.x), y=\(graphBounds.origin.y), width=\(graphBounds.width), height=\(graphBounds.height)")
+        #endif
+        
         return (minZoom, maxZoom)
     }
     
@@ -164,31 +172,16 @@ import WatchKit  // For WKApplication
     public func deleteNode(withID id: NodeID) async {
         await model.deleteNode(withID: id)
         if selectedNodeID == id { selectedNodeID = nil }
-        // Deleting a node may also invalidate an edge selection
-        selectedEdgeID = nil
-        await saveAfterDelay()
-    }
-    
-    public func clearGraph() async {
-        await model.clearGraph()
         await saveAfterDelay()
     }
     
-    public func pauseSimulation() async {
-        await model.pauseSimulation()
-    }
-    
-    public func resumeSimulation() async {
-        await model.resumeSimulation()
-    }
-    
     public func resumeSimulationAfterDelay() async {
         resumeTimer?.invalidate()
         resumeTimer = Timer.scheduledTimer(withTimeInterval: 0.3, repeats: false) { [weak self] _ in
-            Task { @MainActor in  // Hop to main for safe access
-                guard let self = self else { return }
+            Task { @MainActor in
+                guard let self else { return }
                 if WKApplication.shared().applicationState == .active {
-                    await self.model.resumeSimulation()  // Consistent async call
+                    await self.model.resumeSimulation()
                 }
             }
         }
@@ -198,28 +191,42 @@ import WatchKit  // For WKApplication
     public func handleTap(at modelPos: CGPoint) async {
         await model.pauseSimulation()
         
-        print("Handling tap at model pos: \(modelPos)")  // For testing
+        #if DEBUG
+        self.logger.debug("Handling tap at model pos: x=\(modelPos.x), y=\(modelPos.y)")
+        #endif
         
         // Efficient hit test with queryNearby
         let hitRadius: CGFloat = 25.0 / max(1.0, zoomScale)  // Dynamic: Smaller radius at higher zoom for precision; test and adjust
         let nearbyNodes = model.physicsEngine.queryNearby(position: modelPos, radius: hitRadius, nodes: model.visibleNodes())
-        print("Nearby nodes found: \(nearbyNodes.count)")  // For testing
+        
+        #if DEBUG
+        self.logger.debug("Nearby nodes found: \(nearbyNodes.count)")
+        #endif
         
         // Sort by distance to get closest (if multiple)
-        let sortedNearby = nearbyNodes.sorted {
-            hypot($0.position.x - modelPos.x, $0.position.y - modelPos.y) < hypot($1.position.x - modelPos.x, $1.position.y - modelPos.y)
+        let distances = nearbyNodes.map { node in
+            hypot(node.position.x - modelPos.x, node.position.y - modelPos.y)
         }
+        let sortedIndices = distances.indices.sorted { distances[$0] < distances[$1] }
+        let sortedNearby = sortedIndices.map { nearbyNodes[$0] }
         
         if let tappedNode = sortedNearby.first {
             selectedNodeID = (tappedNode.id == selectedNodeID) ? nil : tappedNode.id
             selectedEdgeID = nil
-            print("Selected node \(tappedNode.label) (type: \(type(of: tappedNode)))")
+            
+            #if DEBUG
+            self.logger.debug("Selected node \(tappedNode.label) (type: \(type(of: tappedNode)))")
+            #endif
+            
             model.objectWillChange.send()  // Trigger UI refresh
         } else {
             // Miss: Clear selections
             selectedNodeID = nil
             selectedEdgeID = nil
-            print("Tap missed; cleared selections")
+            
+            #if DEBUG
+            self.logger.debug("Tap missed; cleared selections")
+            #endif
         }
         
         focusState = selectedNodeID.map { .node($0) } ?? .graph
@@ -247,6 +254,41 @@ import WatchKit  // For WKApplication
         offset = .zero
         objectWillChange.send()
     }
+    
+    public func moveDraggedNode(dragOffset: CGPoint, draggedID: NodeID) async {
+        guard let index = model.nodes.firstIndex(where: { $0.id == draggedID }) else { return }
+        let oldNode = model.nodes[index]
+        let unwrapped = oldNode.unwrapped
+        // FIXED: Clamp new position to simulation bounds for consistent offsets
+        let unclampedPos = unwrapped.position + dragOffset
+        let bounds = model.physicsEngine.simulationBounds
+        let newPos = CGPoint(
+            x: unclampedPos.x.clamped(to: 0...bounds.width),
+            y: unclampedPos.y.clamped(to: 0...bounds.height)
+        )
+        let updatedNode: AnyNode
+        if let concrete = unwrapped as? Node {
+            updatedNode = AnyNode(concrete.with(position: newPos, velocity: .zero))
+        } else if let concrete = unwrapped as? ToggleNode {
+            updatedNode = AnyNode(concrete.with(position: newPos, velocity: .zero))
+        } else {
+            logger.error("Unsupported node type for move: \(type(of: unwrapped))")
+            return
+        }
+        model.nodes[index] = updatedNode
+        
+        #if DEBUG
+        logger.debug("Clamped new position to x=\(newPos.x), y=\(newPos.y) within bounds \(bounds.width)x\(bounds.height)")
+        logger.debug("Moved node \(unwrapped.label) to new position x=\(newPos.x), y=\(newPos.y)")
+        #endif
+        
+        await model.startSimulation()
+    }
+    
+    public func clearGraph() async {
+        await model.clearGraph()
+        await saveAfterDelay()
+    }
 }
 
 extension GraphViewModel {
@@ -316,7 +358,10 @@ extension GraphViewModel {
     public func saveViewState() throws {
         let viewState = ViewState(offset: offset, zoomScale: zoomScale, selectedNodeID: selectedNodeID, selectedEdgeID: selectedEdgeID)
         try model.storage.saveViewState(viewState, for: currentGraphName)
-        print("Saved view state for '\(currentGraphName)'")
+        
+        #if DEBUG
+        logger.debug("Saved view state for '\(self.currentGraphName)'")
+        #endif
     }
 }
 
@@ -331,11 +376,17 @@ extension GraphViewModel {
                     try await self?.model.saveGraph()
                     try self?.saveViewState()
                 } catch {
-                    print("Save failed: \(error)")
+                    #if DEBUG
+                    self?.logger.error("Save failed: \(error.localizedDescription)")
+                    #endif
                 }
             }
         }
     }
+    
+    public func resumeSimulation() async {
+        await model.resumeSimulation()
+    }
 }
 ----------------------------------------------------------------------------------------------------
 File: AddSection.swift
@@ -408,18 +459,19 @@ struct AddSection: View {
 ----------------------------------------------------------------------------------------------------
 File: ContentView.swift
 Path: GraphEditorWatch/Views/ContentView.swift
-Last modified: 2025-10-08 16:14:01
+Last modified: 2025-10-11 16:37:25
 
 Contents:
-// ContentView.swift (Reduced version: Extracted utilities, InnerView, and EditContentSheet)
-
 import SwiftUI
 import WatchKit
 import GraphEditorShared
 import Foundation
 import CoreGraphics
+import os  // Added for logging
 
 struct ContentView: View {
+    private let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "contentview")  // Added for consistent logging
+    
     @ObservedObject var viewModel: GraphViewModel
     @State private var zoomScale: CGFloat = 1.0
     @State private var offset: CGSize = .zero
@@ -440,6 +492,7 @@ struct ContentView: View {
     @State private var isAddingEdge: Bool = false
     @State private var viewSize: CGSize = .zero
     @State private var isSimulating: Bool = false
+    @State private var isDragging: Bool = false  // Add this for drag state
     
     // NEW: Custom Bindings to sync @State with ViewModel (two-way)
     private var selectedNodeIDBinding: Binding<NodeID?> {
@@ -469,14 +522,19 @@ struct ContentView: View {
                     Task { await viewModel.resumeSimulation() }
                     updateZoomRanges(for: geo.size)
                     wristSide = WKInterfaceDevice.current().wristLocation
-                    print(geo.size)
+                    
+                    #if DEBUG
+                    logger.debug("Geometry size: width=\(geo.size.width), height=\(geo.size.height)")
+                    #endif
+                    
                     canvasFocus = true
                     
                     let initialNormalized = crownPosition / Double(AppConstants.crownZoomSteps)
                     zoomScale = minZoom + (maxZoom - minZoom) * CGFloat(initialNormalized)
-#if DEBUG
-                    print("Initial sync: crownPosition \(crownPosition) -> zoomScale \(zoomScale)")
-#endif
+                    
+                    #if DEBUG
+                    logger.debug("Initial sync: crownPosition \(self.crownPosition) -> zoomScale \(self.zoomScale)")
+                    #endif
                     
                     viewSize = geo.size  // New: Set viewSize here
                 }
@@ -487,11 +545,17 @@ struct ContentView: View {
                     updateZoomRanges(for: viewSize)  // New: Use viewSize
                 }
                 .onChange(of: crownPosition) { oldValue, newValue in
-                    print("Crown position changed in ContentView: from \(oldValue) to \(newValue)")
+                    #if DEBUG
+                    logger.debug("Crown position changed in ContentView: from \(oldValue) to \(newValue)")
+                    #endif
+                    
                     handleCrownRotation(newValue: newValue)
                 }
                 .onChange(of: canvasFocus) { oldValue, newValue in
-                    print("ContentView canvas focus changed: from \(oldValue) to \(newValue)")
+                    #if DEBUG
+                    logger.debug("ContentView canvas focus changed: from \(oldValue) to \(newValue)")
+                    #endif
+                    
                     if !newValue { canvasFocus = true }
                 }
             
@@ -501,37 +565,42 @@ struct ContentView: View {
                     let targetCrown = Double(AppConstants.crownZoomSteps) * Double(normalized).clamped(to: 0...1)
                     if abs(targetCrown - crownPosition) > 0.01 {
                         crownPosition = targetCrown
-#if DEBUG
-                        print("Zoom sync: zoomScale from \(oldValue) to \(newValue) -> crownPosition \(crownPosition)")
-#endif
+                        
+                        #if DEBUG
+                        logger.debug("Zoom sync: zoomScale from \(oldValue) to \(newValue) -> crownPosition \(self.crownPosition)")
+                        #endif
                     }
                 }
                 .onChange(of: viewModel.selectedNodeID) { oldValue, newValue in
-                    print("ContentView: ViewModel selectedNodeID changed from \(oldValue?.uuidString.prefix(8) ?? "nil") to \(newValue?.uuidString.prefix(8) ?? "nil")")
+                    #if DEBUG
+                    logger.debug("ContentView: ViewModel selectedNodeID changed from \(oldValue?.uuidString.prefix(8) ?? "nil") to \(newValue?.uuidString.prefix(8) ?? "nil")")
+                    #endif
+                    
                     selectedNodeID = newValue  // Sync to local @State
                     viewModel.objectWillChange.send()  // Force re-render if needed
                 }
                 .onChange(of: viewModel.selectedEdgeID) { oldValue, newValue in
-                    print("ContentView: ViewModel selectedEdgeID changed from \(oldValue?.uuidString.prefix(8) ?? "nil") to \(newValue?.uuidString.prefix(8) ?? "nil")")
+                    #if DEBUG
+                    logger.debug("ContentView: ViewModel selectedEdgeID changed from \(oldValue?.uuidString.prefix(8) ?? "nil") to \(newValue?.uuidString.prefix(8) ?? "nil")")
+                    #endif
+                    
                     selectedEdgeID = newValue
                     viewModel.objectWillChange.send()
                 }
                 .onReceive(viewModel.model.$isStable) { isStable in
                     if isStable {
-                        print("Simulation stable: Centering nodes")
+                        #if DEBUG
+                        logger.debug("Simulation stable: Centering nodes")
+                        #endif
+                        
                         centerGraph()
                     }
                 }
                 .onReceive(viewModel.model.$simulationError) { error in
                     if let error = error {
-                        print("Simulation error: \(error.localizedDescription)")
-                    }
-                }
-                .sheet(isPresented: $showEditSheet) {
-                    if let selectedID = selectedNodeID {
-                        EditContentSheet(selectedID: selectedID, viewModel: viewModel, onSave: { newContent in
-                            Task { await viewModel.model.updateNodeContent(withID: selectedID, newContent: newContent) }
-                        })
+                        #if DEBUG
+                        logger.error("Simulation error: \(error.localizedDescription)")
+                        #endif
                     }
                 }
             
@@ -573,7 +642,8 @@ struct ContentView: View {
                 canvasFocus: _canvasFocus,
                 onCenterGraph: centerGraph,
                 isAddingEdge: $isAddingEdge,
-                isSimulatingBinding: $isSimulating  // FIXED: Pass actual binding instance from @State
+                isSimulatingBinding: $isSimulating,  // FIXED: Pass actual binding instance from @State
+                isDragging: $isDragging  // Add this new binding
             ))
         }
         .overlay(alignment: .bottom) {
@@ -594,9 +664,11 @@ struct ContentView: View {
     }
     
     private func handleCrownRotation(newValue: Double) {
-#if DEBUG
-        print("handleCrownRotation triggered with newValue: \(newValue)")
-#endif
+        if isDragging { return }  // Ignore crown during drag to prevent zoom interference
+        #if DEBUG
+        logger.debug("handleCrownRotation triggered with newValue: \(newValue)")
+        #endif
+        
         let normalized = newValue.clamped(to: 0...Double(AppConstants.crownZoomSteps)) / Double(AppConstants.crownZoomSteps)
         let targetZoom = minZoom + (maxZoom - minZoom) * CGFloat(normalized)
         
@@ -605,9 +677,10 @@ struct ContentView: View {
             zoomScale = targetZoom
         }
         viewModel.centerGraph()  // Direct call
-#if DEBUG
-        print("Updated zoomScale to: \(zoomScale)")
-#endif
+        
+        #if DEBUG
+        logger.debug("Updated zoomScale to: \(self.zoomScale)")
+        #endif
     }
     
     private func updateZoomRanges(for viewSize: CGSize) {
@@ -630,14 +703,21 @@ struct ContentView: View {
             offset.width += centroidShift.width
             offset.height += centroidShift.height
         }
-        print("Centering graph: Old centroid \(oldCentroid), Shift \(centroidShift), New target \(newCentroid)")
+        
+        #if DEBUG
+        logger.debug("Centering graph: Old centroid x=\(oldCentroid.x), y=\(oldCentroid.y), Shift width=\(centroidShift.width), height=\(centroidShift.height), New target x=\(newCentroid.x), y=\(newCentroid.y)")
+        #endif
     }
     
     // Existing add node button (unchanged, but renamed for clarity)
     private func addNodeButton(in geo: GeometryProxy) -> some View {
         Button(action: {
             WKInterfaceDevice.current().play(.click)  // Haptic feedback
-            print("Add Node button tapped!")  // Console log (check in Xcode)
+            
+            #if DEBUG
+            logger.debug("Add Node button tapped!")
+            #endif
+            
             let randomPos = CGPoint(x: CGFloat.random(in: -100...100), y: CGFloat.random(in: -100...100))
             Task { await viewModel.addNode(at: randomPos) }
         }, label: {
@@ -655,7 +735,11 @@ struct ContentView: View {
     private func menuButton(in geo: GeometryProxy) -> some View {
         Button(action: {
             WKInterfaceDevice.current().play(.click)  // Haptic feedback
-            print("Menu button tapped!")  // Console log
+            
+            #if DEBUG
+            logger.debug("Menu button tapped!")
+            #endif
+            
             showMenu.toggle()
         }, label: {
             Image(systemName: showMenu ? "point.3.filled.connected.trianglepath.dotted" : "line.3.horizontal")
@@ -876,4 +960,112 @@ struct EditSection: View {
         .foregroundColor(isProcessing ? .gray : .primary)  // NEW: Visual feedback for processing
     }
 }
+----------------------------------------------------------------------------------------------------
+File: GestureUtils.swift
+Path: GraphEditorWatch/Views/GestureUtils.swift
+Last modified: 2025-10-11 19:40:27
+
+Contents:
+// GestureUtils.swift
+// Extracted utilities for hit testing and distance calculations
+
+import SwiftUI
+import GraphEditorShared
+
+struct GestureUtils {
+    static func closestNode(at screenPos: CGPoint, visibleNodes: [any NodeProtocol], context: GraphEditorShared.HitTestContext) -> (any NodeProtocol)? {
+        var closest: (any NodeProtocol)?
+        var minDist: CGFloat = .infinity
+        let adjustedRadius = AppConstants.hitScreenRadius / max(1.0, context.zoomScale) * 2.0  // Double boost at zoom >1; tune to 3.0 if needed
+        #if os(watchOS)
+        let boostedRadius = adjustedRadius * 2.0  // Extra for watch touch (fingers obscure)
+        #endif
+        for node in visibleNodes {
+            let nodeScreen = CoordinateTransformer.modelToScreen(
+                node.position,
+                effectiveCentroid: context.effectiveCentroid,
+                zoomScale: context.zoomScale,
+                offset: context.offset,
+                viewSize: context.viewSize
+            )
+            let dist = hypot(screenPos.x - nodeScreen.x, screenPos.y - nodeScreen.y)
+            if dist < boostedRadius && dist < minDist {
+                minDist = dist
+                closest = node
+            }
+        }
+        return closest
+    }
+    
+    static func closestEdge(at screenPos: CGPoint, visibleEdges: [GraphEdge], visibleNodes: [any NodeProtocol], context: HitTestContext) -> GraphEdge? {
+        var closestEdge: GraphEdge?
+        var minDist: CGFloat = .infinity
+        for edge in visibleEdges {
+            guard let fromNode = visibleNodes.first(where: { $0.id == edge.from }),
+                  let targetNode = visibleNodes.first(where: { $0.id == edge.target }) else { continue }
+            
+            let fromScreen = CoordinateTransformer.modelToScreen(
+                fromNode.position,
+                effectiveCentroid: context.effectiveCentroid,
+                zoomScale: context.zoomScale,
+                offset: context.offset,
+                viewSize: context.viewSize
+            )
+            let toScreen = CoordinateTransformer.modelToScreen(
+                targetNode.position,
+                effectiveCentroid: context.effectiveCentroid,
+                zoomScale: context.zoomScale,
+                offset: context.offset,
+                viewSize: context.viewSize
+            )
+            
+            let dist = pointToLineDistance(point: screenPos, from: fromScreen, to: toScreen)
+            let hitThreshold: CGFloat = 20.0
+            if dist < hitThreshold && dist < minDist {
+                minDist = dist
+                closestEdge = edge
+            }
+        }
+        return closestEdge
+    }
+    
+    static func pointToLineDistance(point: CGPoint, from startPoint: CGPoint, to endPoint: CGPoint) -> CGFloat {
+        let pointX = Double(point.x), pointY = Double(point.y)
+        let startX = Double(startPoint.x), startY = Double(startPoint.y)
+        let endX = Double(endPoint.x), endY = Double(endPoint.y)
+        
+        let lineVecX = endX - startX
+        let lineVecY = endY - startY
+        let lineLen = hypot(lineVecX, lineVecY)
+        
+        if lineLen == 0 {
+            return hypot(point.x - startPoint.x, point.y - startPoint.y)
+        }
+        
+        let pointVecX = pointX - startX
+        let pointVecY = pointY - startY
+        let dot = pointVecX * lineVecX + pointVecY * lineVecY
+        let denom = lineLen * lineLen
+        let projectionParam = dot / denom
+        let clampedParam = max(0.0, min(1.0, projectionParam))
+        
+        let projX = startX + lineVecX * clampedParam
+        let projY = startY + lineVecY * clampedParam
+        
+        let proj = CGPoint(x: CGFloat(projX), y: CGFloat(projY))
+        return hypot(point.x - proj.x, point.y - proj.y)
+    }
+    
+    static func modelToScreen(_ modelPos: CGPoint, context: HitTestContext) -> CGPoint {
+        return CoordinateTransformer.modelToScreen(
+            modelPos,
+            effectiveCentroid: context.effectiveCentroid,
+            zoomScale: context.zoomScale,
+            offset: context.offset,
+            viewSize: context.viewSize
+        )
+    }
+    
+    // Add any other utility functions extracted from the original file here
+}
 --------------------------------------------------
diff --git a/swift_ui_context_parts/part-5.txt b/swift_ui_context_parts/part-5.txt
index 696bc72..779851c 100644
--- a/swift_ui_context_parts/part-5.txt
+++ b/swift_ui_context_parts/part-5.txt
@@ -1,49 +1,32 @@
 ## Focused Project Concatenation
 This file includes only UI, interactivity, model, and core logic files.
 Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
-Current date: 2025-10-10 13:25:46
+Current date: 2025-10-12 10:03:05
 Table of Contents:
 1. GraphEditorWatch/Views/GraphCanvasView.swift
 2. GraphEditorWatch/Views/GraphGesturesModifier.swift
-3. GraphEditorWatch/Views/GraphSection.swift--------------------------------------------------
+3. GraphEditorWatch/Views/GraphSection.swift
+4. GraphEditorWatch/Views/GraphUtilities.swift
+5. GraphEditorWatch/Views/InnerView.swift
+6. GraphEditorWatch/Views/MenuView.swift
+7. GraphEditorWatch/Views/NodeView.swift
+8. GraphEditorWatch/Views/ViewSection.swift--------------------------------------------------
 File: GraphCanvasView.swift
 Path: GraphEditorWatch/Views/GraphCanvasView.swift
-Last modified: 2025-10-03 15:51:25
+Last modified: 2025-10-11 18:36:40
 
 Contents:
+// GraphCanvasView.swift
 import SwiftUI
 import WatchKit
 import GraphEditorShared
+import os  // Added for logging
 
-// Reverted: Custom wrapper for reliable crown focus (without crown—handled in ContentView now)
-struct FocusableView<Content: View>: View {
-    let content: Content
-    @FocusState private var isFocused: Bool
-    
-    init(@ViewBuilder content: () -> Content) {
-        self.content = content()
+struct GraphCanvasView: View {
+    private static var logger: Logger {
+        Logger(subsystem: "io.handcart.GraphEditor", category: "graphcanvasview")  // Changed to computed static for consistency
     }
     
-    var body: some View {
-        content
-            .id("CrownFocusableCanvas")
-            .focused($isFocused)
-            .onAppear {
-                isFocused = true
-                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
-                    isFocused = true  // Double-focus for WatchOS reliability
-                }
-            }
-            .onChange(of: isFocused) { oldValue, newValue in
-                print("Canvas focus changed: from \(oldValue) to \(newValue)")
-                if !newValue {
-                    isFocused = true  // Auto-recover focus loss
-                }
-            }
-    }
-}
-
-struct GraphCanvasView: View {
     let viewModel: GraphViewModel
     @Binding var zoomScale: CGFloat
     @Binding var offset: CGSize
@@ -62,6 +45,7 @@ struct GraphCanvasView: View {
     @Binding var selectedEdgeID: UUID?
     @Binding var showOverlays: Bool
     @Binding var isAddingEdge: Bool
+    @Binding var isDragging: Bool
     
     init(
         viewModel: GraphViewModel,
@@ -79,7 +63,8 @@ struct GraphCanvasView: View {
         onUpdateZoomRanges: @escaping () -> Void,
         selectedEdgeID: Binding<UUID?>,
         showOverlays: Binding<Bool>,
-        isAddingEdge: Binding<Bool>
+        isAddingEdge: Binding<Bool>,
+        isDragging: Binding<Bool>  // Add this new parameter
     ) {
         self.viewModel = viewModel
         self._zoomScale = zoomScale
@@ -97,6 +82,7 @@ struct GraphCanvasView: View {
         self._selectedEdgeID = selectedEdgeID
         self._showOverlays = showOverlays
         self._isAddingEdge = isAddingEdge
+        self._isDragging = isDragging  // Add this
     }
     
     private var boundingBoxOverlay: some View {
@@ -123,129 +109,7 @@ struct GraphCanvasView: View {
             .opacity(0.5)
     }
     
-    private var accessibleCanvas: some View {
-        ZStack {
-            Canvas { context, size in
-                // Define visibleNodes and visibleEdges
-                let visibleNodes = viewModel.model.visibleNodes()
-                let visibleEdges = viewModel.model.visibleEdges()  // Fix: Use visibleEdges() instead of all edges
-                let hiddenIDs = viewModel.model.hiddenNodeIDs.map { $0.uuidString.prefix(8) }
-                print("Visible: \(visibleNodes.count), Hidden IDs: \(hiddenIDs)")
-                
-                if visibleNodes.isEmpty {
-                    print("Warning: No visible nodes")  // Transient; remove if desired
-                    return
-                }
-                
-                // Compute effectiveCentroid: True model center (fixes panning/offset)
-                let effectiveCentroid = centroid(of: visibleNodes)  // Non-optional CGPoint
-                
-                print("Drawing: \(visibleNodes.count) nodes, \(visibleEdges.count) edges | Centroid: \(effectiveCentroid) | Zoom: \(zoomScale) | Offset: \(offset)")  // Debug
-                
-                // Draw elements using helpers
-                drawNodes(in: context, size: size, visibleNodes: visibleNodes, effectiveCentroid: effectiveCentroid)
-                drawEdgeLines(in: context, size: size, visibleEdges: visibleEdges, visibleNodes: visibleNodes, effectiveCentroid: effectiveCentroid)
-                drawEdgeArrows(in: context, size: size, visibleEdges: visibleEdges, visibleNodes: visibleNodes, effectiveCentroid: effectiveCentroid)
-                drawDraggedNodeAndPotentialEdge(in: context, size: size, effectiveCentroid: effectiveCentroid)
-            }
-            .frame(width: viewSize.width, height: viewSize.height)
-            .accessibilityLabel(viewModel.model.graphDescription(selectedID: selectedNodeID, selectedEdgeID: selectedEdgeID))
-            .accessibilityIdentifier("GraphCanvas")  // Add this line
-            .accessibilityHint("Tap menu button on bottom edge.")
-            
-            if showOverlays {
-                boundingBoxOverlay
-            }
-            
-            if let selectedID = selectedNodeID {
-                Text("Selected: \(selectedID.uuidString.prefix(8))")  // Debug label
-                    .position(x: 20, y: 10)
-                    .foregroundColor(.yellow)
-            }
-        }
-    }
-    
-    private func centroid(of nodes: [any NodeProtocol]) -> CGPoint {
-        guard !nodes.isEmpty else { return .zero }  // Safe default (no optional)
-        let sumX = nodes.reduce(0.0) { $0 + $1.position.x }
-        let sumY = nodes.reduce(0.0) { $0 + $1.position.y }
-        return CGPoint(x: sumX / CGFloat(nodes.count), y: sumY / CGFloat(nodes.count))
-    }
-    
-    var body: some View {
-        Group {
-            FocusableView {  // Reverted: No crown params
-                accessibleCanvas
-            }
-            .modifier(GraphGesturesModifier(
-                viewModel: viewModel,
-                zoomScale: $zoomScale,
-                offset: $offset,
-                draggedNode: $draggedNode,
-                dragOffset: $dragOffset,
-                potentialEdgeTarget: $potentialEdgeTarget,
-                selectedNodeID: $selectedNodeID,
-                selectedEdgeID: $selectedEdgeID,
-                viewSize: viewSize,
-                panStartOffset: $panStartOffset,
-                showMenu: $showMenu,
-                maxZoom: maxZoom,
-                crownPosition: $crownPosition,
-                onUpdateZoomRanges: onUpdateZoomRanges,
-                isAddingEdge: $isAddingEdge  // Pass to modifier
-            ))
-        }
-        .onChange(of: selectedNodeID) {
-            do {
-                try viewModel.saveViewState()  // Existing: Triggers view state save on selection change
-            } catch {
-                print("Failed to save view state on selectedNodeID change: \(error)")
-            }
-        }
-        .onChange(of: selectedEdgeID) {
-            do {
-                try viewModel.saveViewState()  // Existing
-            } catch {
-                print("Failed to save view state on selectedEdgeID change: \(error)")
-            }
-        }
-        .onChange(of: offset) {  // NEW: Save on offset/zoom changes for full view persistence
-            do {
-                try viewModel.saveViewState()
-            } catch {
-                print("Failed to save view state on offset change: \(error)")
-            }
-        }
-        .onChange(of: zoomScale) {
-            do {
-                try viewModel.saveViewState()
-            } catch {
-                print("Failed to save view state on zoomScale change: \(error)")
-            }
-        }
-        .ignoresSafeArea()
-    }
-}
-
-extension GraphCanvasView {
-    func drawNodes(in context: GraphicsContext, size: CGSize, visibleNodes: [any NodeProtocol], effectiveCentroid: CGPoint) {
-        // Pass 0: Draw nodes FIRST (under edges/arrows)
-        for node in visibleNodes {
-            let screenPos = CoordinateTransformer.modelToScreen(
-                node.position,
-                effectiveCentroid: effectiveCentroid,
-                zoomScale: zoomScale,
-                offset: offset,
-                viewSize: size
-            )
-            let isSelected = (node.id == selectedNodeID)
-            print("Drawing node \(node.label) at screen \(screenPos), selected: \(isSelected)")  // Debug
-            node.draw(in: context, at: screenPos, zoomScale: zoomScale, isSelected: isSelected)
-        }
-    }
-    
-    func drawEdgeLines(in context: GraphicsContext, size: CGSize, visibleEdges: [GraphEdge], visibleNodes: [any NodeProtocol], effectiveCentroid: CGPoint) {
-        // Pass 1: Draw edges (lines only)
+    private func drawEdges(in context: GraphicsContext, size: CGSize, visibleEdges: [GraphEdge], visibleNodes: [any NodeProtocol], effectiveCentroid: CGPoint) {
         for edge in visibleEdges {
             guard let fromNode = visibleNodes.first(where: { $0.id == edge.from }),
                   let toNode = visibleNodes.first(where: { $0.id == edge.target }) else { continue }
@@ -265,37 +129,17 @@ extension GraphCanvasView {
                 viewSize: size
             )
             
-            let direction = CGVector(dx: toScreen.x - fromScreen.x, dy: toScreen.y - fromScreen.y)
-            let length = hypot(direction.dx, direction.dy)
-            if length <= 0 { continue }
-            
-            let unitDx = direction.dx / length
-            let unitDy = direction.dy / length
-            let fromRadiusScreen = fromNode.radius * zoomScale
-            let toRadiusScreen = toNode.radius * zoomScale
-            let margin: CGFloat = 3.0
+            var path = Path()
+            path.move(to: fromScreen)
+            path.addLine(to: toScreen)
             
             let isSelected = edge.id == selectedEdgeID
-            let lineColor: Color = isSelected ? .red : .gray
-            let lineWidth: CGFloat = 3.0
-            
-            let startPoint = CGPoint(x: fromScreen.x + unitDx * (fromRadiusScreen + margin),
-                                     y: fromScreen.y + unitDy * (fromRadiusScreen + margin))
-            let endPoint = CGPoint(x: toScreen.x - unitDx * (toRadiusScreen + margin),
-                                   y: toScreen.y - unitDy * (toRadiusScreen + margin))
-            
-            let linePath = Path { path in
-                path.move(to: startPoint)
-                path.addLine(to: endPoint)
-            }
-            
-            context.stroke(linePath, with: .color(lineColor), lineWidth: lineWidth)
-            print("Drawing line for edge \(edge.id.uuidString.prefix(8)) from \(startPoint) to \(endPoint)")  // Debug
+            let edgeColor: Color = isSelected ? .red : .gray
+            context.stroke(path, with: .color(edgeColor), lineWidth: 2 * zoomScale)
         }
     }
     
-    func drawEdgeArrows(in context: GraphicsContext, size: CGSize, visibleEdges: [GraphEdge], visibleNodes: [any NodeProtocol], effectiveCentroid: CGPoint) {
-        // Pass 2: Draw arrows (over lines)
+    private func drawArrows(in context: GraphicsContext, size: CGSize, visibleEdges: [GraphEdge], visibleNodes: [any NodeProtocol], effectiveCentroid: CGPoint) {
         for edge in visibleEdges {
             guard let fromNode = visibleNodes.first(where: { $0.id == edge.from }),
                   let toNode = visibleNodes.first(where: { $0.id == edge.target }) else { continue }
@@ -315,55 +159,37 @@ extension GraphCanvasView {
                 viewSize: size
             )
             
-            let direction = CGVector(dx: toScreen.x - fromScreen.x, dy: toScreen.y - fromScreen.y)
-            let length = hypot(direction.dx, direction.dy)
-            if length <= 0 { continue }
-            
-            let unitDx = direction.dx / length
-            let unitDy = direction.dy / length
-            let toRadiusScreen = toNode.radius * zoomScale
-            let boundaryPoint = CGPoint(x: toScreen.x - unitDx * toRadiusScreen,
-                                        y: toScreen.y - unitDy * toRadiusScreen)
-            
-            let lineAngle = atan2(unitDy, unitDx)
-            let arrowLength: CGFloat = 10.0
-            let arrowAngle: CGFloat = .pi / 6
-            let arrowPoint1 = CGPoint(
-                x: boundaryPoint.x - arrowLength * cos(lineAngle - arrowAngle),
-                y: boundaryPoint.y - arrowLength * sin(lineAngle - arrowAngle)
-            )
-            let arrowPoint2 = CGPoint(
-                x: boundaryPoint.x - arrowLength * cos(lineAngle + arrowAngle),
-                y: boundaryPoint.y - arrowLength * sin(lineAngle + arrowAngle)
-            )
+            let arrowSize = 10 * zoomScale
+            let delta = toScreen - fromScreen
+            let length = hypot(delta.x, delta.y)
+            if length == 0 { continue }
+            let unitDelta = delta / length
+            let arrowPoint = toScreen - unitDelta * (toNode.radius * zoomScale)
             
+            let perpX = -unitDelta.y
+            let perpY = unitDelta.x
             let arrowPath = Path { path in
-                path.move(to: boundaryPoint)
-                path.addLine(to: arrowPoint1)
-                path.move(to: boundaryPoint)
-                path.addLine(to: arrowPoint2)
+                path.move(to: arrowPoint)
+                path.addLine(to: arrowPoint - unitDelta * arrowSize + CGPoint(x: perpX * arrowSize / 2, y: perpY * arrowSize / 2))
+                path.move(to: arrowPoint)
+                path.addLine(to: arrowPoint - unitDelta * arrowSize - CGPoint(x: perpX * arrowSize / 2, y: perpY * arrowSize / 2))
             }
-            
-            let isSelected = edge.id == selectedEdgeID
-            let arrowColor: Color = isSelected ? .red : .gray
-            let arrowLineWidth: CGFloat = 3.0
-            
-            context.stroke(arrowPath, with: .color(arrowColor), lineWidth: arrowLineWidth)
-            print("Drawing arrow for edge \(edge.id.uuidString.prefix(8)) to boundary \(boundaryPoint)")  // Debug
+            context.stroke(arrowPath, with: .color(.gray), lineWidth: 1 * zoomScale)
         }
     }
     
-    func drawDraggedNodeAndPotentialEdge(in context: GraphicsContext, size: CGSize, effectiveCentroid: CGPoint) {
-        // Draw dragged node and potential edge
+    private func drawDraggedNodeAndPotentialEdge(in context: GraphicsContext, size: CGSize, effectiveCentroid: CGPoint) {
         if let dragged = draggedNode {
             let draggedScreen = CoordinateTransformer.modelToScreen(
-                dragged.position + dragOffset,
-                effectiveCentroid: effectiveCentroid,
+                draggedNode?.position ?? .zero + dragOffset,  // Virtual position
+                effectiveCentroid: effectiveCentroid,  // Use virtual
                 zoomScale: zoomScale,
                 offset: offset,
                 viewSize: size
             )
-            context.fill(Circle().path(in: CGRect(center: draggedScreen, size: CGSize(width: Constants.App.nodeModelRadius * 2 * zoomScale, height: Constants.App.nodeModelRadius * 2 * zoomScale))), with: .color(.green))
+            let draggedRadius = Constants.App.nodeModelRadius * zoomScale
+            let draggedPath = Circle().path(in: CGRect(center: draggedScreen, size: CGSize(width: draggedRadius * 2, height: draggedRadius * 2)))
+            context.fill(draggedPath, with: .color(.green.opacity(0.5)))
             
             if let target = potentialEdgeTarget {
                 let targetScreen = CoordinateTransformer.modelToScreen(
@@ -373,33 +199,99 @@ extension GraphCanvasView {
                     offset: offset,
                     viewSize: size
                 )
-                let tempLinePath = Path { path in
-                    path.move(to: draggedScreen)
-                    path.addLine(to: targetScreen)
-                }
-                context.stroke(tempLinePath, with: .color(.green), lineWidth: 2.0)
+                var potentialPath = Path()
+                potentialPath.move(to: draggedScreen)
+                potentialPath.addLine(to: targetScreen)
+                context.stroke(potentialPath, with: .color(.green), style: StrokeStyle(lineWidth: 2 * zoomScale, dash: [5 * zoomScale]))
             }
         }
     }
-}
-
-struct Line: Shape, Animatable {
-    var from: CGPoint
-    var end: CGPoint
     
-    var animatableData: AnimatablePair<CGPoint.AnimatableData, CGPoint.AnimatableData> {
-        get { AnimatablePair(from.animatableData, end.animatableData) }
-        set {
-            from.animatableData = newValue.first
-            end.animatableData = newValue.second
+    private func drawNodes(in context: GraphicsContext, size: CGSize, visibleNodes: [any NodeProtocol], effectiveCentroid: CGPoint) {
+        for node in visibleNodes {
+            let nodeScreen = CoordinateTransformer.modelToScreen(
+                node.position,
+                effectiveCentroid: effectiveCentroid,
+                zoomScale: zoomScale,
+                offset: offset,
+                viewSize: size
+            )
+            let nodeRadius = Constants.App.nodeModelRadius * zoomScale
+            
+            let isSelected = node.id == selectedNodeID
+            let nodeColor: Color = isSelected ? .red : .blue
+            let nodePath = Circle().path(in: CGRect(center: nodeScreen, size: CGSize(width: nodeRadius * 2, height: nodeRadius * 2)))
+            context.fill(nodePath, with: .color(nodeColor))
+            
+            // Draw label
+            let labelText = Text("\(node.label)").font(.system(size: 12 * zoomScale))
+            context.draw(labelText, at: nodeScreen, anchor: .center)
         }
     }
     
-    func path(in rect: CGRect) -> Path {
-        var path = Path()
-        path.move(to: from)
-        path.addLine(to: end)
-        return path
+    private var accessibleCanvas: some View {
+        ZStack {
+            Canvas { context, size in
+                // Define visibleNodes and visibleEdges
+                let visibleNodes = viewModel.model.visibleNodes()
+                let visibleEdges = viewModel.model.visibleEdges()  // Fix: Use visibleEdges() instead of all edges
+                
+#if DEBUG
+                Self.logger.debug("Visible: \(visibleNodes.count)")
+#endif
+                
+                let effectiveCentroid = viewModel.effectiveCentroid
+                
+                // Draw edges (Pass 1: Lines only)
+                drawEdges(in: context, size: size, visibleEdges: visibleEdges, visibleNodes: visibleNodes, effectiveCentroid: effectiveCentroid)
+                
+                // Draw nodes
+                drawNodes(in: context, size: size, visibleNodes: visibleNodes, effectiveCentroid: effectiveCentroid)
+                
+                // Draw arrows (Pass 2: Over lines)
+                drawArrows(in: context, size: size, visibleEdges: visibleEdges, visibleNodes: visibleNodes, effectiveCentroid: effectiveCentroid)
+                
+                // Draw dragged node and potential edge
+                drawDraggedNodeAndPotentialEdge(in: context, size: size, effectiveCentroid: effectiveCentroid)
+            }
+            .frame(width: viewSize.width, height: viewSize.height)
+            .accessibilityLabel(accessibilityLabel())
+            .accessibilityIdentifier("GraphCanvas")
+            
+            if showOverlays {
+                boundingBoxOverlay
+            }
+        }
+    }
+    
+    var body: some View {
+        accessibleCanvas
+            .modifier(GraphGesturesModifier(
+                viewModel: viewModel,
+                zoomScale: $zoomScale,
+                offset: $offset,
+                draggedNode: $draggedNode,
+                dragOffset: $dragOffset,
+                potentialEdgeTarget: $potentialEdgeTarget,
+                selectedNodeID: $selectedNodeID,
+                selectedEdgeID: $selectedEdgeID,
+                viewSize: viewSize,
+                panStartOffset: $panStartOffset,
+                showMenu: $showMenu,
+                maxZoom: maxZoom,
+                crownPosition: $crownPosition,
+                onUpdateZoomRanges: onUpdateZoomRanges,
+                isAddingEdge: $isAddingEdge,
+                isDragging: $isDragging  // Add this to pass down the binding
+            ))
+    }
+    
+    private func accessibilityLabel() -> String {
+        let nodeCount = viewModel.model.visibleNodes().count
+        let edgeCount = viewModel.model.visibleEdges().count
+        let selectedNodeLabel = selectedNodeID.flatMap { id in viewModel.model.nodes.first(where: { $0.id == id })?.label }?.description ?? "none"
+        let selectedEdgeLabel = selectedEdgeID.flatMap { id in viewModel.model.edges.first(where: { $0.id == id }).map { "\($0.from) to \($0.target)" } } ?? "none"
+        return "Graph with \(nodeCount) nodes and \(edgeCount) edges. Selected node: \(selectedNodeLabel), selected edge: \(selectedEdgeLabel)."
     }
 }
 
@@ -408,27 +300,62 @@ extension CGRect {
         self.init(x: center.x - size.width / 2, y: center.y - size.height / 2, width: size.width, height: size.height)
     }
 }
+
+extension CGPoint {
+    static func - (lhs: CGPoint, rhs: CGPoint) -> CGPoint {
+        CGPoint(x: lhs.x - rhs.x, y: lhs.y - rhs.y)
+    }
+    
+    static func / (lhs: CGPoint, rhs: CGFloat) -> CGPoint {
+        CGPoint(x: lhs.x / rhs, y: lhs.y / rhs)
+    }
+}
+
+extension GraphCanvasView {
+    func moveDraggedNode() async {
+        guard let dragged = draggedNode else { return }
+        let modelDragOffset = dragOffset / zoomScale
+        if let index = viewModel.model.nodes.firstIndex(where: { $0.id == dragged.id }) {
+            let oldNode = viewModel.model.nodes[index]
+            let unwrapped = oldNode.unwrapped
+            let tentativePos = unwrapped.position + dragOffset
+            let bounds = viewModel.model.physicsEngine.simulationBounds
+            let newPos = CGPoint(
+                x: max(0, min(tentativePos.x, bounds.width)),
+                y: max(0, min(tentativePos.y, bounds.height))
+            )
+            let updatedNode: AnyNode
+            if let concrete = unwrapped as? Node {
+                let concreteUpdated = concrete.with(position: newPos, velocity: .zero)
+                updatedNode = AnyNode(concreteUpdated)
+            } else if let concrete = unwrapped as? ToggleNode {
+                let concreteUpdated = concrete.with(position: newPos, velocity: .zero)
+                updatedNode = AnyNode(concreteUpdated)
+            } else {
+                Self.logger.error("Unsupported node type for move: \(type(of: unwrapped))")
+                return
+            }
+            viewModel.model.nodes[index] = updatedNode
+            
+#if DEBUG
+            Self.logger.debug("Moved node \(unwrapped.label) to new position x=\(newPos.x), y=\(newPos.y)")
+#endif
+            
+            Task { await viewModel.model.startSimulation() }
+        }
+    }
+}
 ----------------------------------------------------------------------------------------------------
 File: GraphGesturesModifier.swift
 Path: GraphEditorWatch/Views/GraphGesturesModifier.swift
-Last modified: 2025-10-03 15:50:34
+Last modified: 2025-10-11 18:46:49
 
 Contents:
-//
-//  GraphGesturesModifier.swift
-//  GraphEditorWatch
-//
-//  Created by handcart on 2025-08-16
+// GraphGesturesModifier.swift
+// Reduced length by extracting utilities and heavy methods to extensions/utils
 
 import SwiftUI
-import WatchKit
 import GraphEditorShared
-import os.log  // Added for optimized logging
-
-enum HitType {
-    case node
-    case edge
-}
 
 struct GestureContext {
     let zoomScale: CGFloat
@@ -437,12 +364,6 @@ struct GestureContext {
     let effectiveCentroid: CGPoint
 }
 
-struct NodeDistanceInfo {
-    let label: Int
-    let screenPos: CGPoint
-    let dist: CGFloat
-}
-
 struct GraphGesturesModifier: ViewModifier {
     let viewModel: GraphViewModel
     @Binding var zoomScale: CGFloat
@@ -459,363 +380,213 @@ struct GraphGesturesModifier: ViewModifier {
     @Binding var crownPosition: Double
     let onUpdateZoomRanges: () -> Void
     @Binding var isAddingEdge: Bool
+    @Binding var isDragging: Bool
+    @State private var longPressLocation: CGPoint?
+    @State private var longPressTimer: Timer?
     
-    @State private var dragStartNode: (any NodeProtocol)?
-    @State private var isMovingSelectedNode: Bool = false
-    @State private var gestureStartCentroid: CGPoint = .zero
-    @State private var startLocation: CGPoint?
+    private let minDragDistance: CGFloat = 10.0
+    private let longPressDuration: TimeInterval = 0.5
+    
+    func body(content: Content) -> some View {
+        content
+            .digitalCrownRotation(
+                $crownPosition,
+                from: 0,
+                through: Double(AppConstants.crownZoomSteps),
+                sensitivity: .high,
+                isContinuous: true,
+                isHapticFeedbackEnabled: true
+            )
+            .onChange(of: crownPosition) { oldValue, newValue in
+                handleCrownRotation(oldValue: oldValue, newValue: newValue)
+            }
+            .onTapGesture { location in
+                let context = GestureContext(zoomScale: zoomScale, offset: offset, viewSize: viewSize, effectiveCentroid: viewModel.effectiveCentroid)
+                let visibleNodes = viewModel.model.visibleNodes()
+                let visibleEdges = viewModel.model.visibleEdges()
+                handleTap(at: location, visibleNodes: visibleNodes, visibleEdges: visibleEdges, context: context)
+            }
+            .gesture(dragGesture)
+            .gesture(longPressGesture)
+            .simultaneousGesture(panGesture)
+    }
     
-    private let dragStartThreshold: CGFloat = 10.0  // Increased for better tap vs. drag distinction
+    private var dragGesture: some Gesture {
+            DragGesture(minimumDistance: minDragDistance)
+                .onChanged { value in
+                    // If handleDragChanged has async calls, it's fine as long as they're wrapped in Task inside it
+                    handleDragChanged(value: value)
+                }
+                .onEnded { value in
+                    handleDragEnded(value: value)
+                }
+        }
     
-    // Optimized logger
-    private let logger = Logger(subsystem: "io.handcart.GraphEditor", category: "gestures")
+    private var longPressGesture: some Gesture {
+        LongPressGesture(minimumDuration: longPressDuration)
+            .onEnded { _ in
+                handleLongPressEnded()
+            }
+    }
     
-    func body(content: Content) -> some View {
-        let dragGesture = DragGesture(minimumDistance: 0, coordinateSpace: .local)  // Zero for immediate detection
+    private var panGesture: some Gesture {
+        DragGesture()
             .onChanged { value in
-                let visibleNodes = viewModel.model.visibleNodes()  // Or viewModel.model.nodes if no visibleNodes()
-                let effectiveCentroid = viewModel.effectiveCentroid  // From ViewModel
-                let context = GestureContext(zoomScale: zoomScale, offset: offset, viewSize: viewSize, effectiveCentroid: effectiveCentroid)
-                handleDragChanged(value: value, visibleNodes: visibleNodes, context: context)
+                handlePanChanged(value: value)
             }
             .onEnded { value in
-                let visibleNodes = viewModel.model.visibleNodes()
-                let visibleEdges = viewModel.model.visibleEdges()  // NEW: Get visible edges (assume method exists; use model.edges if not)
-                let effectiveCentroid = viewModel.effectiveCentroid
-                let context = GestureContext(zoomScale: zoomScale, offset: offset, viewSize: viewSize, effectiveCentroid: effectiveCentroid)
-                handleDragEnded(value: value, visibleNodes: visibleNodes, visibleEdges: visibleEdges, context: context)
+                handlePanEnded(value: value)
             }
-        content
-            .highPriorityGesture(dragGesture)
+    }
+    
+    private func handleCrownRotation(oldValue: Double, newValue: Double) {
+        let delta = newValue - oldValue
+        let zoomDelta = delta / Double(AppConstants.crownZoomSteps) * (maxZoom - 1.0)
+        zoomScale = (zoomScale + zoomDelta).clamped(to: 0.2...maxZoom)
+        onUpdateZoomRanges()
+    }
+    
+    private var currentCentroid: CGPoint {
+        if let node = draggedNode {
+            return node.position + dragOffset  // Virtual for single selected node drag
+        }
+        return viewModel.effectiveCentroid
     }
 }
 
 extension GraphGesturesModifier {
-    
-    /*
-    // Screen-space hit test for nodes (consistent usability)
-    func hitTestNodesInScreenSpace(at screenPos: CGPoint, visibleNodes: [any NodeProtocol], context: GestureContext) -> (any NodeProtocol)? {
-        var closestNode: (any NodeProtocol)?
-        var minScreenDist: CGFloat = .infinity
-        let minHitRadius: CGFloat = 10.0  // Minimum tappable radius in screen points for small zooms
-        let padding: CGFloat = 5.0  // Extra padding in screen points for forgiveness
-
-    #if DEBUG
-        var nodeDistances: [NodeDistanceInfo] = []  // For logging
-        logger.debug("Using centroid: \(String(describing: context.effectiveCentroid)) for this gesture")
-    #endif
-
-        for node in visibleNodes {
-            let safeZoom = max(context.zoomScale, 0.1)
-            let nodeScreenPos = CoordinateTransformer.modelToScreen(node.position, effectiveCentroid: context.effectiveCentroid, zoomScale: safeZoom, offset: context.offset, viewSize: context.viewSize)
-            let dist = distance(screenPos, nodeScreenPos)
-
-            let visibleRadius = node.radius * safeZoom
-            let nodeHitRadius = max(minHitRadius, visibleRadius) + padding  // Matches visible size, with min and padding
-
-    #if DEBUG
-            nodeDistances.append(NodeDistanceInfo(label: node.label, screenPos: nodeScreenPos, dist: dist))
-            // Optional: Log per-node hit radius for debugging
-            logger.debug("Node \(node.label): visibleRadius \(visibleRadius), nodeHitRadius \(nodeHitRadius)")
-    #endif
-
-            if dist <= nodeHitRadius && dist < minScreenDist {
-                minScreenDist = dist
-                closestNode = node
+    func handleTap(at screenPos: CGPoint, visibleNodes: [any NodeProtocol], visibleEdges: [GraphEdge], context: GestureContext) {
+        _ = CoordinateTransformer.screenToModel(screenPos, effectiveCentroid: context.effectiveCentroid, zoomScale: context.zoomScale, offset: context.offset, viewSize: context.viewSize)
+        
+        let hitContext = HitTestContext(zoomScale: context.zoomScale, offset: context.offset, viewSize: context.viewSize, effectiveCentroid: context.effectiveCentroid)
+        let hitNode = GestureUtils.closestNode(at: screenPos, visibleNodes: visibleNodes, context: hitContext)
+        
+        if let node = hitNode {
+            selectedNodeID = node.id
+            selectedEdgeID = nil
+            if isAddingEdge, let from = draggedNode {
+                addEdge(from: from.id, to: node.id)
             }
+            return
         }
-
-    #if DEBUG
-        // Log sorted by distance for verification
-        nodeDistances.sort { $0.dist < $1.dist }
-        logger.debug("Hit Test Diagnostics: Tap at screen \(String(describing: screenPos))")
-        for info in nodeDistances.prefix(5) {  // Limit to top 5 closest
-            logger.debug("Node \(info.label): screen pos \(String(describing: info.screenPos)), dist \(info.dist)")
-        }
-        if let closest = closestNode {
-            logger.debug("Hit: Node \(closest.label) (dist \(minScreenDist))")
-        } else {
-            logger.debug("Miss: Closest dist \(nodeDistances.first?.dist ?? .infinity)")
+        
+        let hitEdge = GestureUtils.closestEdge(at: screenPos, visibleEdges: visibleEdges, visibleNodes: visibleNodes, context: hitContext)
+        if let edge = hitEdge {
+            selectedEdgeID = edge.id
+            selectedNodeID = nil
+            return
         }
-    #endif
-        return closestNode
+        
+        selectedNodeID = nil
+        selectedEdgeID = nil
     }
     
-    // Screen-space hit test for edges (for consistency with nodes)
-    func hitTestEdgesInScreenSpace(at screenPos: CGPoint, visibleEdges: [GraphEdge], visibleNodes: [any NodeProtocol], context: GestureContext) -> GraphEdge? {
-        var closestEdge: GraphEdge?
-        var minScreenDist: CGFloat = .infinity
-        let hitScreenRadius: CGFloat = Constants.App.hitScreenRadius / 2  // Smaller for edges to avoid overlapping node taps
+    // Keep this sync; wrap async inside Task
+    private func handleDragChanged(value: DragGesture.Value) {
+        isDragging = true
+        let screenPos = value.location
+        let context = HitTestContext(zoomScale: zoomScale, offset: offset, viewSize: viewSize, effectiveCentroid: currentCentroid)
         
-#if DEBUG
-        var edgeDistances: [(id: UUID, dist: CGFloat)] = []  // For logging
-#endif
+        var localDraggedNode: (any NodeProtocol)? = draggedNode  // Local to handle immediate set
         
-        for edge in visibleEdges {
-            guard let fromNode = visibleNodes.first(where: { $0.id == edge.from }),
-                  let toNode = visibleNodes.first(where: { $0.id == edge.target }) else { continue }
-            
-            let safeZoom = max(context.zoomScale, 0.1)
-            let fromScreen = CoordinateTransformer.modelToScreen(fromNode.position, effectiveCentroid: context.effectiveCentroid, zoomScale: safeZoom, offset: context.offset, viewSize: context.viewSize)
-            let toScreen = CoordinateTransformer.modelToScreen(toNode.position, effectiveCentroid: context.effectiveCentroid, zoomScale: safeZoom, offset: context.offset, viewSize: context.viewSize)
-            let dist = pointToLineDistance(point: screenPos, from: fromScreen, endPoint: toScreen)
+        if localDraggedNode == nil {
+            let visibleNodes = viewModel.model.visibleNodes()
+            print("Drag start: Visible nodes count = \(visibleNodes.count)")  // Debug: Confirm nodes
             
-#if DEBUG
-            edgeDistances.append((edge.id, dist))
-#endif
-            
-            if dist < minScreenDist && dist <= hitScreenRadius {
-                minScreenDist = dist
-                closestEdge = edge
-            }
-        }
-        
-#if DEBUG
-        // Log sorted by distance
-        edgeDistances.sort { $0.dist < $1.dist }
-        logger.debug("Edge Hit Test at screen \(String(describing: screenPos))")
-        for (id, dist) in edgeDistances.prefix(3) {
-            logger.debug("Edge \(id): dist \(dist)")
-        }
-        if let closest = closestEdge {
-            logger.debug("Hit: Edge \(closest.id) (dist \(minScreenDist) <= \(hitScreenRadius))")
-        } else {
-            logger.debug("Miss: Closest dist \(edgeDistances.first?.dist ?? .infinity) > \(hitScreenRadius)")
-        }
-#endif
-        return closestEdge
-    }
-    */
-     
-    private func resetGestureState() {
-        dragStartNode = nil
-        isMovingSelectedNode = false
-        draggedNode = nil
-        dragOffset = .zero
-        potentialEdgeTarget = nil
-        panStartOffset = nil
-        startLocation = nil
-        isAddingEdge = false
-        onUpdateZoomRanges()
-        gestureStartCentroid = .zero
-    }
-    
-    func handleTap(at location: CGPoint, visibleNodes: [any NodeProtocol], visibleEdges: [GraphEdge], context: GestureContext) -> Bool {
-    #if DEBUG
-        logger.debug("Hit Test Diagnostics: Tap at screen \(String(describing: location))")
-        logger.debug("Visible Nodes Count: \(visibleNodes.count)")
-        logger.debug("--------------------------------")
-    #endif
-      
-        // Pause simulation first (mimics handleTap)
-        Task { await viewModel.model.pauseSimulation() }
-      
-        let hitContext = HitTestContext(zoomScale: context.zoomScale, offset: context.offset, viewSize: context.viewSize, effectiveCentroid: context.effectiveCentroid)
-        let hitNode = HitTestHelper.closestNode(at: location, visibleNodes: visibleNodes, context: hitContext)
-        if let node = hitNode {
-            // Node hit: Handle toggle or selection (replicates viewModel.handleTap logic)
-            if let toggleNode = node as? ToggleNode {
-                // Toggle without selection
-                let updated = toggleNode.handlingTap()
-                if let index = viewModel.model.nodes.firstIndex(where: { $0.id == toggleNode.id }) {
-                    viewModel.model.nodes[index] = AnyNode(updated)
+            if let closest = GestureUtils.closestNode(at: screenPos, visibleNodes: visibleNodes, context: context) {
+                print("Node hit: ID \(closest.id.uuidString)")  // Debug: Confirm hit (fixed UUID to String)
+                draggedNode = closest  // Set state
+                localDraggedNode = closest  // Update local immediately
+                dragOffset = .zero
+                viewModel.selectedNodeID = closest.id
+                
+                // Wrap async call
+                Task {
+                    await viewModel.model.pauseSimulation()
+                    print("Drag started: Simulation paused")  // Confirm in console
                 }
-                selectedNodeID = nil
-                selectedEdgeID = nil
-                logger.debug("Toggled ToggleNode \(toggleNode.label)")
+            } else if let _ = GestureUtils.closestEdge(at: screenPos, visibleEdges: viewModel.model.visibleEdges(), visibleNodes: viewModel.model.visibleNodes(), context: context) {
+                // Handle edge drag if needed (add Task if async)
             } else {
-                // Select regular node (toggle off if already)
-                selectedNodeID = (node.id == selectedNodeID) ? nil : node.id
-                selectedEdgeID = nil
-                logger.debug("Selected regular Node \(node.label)")
-            }
-            // Sync with ViewModel (triggers onChange in ContentView)
-            viewModel.objectWillChange.send()
-          
-            // Resume simulation after delay (mimics handleTap)
-            Task { await viewModel.resumeSimulationAfterDelay() }
-            return true  // Hit occurred
-        } else {
-            // No node: Check edges
-            let hitEdge = HitTestHelper.closestEdge(at: location, visibleEdges: visibleEdges, visibleNodes: visibleNodes, context: hitContext)
-            if let edge = hitEdge {
-                // Select edge, clear node
-                selectedEdgeID = edge.id
-                selectedNodeID = nil
-                logger.debug("Tap selected Edge \(edge.id.uuidString.prefix(8))")
-              
-                // Sync with ViewModel (triggers onChange in ContentView)
-                viewModel.objectWillChange.send()
-              
-                // Resume simulation after delay (mimics handleTap)
-                Task { await viewModel.resumeSimulationAfterDelay() }
-                return true  // Hit occurred
-            } else {
-                // Miss: Clear all
-                selectedNodeID = nil
-                selectedEdgeID = nil
-                logger.debug("Tap missed; cleared selections")
-              
-                // Sync with ViewModel (triggers onChange in ContentView)
-                viewModel.objectWillChange.send()
-              
-                // Resume simulation after delay (mimics handleTap)
-                Task { await viewModel.resumeSimulationAfterDelay() }
-                return false  // No hit
+                print("No node hit; falling back to pan")  // Debug: Why pan?
+                panStartOffset = offset
             }
         }
-    }
-  
-    private func handleDragChanged(value: DragGesture.Value, visibleNodes: [any NodeProtocol], context: GestureContext) {
-        let location = value.location
-        let translation = value.translation
-        let dragMagnitude = distance(.zero, CGPoint(x: translation.width, y: translation.height))
-      
-        // Initial hit if no dragStartNode (start of drag)
-        if dragStartNode == nil {
-            let hitContext = HitTestContext(zoomScale: context.zoomScale, offset: context.offset, viewSize: context.viewSize, effectiveCentroid: context.effectiveCentroid)
-            let hitNode = HitTestHelper.closestNode(at: location, visibleNodes: visibleNodes, context: hitContext)
-            if let node = hitNode {
-                dragStartNode = node
-                draggedNode = node
-                dragOffset = .zero
-                isAddingEdge = true  // Enter edge creation mode
-                logger.debug("Drag of \(dragMagnitude) started from Node \(node.label)")
-            } else {
-                // Pan the canvas instead
-                if panStartOffset == nil {
-                    panStartOffset = offset
+        
+        if let node = localDraggedNode {
+            let modelDelta = CGPoint(x: value.translation.width / zoomScale, y: value.translation.height / zoomScale)
+            dragOffset = modelDelta
+            isAddingEdge = distance(value.predictedEndLocation, value.startLocation) > 30.0  // Uses global distance func
+            if isAddingEdge {
+                if let target = GestureUtils.closestNode(at: value.predictedEndLocation, visibleNodes: viewModel.model.visibleNodes().filter { $0.id != node.id }, context: context) {
+                    potentialEdgeTarget = target
+                } else {
+                    potentialEdgeTarget = nil
                 }
-                let delta = CGSize(width: translation.width, height: translation.height)
-                offset = panStartOffset! + delta
-            }
-            startLocation = location  // For tap threshold in onEnded
-            gestureStartCentroid = context.effectiveCentroid
-            return
-        }
-      
-        // Ongoing drag: Update drag offset and check for potential target
-        if let node = draggedNode {
-            dragOffset = CGPoint(x: translation.width / zoomScale, y: translation.height / zoomScale)
-            let hitContext = HitTestContext(zoomScale: context.zoomScale, offset: context.offset, viewSize: context.viewSize, effectiveCentroid: context.effectiveCentroid)
-            let potential = HitTestHelper.closestNode(at: location, visibleNodes: visibleNodes, context: hitContext)
-            potentialEdgeTarget = (potential?.id != node.id) ? potential : nil  // Avoid self-edges
-            if let target = potentialEdgeTarget {
-                logger.debug("Potential edge target: Node \(target.label)")
             }
+        } else if let startOffset = panStartOffset {
+            offset = startOffset + CGSize(width: value.translation.width, height: value.translation.height)
         }
     }
-    
-    private func handleDragEnded(value: DragGesture.Value, visibleNodes: [any NodeProtocol], visibleEdges: [GraphEdge], context: GestureContext) {
-        let location = value.location
-        let translation = value.translation
-        let dragMagnitude = distance(.zero, CGPoint(x: translation.width, y: translation.height))
-        
-        // Defer cleanup (ensures reset even on errors/taps)
-        defer { resetGestureState() }
-        
-        // Early exit for taps (short drag) - enhanced for node/edge selection
-        if let start = startLocation, dragMagnitude < dragStartThreshold, distance(start, location) < dragStartThreshold {
-            let wasHit = handleTap(at: location, visibleNodes: visibleNodes, visibleEdges: visibleEdges, context: context)
-            if wasHit {
-                WKInterfaceDevice.current().play(.click)  // Subtler haptic feedback (short tick/tap) on successful hit
-            }
-            return  // Exit early
+
+    // Keep this sync; wrap async inside Task
+    private func handleDragEnded(value: DragGesture.Value) {
+        guard let node = draggedNode else {
+            print("Drag end: No draggedNode (likely pan mode)")  // Debug: Why skipped?
+            panStartOffset = nil
+            isDragging = false
+            return
         }
         
-        print("Processing as drag: magnitude \(dragMagnitude), translation \(translation)")
+        let modelDelta = CGPoint(x: value.translation.width / zoomScale, y: value.translation.height / zoomScale)
         
-        if let dragged = draggedNode {
-            Task { await viewModel.model.snapshot() }
-            let modelDragOffset = CGPoint(x: translation.width / zoomScale, y: translation.height / zoomScale)
-            print("Drag offset in model: \(modelDragOffset)")
-            
-            if let target = potentialEdgeTarget, target.id != dragged.id, isAddingEdge {
-                handleEdgeCreation(from: dragged, to: target, translation: translation)
+        // Wrap all async + state clearing to ensure order
+        Task {
+            await viewModel.model.updateNodePosition(id: node.id, delta: modelDelta)
+            if let target = potentialEdgeTarget, isAddingEdge {
+                print("Adding edge from \(node.id.uuidString) to \(target.id.uuidString)")  // Debug: Confirm add (fixed UUID to String)
+                await viewModel.addEdge(from: node.id, to: target.id, type: viewModel.pendingEdgeType)
             } else {
-                handleNodeMovement(for: dragged, with: modelDragOffset)
+                print("No edge added: target=\(potentialEdgeTarget?.id.uuidString ?? "nil"), isAddingEdge=\(isAddingEdge)")  // Debug: Why not? (fixed UUID to String)
             }
-        }
-        withAnimation(.spring(duration: 0.3, bounce: 0.2)) {
-            onUpdateZoomRanges()
+            await viewModel.model.resumeSimulation()
+            print("Drag ended: Simulation resumed")
+            
+            // Clear states after async completes (prevents premature clearing)
+            draggedNode = nil
+            dragOffset = .zero
+            potentialEdgeTarget = nil
+            isAddingEdge = false
+            panStartOffset = nil
+            isDragging = false
         }
     }
     
-    private func handleEdgeCreation(from dragged: any NodeProtocol, to target: any NodeProtocol, translation: CGSize) {
-        // Duplicate check with logging
-        let exists = viewModel.model.edges.contains { edge in
-            (edge.from == dragged.id && edge.target == target.id) || (edge.from == target.id && edge.target == dragged.id)
-        }
-        if !exists {
-            print("No duplicate; adding edge")
-            // Heuristic: Downward = hierarchy
-            let type = (translation.height > 0) ? .hierarchy : viewModel.pendingEdgeType
-            viewModel.pendingEdgeType = type  // Update for UI
-            Task {
-                await viewModel.addEdge(from: dragged.id, to: target.id, type: type)  // Async call
-            }
-            print("Created edge of type \(type.rawValue) from node \(dragged.label) to \(target.label)")
-            isAddingEdge = false
-        } else {
-            print("Duplicate edge ignored between \(dragged.label) and \(target.label)")
-        }
+    private func handleLongPressEnded() {
+        showMenu = true
     }
     
-    private func handleNodeMovement(for dragged: any NodeProtocol, with modelDragOffset: CGPoint) {
-        // No target: Move the node (with casts for .with, as it's not on protocol)
-        if let index = viewModel.model.nodes.firstIndex(where: { $0.id == dragged.id }) {
-            let oldNode = viewModel.model.nodes[index]
-            let unwrapped = oldNode.unwrapped
-            let newPos = unwrapped.position + modelDragOffset
-            let updatedNode: AnyNode
-            if let concrete = unwrapped as? Node {
-                let concreteUpdated = concrete.with(position: newPos, velocity: .zero)
-                updatedNode = AnyNode(concreteUpdated)
-            } else if let concrete = unwrapped as? ToggleNode {
-                let concreteUpdated = concrete.with(position: newPos, velocity: .zero)
-                updatedNode = AnyNode(concreteUpdated)
-            } else {
-                logger.error("Unsupported node type for move: \(type(of: unwrapped))")
-                return
-            }
-            viewModel.model.nodes[index] = updatedNode
-            print("Moved node \(unwrapped.label) to new position \(newPos)")
-            Task { await viewModel.model.startSimulation() }
+    private func handlePanChanged(value: DragGesture.Value) {
+        if panStartOffset == nil {
+            panStartOffset = offset
         }
+        offset = CGSize(width: panStartOffset!.width + value.translation.width, height: panStartOffset!.height + value.translation.height)
     }
-}
-extension GraphGesturesModifier {
-    public func pointToLineDistance(point: CGPoint, from startPoint: CGPoint, endPoint: CGPoint) -> CGFloat {
-        let pointX = Double(point.x), pointY = Double(point.y)
-        let startX = Double(startPoint.x), startY = Double(startPoint.y)
-        let endX = Double(endPoint.x), endY = Double(endPoint.y)
-        
-        let lineVecX = endX - startX
-        let lineVecY = endY - startY
-        let lineLen = hypot(lineVecX, lineVecY)
-        
-        if lineLen == 0 {
-            return distance(point, startPoint)
+    
+    private func handlePanEnded(value: DragGesture.Value) {
+        panStartOffset = nil
+    }
+    
+    private func addEdge(from fromID: NodeID, to targetID: NodeID) {
+        Task {
+            await viewModel.addEdge(from: fromID, to: targetID, type: viewModel.pendingEdgeType)
         }
-        
-        let pointVecX = pointX - startX
-        let pointVecY = pointY - startY
-        let dot = pointVecX * lineVecX + pointVecY * lineVecY
-        let denom = lineLen * lineLen
-        let projectionParam = dot / denom
-        let clampedParam = max(0.0, min(1.0, projectionParam))
-        
-        let projX = startX + lineVecX * clampedParam
-        let projY = startY + lineVecY * clampedParam
-        
-        let proj = CGPoint(x: CGFloat(projX), y: CGFloat(projY))
-        return distance(point, proj)
     }
 }
 ----------------------------------------------------------------------------------------------------
 File: GraphSection.swift
 Path: GraphEditorWatch/Views/GraphSection.swift
-Last modified: 2025-10-07 00:41:34
+Last modified: 2025-10-11 10:22:33
 
 Contents:
 //
@@ -973,4 +744,383 @@ struct GraphSection: View {
         .accessibilityLabel("Graph section")  // NEW: Accessibility
     }
 }
+----------------------------------------------------------------------------------------------------
+File: GraphUtilities.swift
+Path: GraphEditorWatch/Views/GraphUtilities.swift
+Last modified: 2025-10-11 18:46:49
+
+Contents:
+// GraphUtilities.swift
+//  GraphEditor
+//
+//  Created by handcart on 9/19/25.
+//
+import SwiftUI
+import GraphEditorShared
+import CoreGraphics
+
+struct ViewSizeKey: PreferenceKey {
+    static var defaultValue: CGSize = .zero
+    static func reduce(value: inout CGSize, nextValue: () -> CGSize) {
+        value = nextValue()
+    }
+}
+
+struct NodeWrapper: Equatable, Identifiable {
+    let id: UUID?
+    let node: (any NodeProtocol)?
+    
+    init(node: (any NodeProtocol)?) {
+        self.node = node
+        self.id = node?.id
+    }
+    
+    static func == (lhs: NodeWrapper, rhs: NodeWrapper) -> Bool {
+        lhs.id == rhs.id
+    }
+}
+
+struct InnerViewConfig {
+    let geo: GeometryProxy
+    let viewModel: GraphViewModel
+    let zoomScale: Binding<CGFloat>
+    let offset: Binding<CGSize>
+    let draggedNode: Binding<NodeWrapper>
+    let dragOffset: Binding<CGPoint>
+    let potentialEdgeTarget: Binding<NodeWrapper>
+    let panStartOffset: Binding<CGSize?>
+    let showMenu: Binding<Bool>
+    let showOverlays: Binding<Bool>
+    let maxZoom: CGFloat
+    let crownPosition: Binding<Double>
+    let updateZoomRangesHandler: (CGSize) -> Void
+    let selectedNodeID: Binding<NodeID?>
+    let selectedEdgeID: Binding<UUID?>
+    let canvasFocus: FocusState<Bool>
+    let onCenterGraph: () -> Void
+    let isAddingEdge: Binding<Bool>
+    let isSimulatingBinding: Binding<Bool>
+    let isDragging: Binding<Bool>
+    
+    init(
+        geo: GeometryProxy,
+        viewModel: GraphViewModel,
+        zoomScale: Binding<CGFloat>,
+        offset: Binding<CGSize>,
+        draggedNode: Binding<NodeWrapper>,
+        dragOffset: Binding<CGPoint>,
+        potentialEdgeTarget: Binding<NodeWrapper>,
+        panStartOffset: Binding<CGSize?>,
+        showMenu: Binding<Bool>,
+        showOverlays: Binding<Bool>,
+        maxZoom: CGFloat,
+        crownPosition: Binding<Double>,
+        updateZoomRangesHandler: @escaping (CGSize) -> Void,
+        selectedNodeID: Binding<NodeID?>,
+        selectedEdgeID: Binding<UUID?>,
+        canvasFocus: FocusState<Bool>,
+        onCenterGraph: @escaping () -> Void,
+        isAddingEdge: Binding<Bool>,
+        isSimulatingBinding: Binding<Bool>,  // NEW: Add this param
+        isDragging: Binding<Bool>
+    ) {
+        self.geo = geo
+        self.viewModel = viewModel
+        self.zoomScale = zoomScale
+        self.offset = offset
+        self.draggedNode = draggedNode
+        self.dragOffset = dragOffset
+        self.potentialEdgeTarget = potentialEdgeTarget
+        self.panStartOffset = panStartOffset
+        self.showMenu = showMenu
+        self.showOverlays = showOverlays
+        self.maxZoom = maxZoom
+        self.crownPosition = crownPosition
+        self.updateZoomRangesHandler = updateZoomRangesHandler
+        self.selectedNodeID = selectedNodeID
+        self.selectedEdgeID = selectedEdgeID
+        self.canvasFocus = canvasFocus
+        self.onCenterGraph = onCenterGraph
+        self.isAddingEdge = isAddingEdge
+        self.isSimulatingBinding = isSimulatingBinding  // NEW: Assign it
+        self.isDragging = isDragging
+    }
+}
+----------------------------------------------------------------------------------------------------
+File: InnerView.swift
+Path: GraphEditorWatch/Views/InnerView.swift
+Last modified: 2025-10-11 18:40:05
+
+Contents:
+//
+//  InnerView.swift
+//  GraphEditor
+//
+//  Created by handcart on 9/19/25.
+//
+
+// InnerView.swift
+
+import SwiftUI
+import GraphEditorShared
+
+struct InnerView: View {
+    let config: InnerViewConfig
+    
+    var body: some View {
+        let draggedNodeBinding = Binding<(any NodeProtocol)?>(
+            get: { config.draggedNode.wrappedValue.node },
+            set: { config.draggedNode.wrappedValue = NodeWrapper(node: $0) }
+        )
+        let potentialEdgeTargetBinding = Binding<(any NodeProtocol)?>(
+            get: { config.potentialEdgeTarget.wrappedValue.node },
+            set: { config.potentialEdgeTarget.wrappedValue = NodeWrapper(node: $0) }
+        )
+        
+        let canvasView = GraphCanvasView(
+            viewModel: config.viewModel,
+            zoomScale: config.zoomScale,
+            offset: config.offset,
+            draggedNode: draggedNodeBinding,
+            dragOffset: config.dragOffset,
+            potentialEdgeTarget: potentialEdgeTargetBinding,
+            selectedNodeID: config.selectedNodeID,
+            viewSize: config.geo.size,
+            panStartOffset: config.panStartOffset,
+            showMenu: config.showMenu,
+            maxZoom: config.maxZoom,
+            crownPosition: config.crownPosition,
+            onUpdateZoomRanges: { config.updateZoomRangesHandler(config.geo.size) },
+            selectedEdgeID: config.selectedEdgeID,
+            showOverlays: config.showOverlays,
+            isAddingEdge: config.isAddingEdge,
+            isDragging: config.isDragging
+        )
+            .accessibilityIdentifier("GraphCanvas")
+            .focused(config.canvasFocus.projectedValue)
+            .focusable()
+        
+        if config.showMenu.wrappedValue {
+            MenuView(
+                viewModel: config.viewModel,
+                isSimulatingBinding: config.isSimulatingBinding,
+                onCenterGraph: config.onCenterGraph,
+                showMenu: config.showMenu,
+                showOverlays: config.showOverlays,
+                selectedNodeID: config.selectedNodeID,    // NEW: Pass binding
+                selectedEdgeID: config.selectedEdgeID     // NEW: Pass binding
+            )
+            .navigationTitle("Menu")
+        } else {
+            canvasView
+        }
+    }
+}
+----------------------------------------------------------------------------------------------------
+File: MenuView.swift
+Path: GraphEditorWatch/Views/MenuView.swift
+Last modified: 2025-10-06 20:24:41
+
+Contents:
+//
+//  MenuView.swift
+//  GraphEditor
+//
+//  Created by handcart on 8/20/25.
+//
+
+import SwiftUI
+import WatchKit
+import GraphEditorShared
+
+struct MenuView: View {
+    let viewModel: GraphViewModel
+    let isSimulatingBinding: Binding<Bool>
+    let onCenterGraph: () -> Void
+    @Binding var showMenu: Bool
+    @Binding var showOverlays: Bool
+    @Binding var selectedNodeID: NodeID?    // NEW: @Binding for reactivity
+    @Binding var selectedEdgeID: UUID?      // NEW: @Binding for reactivity
+    
+    @FocusState private var isMenuFocused: Bool
+    @State private var showEditSheet: Bool = false
+    @State private var isAddingEdge: Bool = false
+    
+    var body: some View {
+        List {
+            AddSection(
+                viewModel: viewModel,
+                selectedNodeID: selectedNodeID,  // NEW: Use binding.wrappedValue
+                onDismiss: { showMenu = false },
+                onAddEdge: { type in
+                    viewModel.pendingEdgeType = type
+                    isAddingEdge = true
+                }
+            )
+            
+            // NEW: Conditional EditSection to avoid empty header
+            if selectedNodeID != nil || selectedEdgeID != nil {  // NEW: Use bindings
+                EditSection(
+                    viewModel: viewModel,
+                    selectedNodeID: selectedNodeID,      // NEW: Pass binding.wrappedValue
+                    selectedEdgeID: selectedEdgeID,      // NEW: Pass binding.wrappedValue
+                    onDismiss: { showMenu = false },
+                    onEditNode: { showEditSheet = true }
+                )
+            }
+            
+            ViewSection(
+                showOverlays: $showOverlays,  // Now in scope
+                isSimulating: isSimulatingBinding,
+                onCenterGraph: onCenterGraph,
+                onDismiss: { showMenu = false },  // Now in scope
+                onSimulationChange: { newValue in
+                    viewModel.model.isSimulating = newValue
+                    if newValue {
+                        Task { await viewModel.model.startSimulation() }
+                    } else {
+                        Task { await viewModel.model.stopSimulation() }
+                    }
+                }
+            )
+            
+            GraphSection(viewModel: viewModel, onDismiss: { showMenu = false })  // Now in scope
+        }
+        .accessibilityIdentifier("menuList")
+        .navigationTitle("Menu")
+        .focused($isMenuFocused)  // New: Bind focus to list
+        .onAppear {
+            isMenuFocused = true
+            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
+                isMenuFocused = true
+            }
+            // NEW: Debug log for selections
+            print("Menu appeared: selectedNodeID=\(selectedNodeID?.uuidString.prefix(8) ?? "nil"), selectedEdgeID=\(selectedEdgeID?.uuidString.prefix(8) ?? "nil")")
+        }
+        .onChange(of: isMenuFocused) { _, newValue in
+            print("Menu focus: \(newValue)") // Debug (fixed typo)
+            if !newValue {
+                isMenuFocused = true // Auto-recover
+            }
+        }
+        .ignoresSafeArea(.keyboard)
+        .sheet(isPresented: $showEditSheet) {  // New: Local sheet for edit
+            if let selectedID = viewModel.selectedNodeID {
+                EditContentSheet(selectedID: selectedID, viewModel: viewModel, onSave: { newContent in
+                    Task { await viewModel.model.updateNodeContent(withID: selectedID, newContent: newContent) }
+                    showEditSheet = false
+                })
+            }
+        }
+        .onChange(of: isAddingEdge) { _, newValue in  // New: Handle add edge mode (if needed; or pass to parent)
+            if newValue {
+                // Optionally notify viewModel or handle here
+            }
+        }
+    }
+}
+
+#Preview {
+    @Previewable @State var mockSelectedNodeID: NodeID?
+    @Previewable @State var mockSelectedEdgeID: UUID? = UUID()  // Simulate
+    let mockViewModel = GraphViewModel(model: GraphModel(storage: PersistenceManager(), physicsEngine: PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))))
+    mockViewModel.setSelectedEdge(UUID())  // Simulate edge selection for preview
+    return MenuView(
+        viewModel: mockViewModel,
+        isSimulatingBinding: .constant(false),
+        onCenterGraph: {},
+        showMenu: .constant(true),
+        showOverlays: .constant(false),
+        selectedNodeID: $mockSelectedNodeID,  // NEW
+        selectedEdgeID: $mockSelectedEdgeID   // NEW
+    )
+}
+----------------------------------------------------------------------------------------------------
+File: NodeView.swift
+Path: GraphEditorWatch/Views/NodeView.swift
+Last modified: 2025-09-16 11:24:30
+
+Contents:
+//
+//  NodeView.swift
+//  GraphEditor
+//
+//  Created by handcart on 8/13/25.
+//
+
+import SwiftUI
+import GraphEditorShared
+
+struct NodeView: View {
+    let node: any NodeProtocol
+    let isSelected: Bool
+    let zoomScale: CGFloat
+    
+    var body: some View {
+        ZStack {
+            if isSelected {
+                Circle()
+                    .stroke(Color.yellow, lineWidth: 4 * zoomScale)
+                    .frame(width: node.radius * 2 * zoomScale + 4 * zoomScale, height: node.radius * 2 * zoomScale + 4 * zoomScale)
+            }
+            Circle()
+                .fill(node.fillColor)  // Or dynamic based on node type
+                .frame(width: node.radius * 2 * zoomScale, height: node.radius * 2 * zoomScale)
+            
+            // Add icon/label as in ToggleNode.draw
+            if let toggleNode = node as? ToggleNode {
+                Text(toggleNode.isExpanded ? "-" : "+")
+                    .foregroundColor(.white)
+                    .font(.system(size: max(8.0, 12.0 * zoomScale), weight: .bold))
+            }
+            
+            Text("\(node.label)")
+                .foregroundColor(.white)
+                .font(.system(size: max(8.0, 12.0 * zoomScale)))
+                .offset(y: -(node.radius + 10) * zoomScale)  // Position above
+        }
+    }
+}
+----------------------------------------------------------------------------------------------------
+File: ViewSection.swift
+Path: GraphEditorWatch/Views/ViewSection.swift
+Last modified: 2025-10-05 16:02:44
+
+Contents:
+//
+//  ViewSection.swift
+//  GraphEditor
+//
+//  Created by handcart on 10/5/25.
+//
+
+import SwiftUI
+
+struct ViewSection: View {
+    @Binding var showOverlays: Bool
+    let isSimulating: Binding<Bool>
+    let onCenterGraph: () -> Void
+    let onDismiss: () -> Void
+    let onSimulationChange: (Bool) -> Void
+    
+    var body: some View {
+        Section(header: Text("View")) {
+            Toggle("Show Overlays", isOn: $showOverlays)
+                .onSubmit { /* No-op for toggle */ }
+            
+            Toggle("Run Simulation", isOn: isSimulating)
+                .onChange(of: isSimulating.wrappedValue) { _, newValue in
+                    onSimulationChange(newValue)
+                }
+                .onSubmit { /* No-op for toggle */ }
+            
+            Button("Center Graph") {
+                onCenterGraph()
+                onDismiss()
+            }
+            .onSubmit { onCenterGraph(); onDismiss() }
+        }
+        .accessibilityLabel("View section")  // NEW: Accessibility
+    }
+}
 --------------------------------------------------
diff --git a/swift_ui_context_parts/part-6.txt b/swift_ui_context_parts/part-6.txt
index f57d425..a890467 100644
--- a/swift_ui_context_parts/part-6.txt
+++ b/swift_ui_context_parts/part-6.txt
@@ -1,394 +1,16 @@
 ## Focused Project Concatenation
 This file includes only UI, interactivity, model, and core logic files.
 Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
-Current date: 2025-10-10 13:25:47
+Current date: 2025-10-12 10:03:05
 Table of Contents:
-1. GraphEditorWatch/Views/GraphUtilities.swift
-2. GraphEditorWatch/Views/InnerView.swift
-3. GraphEditorWatch/Views/MenuView.swift
-4. GraphEditorWatch/Views/NodeView.swift
-5. GraphEditorWatch/Views/ViewSection.swift
-6. GraphEditorWatchTests/AccessibilityTests.swift
-7. GraphEditorWatchTests/CoordinateTransformerTests.swift
-8. GraphEditorWatchTests/EditContentSheetTests.swift
-9. GraphEditorWatchTests/GestureTests.swift
-10. GraphEditorWatchTests/GraphEditorWatchTests.swift
-11. GraphEditorWatchTests/GraphGesturesModifierTests.swift--------------------------------------------------
-File: GraphUtilities.swift
-Path: GraphEditorWatch/Views/GraphUtilities.swift
-Last modified: 2025-09-19 14:46:52
-
-Contents:
-// GraphUtilities.swift
-//  GraphEditor
-//
-//  Created by handcart on 9/19/25.
-//
-import SwiftUI
-import GraphEditorShared
-import CoreGraphics
-
-struct ViewSizeKey: PreferenceKey {
-    static var defaultValue: CGSize = .zero
-    static func reduce(value: inout CGSize, nextValue: () -> CGSize) {
-        value = nextValue()
-    }
-}
-
-struct NodeWrapper: Equatable, Identifiable {
-    let id: UUID?
-    let node: (any NodeProtocol)?
-    
-    init(node: (any NodeProtocol)?) {
-        self.node = node
-        self.id = node?.id
-    }
-    
-    static func == (lhs: NodeWrapper, rhs: NodeWrapper) -> Bool {
-        lhs.id == rhs.id
-    }
-}
-
-struct InnerViewConfig {
-    let geo: GeometryProxy
-    let viewModel: GraphViewModel
-    let zoomScale: Binding<CGFloat>
-    let offset: Binding<CGSize>
-    let draggedNode: Binding<NodeWrapper>
-    let dragOffset: Binding<CGPoint>
-    let potentialEdgeTarget: Binding<NodeWrapper>
-    let panStartOffset: Binding<CGSize?>
-    let showMenu: Binding<Bool>
-    let showOverlays: Binding<Bool>
-    let maxZoom: CGFloat
-    let crownPosition: Binding<Double>
-    let updateZoomRangesHandler: (CGSize) -> Void
-    let selectedNodeID: Binding<NodeID?>
-    let selectedEdgeID: Binding<UUID?>
-    let canvasFocus: FocusState<Bool>
-    let onCenterGraph: () -> Void
-    let isAddingEdge: Binding<Bool>
-    let isSimulatingBinding: Binding<Bool>
-    
-    init(
-        geo: GeometryProxy,
-        viewModel: GraphViewModel,
-        zoomScale: Binding<CGFloat>,
-        offset: Binding<CGSize>,
-        draggedNode: Binding<NodeWrapper>,
-        dragOffset: Binding<CGPoint>,
-        potentialEdgeTarget: Binding<NodeWrapper>,
-        panStartOffset: Binding<CGSize?>,
-        showMenu: Binding<Bool>,
-        showOverlays: Binding<Bool>,
-        maxZoom: CGFloat,
-        crownPosition: Binding<Double>,
-        updateZoomRangesHandler: @escaping (CGSize) -> Void,
-        selectedNodeID: Binding<NodeID?>,
-        selectedEdgeID: Binding<UUID?>,
-        canvasFocus: FocusState<Bool>,
-        onCenterGraph: @escaping () -> Void,
-        isAddingEdge: Binding<Bool>,
-        isSimulatingBinding: Binding<Bool>  // NEW: Add this param
-    ) {
-        self.geo = geo
-        self.viewModel = viewModel
-        self.zoomScale = zoomScale
-        self.offset = offset
-        self.draggedNode = draggedNode
-        self.dragOffset = dragOffset
-        self.potentialEdgeTarget = potentialEdgeTarget
-        self.panStartOffset = panStartOffset
-        self.showMenu = showMenu
-        self.showOverlays = showOverlays
-        self.maxZoom = maxZoom
-        self.crownPosition = crownPosition
-        self.updateZoomRangesHandler = updateZoomRangesHandler
-        self.selectedNodeID = selectedNodeID
-        self.selectedEdgeID = selectedEdgeID
-        self.canvasFocus = canvasFocus
-        self.onCenterGraph = onCenterGraph
-        self.isAddingEdge = isAddingEdge
-        self.isSimulatingBinding = isSimulatingBinding  // NEW: Assign it
-    }
-}
-----------------------------------------------------------------------------------------------------
-File: InnerView.swift
-Path: GraphEditorWatch/Views/InnerView.swift
-Last modified: 2025-09-19 14:46:52
-
-Contents:
-//
-//  InnerView.swift
-//  GraphEditor
-//
-//  Created by handcart on 9/19/25.
-//
-
-// InnerView.swift
-
-import SwiftUI
-import GraphEditorShared
-
-struct InnerView: View {
-    let config: InnerViewConfig
-    
-    var body: some View {
-        let draggedNodeBinding = Binding<(any NodeProtocol)?>(
-            get: { config.draggedNode.wrappedValue.node },
-            set: { config.draggedNode.wrappedValue = NodeWrapper(node: $0) }
-        )
-        let potentialEdgeTargetBinding = Binding<(any NodeProtocol)?>(
-            get: { config.potentialEdgeTarget.wrappedValue.node },
-            set: { config.potentialEdgeTarget.wrappedValue = NodeWrapper(node: $0) }
-        )
-        
-        let canvasView = GraphCanvasView(
-            viewModel: config.viewModel,
-            zoomScale: config.zoomScale,
-            offset: config.offset,
-            draggedNode: draggedNodeBinding,
-            dragOffset: config.dragOffset,
-            potentialEdgeTarget: potentialEdgeTargetBinding,
-            selectedNodeID: config.selectedNodeID,
-            viewSize: config.geo.size,
-            panStartOffset: config.panStartOffset,
-            showMenu: config.showMenu,
-            maxZoom: config.maxZoom,
-            crownPosition: config.crownPosition,
-            onUpdateZoomRanges: { config.updateZoomRangesHandler(config.geo.size) },
-            selectedEdgeID: config.selectedEdgeID,
-            showOverlays: config.showOverlays,
-            isAddingEdge: config.isAddingEdge
-        )
-            .accessibilityIdentifier("GraphCanvas")
-            .focused(config.canvasFocus.projectedValue)
-            .focusable()
-        
-        if config.showMenu.wrappedValue {
-            MenuView(
-                viewModel: config.viewModel,
-                isSimulatingBinding: config.isSimulatingBinding,
-                onCenterGraph: config.onCenterGraph,
-                showMenu: config.showMenu,
-                showOverlays: config.showOverlays,
-                selectedNodeID: config.selectedNodeID,    // NEW: Pass binding
-                selectedEdgeID: config.selectedEdgeID     // NEW: Pass binding
-            )
-            .navigationTitle("Menu")
-        } else {
-            canvasView
-        }
-    }
-}
-----------------------------------------------------------------------------------------------------
-File: MenuView.swift
-Path: GraphEditorWatch/Views/MenuView.swift
-Last modified: 2025-10-06 20:24:41
-
-Contents:
-//
-//  MenuView.swift
-//  GraphEditor
-//
-//  Created by handcart on 8/20/25.
-//
-
-import SwiftUI
-import WatchKit
-import GraphEditorShared
-
-struct MenuView: View {
-    let viewModel: GraphViewModel
-    let isSimulatingBinding: Binding<Bool>
-    let onCenterGraph: () -> Void
-    @Binding var showMenu: Bool
-    @Binding var showOverlays: Bool
-    @Binding var selectedNodeID: NodeID?    // NEW: @Binding for reactivity
-    @Binding var selectedEdgeID: UUID?      // NEW: @Binding for reactivity
-    
-    @FocusState private var isMenuFocused: Bool
-    @State private var showEditSheet: Bool = false
-    @State private var isAddingEdge: Bool = false
-    
-    var body: some View {
-        List {
-            AddSection(
-                viewModel: viewModel,
-                selectedNodeID: selectedNodeID,  // NEW: Use binding.wrappedValue
-                onDismiss: { showMenu = false },
-                onAddEdge: { type in
-                    viewModel.pendingEdgeType = type
-                    isAddingEdge = true
-                }
-            )
-            
-            // NEW: Conditional EditSection to avoid empty header
-            if selectedNodeID != nil || selectedEdgeID != nil {  // NEW: Use bindings
-                EditSection(
-                    viewModel: viewModel,
-                    selectedNodeID: selectedNodeID,      // NEW: Pass binding.wrappedValue
-                    selectedEdgeID: selectedEdgeID,      // NEW: Pass binding.wrappedValue
-                    onDismiss: { showMenu = false },
-                    onEditNode: { showEditSheet = true }
-                )
-            }
-            
-            ViewSection(
-                showOverlays: $showOverlays,  // Now in scope
-                isSimulating: isSimulatingBinding,
-                onCenterGraph: onCenterGraph,
-                onDismiss: { showMenu = false },  // Now in scope
-                onSimulationChange: { newValue in
-                    viewModel.model.isSimulating = newValue
-                    if newValue {
-                        Task { await viewModel.model.startSimulation() }
-                    } else {
-                        Task { await viewModel.model.stopSimulation() }
-                    }
-                }
-            )
-            
-            GraphSection(viewModel: viewModel, onDismiss: { showMenu = false })  // Now in scope
-        }
-        .accessibilityIdentifier("menuList")
-        .navigationTitle("Menu")
-        .focused($isMenuFocused)  // New: Bind focus to list
-        .onAppear {
-            isMenuFocused = true
-            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
-                isMenuFocused = true
-            }
-            // NEW: Debug log for selections
-            print("Menu appeared: selectedNodeID=\(selectedNodeID?.uuidString.prefix(8) ?? "nil"), selectedEdgeID=\(selectedEdgeID?.uuidString.prefix(8) ?? "nil")")
-        }
-        .onChange(of: isMenuFocused) { _, newValue in
-            print("Menu focus: \(newValue)") // Debug (fixed typo)
-            if !newValue {
-                isMenuFocused = true // Auto-recover
-            }
-        }
-        .ignoresSafeArea(.keyboard)
-        .sheet(isPresented: $showEditSheet) {  // New: Local sheet for edit
-            if let selectedID = viewModel.selectedNodeID {
-                EditContentSheet(selectedID: selectedID, viewModel: viewModel, onSave: { newContent in
-                    Task { await viewModel.model.updateNodeContent(withID: selectedID, newContent: newContent) }
-                    showEditSheet = false
-                })
-            }
-        }
-        .onChange(of: isAddingEdge) { _, newValue in  // New: Handle add edge mode (if needed; or pass to parent)
-            if newValue {
-                // Optionally notify viewModel or handle here
-            }
-        }
-    }
-}
-
-#Preview {
-    @Previewable @State var mockSelectedNodeID: NodeID?
-    @Previewable @State var mockSelectedEdgeID: UUID? = UUID()  // Simulate
-    let mockViewModel = GraphViewModel(model: GraphModel(storage: PersistenceManager(), physicsEngine: PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))))
-    mockViewModel.setSelectedEdge(UUID())  // Simulate edge selection for preview
-    return MenuView(
-        viewModel: mockViewModel,
-        isSimulatingBinding: .constant(false),
-        onCenterGraph: {},
-        showMenu: .constant(true),
-        showOverlays: .constant(false),
-        selectedNodeID: $mockSelectedNodeID,  // NEW
-        selectedEdgeID: $mockSelectedEdgeID   // NEW
-    )
-}
-----------------------------------------------------------------------------------------------------
-File: NodeView.swift
-Path: GraphEditorWatch/Views/NodeView.swift
-Last modified: 2025-09-16 11:24:30
-
-Contents:
-//
-//  NodeView.swift
-//  GraphEditor
-//
-//  Created by handcart on 8/13/25.
-//
-
-import SwiftUI
-import GraphEditorShared
-
-struct NodeView: View {
-    let node: any NodeProtocol
-    let isSelected: Bool
-    let zoomScale: CGFloat
-    
-    var body: some View {
-        ZStack {
-            if isSelected {
-                Circle()
-                    .stroke(Color.yellow, lineWidth: 4 * zoomScale)
-                    .frame(width: node.radius * 2 * zoomScale + 4 * zoomScale, height: node.radius * 2 * zoomScale + 4 * zoomScale)
-            }
-            Circle()
-                .fill(node.fillColor)  // Or dynamic based on node type
-                .frame(width: node.radius * 2 * zoomScale, height: node.radius * 2 * zoomScale)
-            
-            // Add icon/label as in ToggleNode.draw
-            if let toggleNode = node as? ToggleNode {
-                Text(toggleNode.isExpanded ? "-" : "+")
-                    .foregroundColor(.white)
-                    .font(.system(size: max(8.0, 12.0 * zoomScale), weight: .bold))
-            }
-            
-            Text("\(node.label)")
-                .foregroundColor(.white)
-                .font(.system(size: max(8.0, 12.0 * zoomScale)))
-                .offset(y: -(node.radius + 10) * zoomScale)  // Position above
-        }
-    }
-}
-----------------------------------------------------------------------------------------------------
-File: ViewSection.swift
-Path: GraphEditorWatch/Views/ViewSection.swift
-Last modified: 2025-10-05 16:02:44
-
-Contents:
-//
-//  ViewSection.swift
-//  GraphEditor
-//
-//  Created by handcart on 10/5/25.
-//
-
-import SwiftUI
-
-struct ViewSection: View {
-    @Binding var showOverlays: Bool
-    let isSimulating: Binding<Bool>
-    let onCenterGraph: () -> Void
-    let onDismiss: () -> Void
-    let onSimulationChange: (Bool) -> Void
-    
-    var body: some View {
-        Section(header: Text("View")) {
-            Toggle("Show Overlays", isOn: $showOverlays)
-                .onSubmit { /* No-op for toggle */ }
-            
-            Toggle("Run Simulation", isOn: isSimulating)
-                .onChange(of: isSimulating.wrappedValue) { _, newValue in
-                    onSimulationChange(newValue)
-                }
-                .onSubmit { /* No-op for toggle */ }
-            
-            Button("Center Graph") {
-                onCenterGraph()
-                onDismiss()
-            }
-            .onSubmit { onCenterGraph(); onDismiss() }
-        }
-        .accessibilityLabel("View section")  // NEW: Accessibility
-    }
-}
-----------------------------------------------------------------------------------------------------
+1. GraphEditorWatchTests/AccessibilityTests.swift
+2. GraphEditorWatchTests/CoordinateTransformerTests.swift
+3. GraphEditorWatchTests/EditContentSheetTests.swift
+4. GraphEditorWatchTests/GestureTests.swift
+5. GraphEditorWatchTests/GraphEditorWatchTests.swift
+6. GraphEditorWatchTests/GraphGesturesModifierTests.swift
+7. GraphEditorWatchTests/GraphModelTests.swift
+8. GraphEditorWatchTests/MenuViewTests.swift--------------------------------------------------
 File: AccessibilityTests.swift
 Path: GraphEditorWatchTests/AccessibilityTests.swift
 Last modified: 2025-09-22 11:21:14
@@ -872,26 +494,18 @@ class MockGraphStorage: GraphStorage {
 ----------------------------------------------------------------------------------------------------
 File: GraphGesturesModifierTests.swift
 Path: GraphEditorWatchTests/GraphGesturesModifierTests.swift
-Last modified: 2025-10-07 16:10:08
+Last modified: 2025-10-11 19:42:01
 
 Contents:
-//
-//  GraphGesturesModifierTests.swift
-//  GraphEditorWatch
-//
-//  Created by handcart on 9/25/25.
-//
 import Testing
 import SwiftUI
 @testable import GraphEditorWatch
-@testable import GraphEditorShared
+@testable import GraphEditorShared  // Ensure shared module is imported for types if needed
 
 struct GraphGesturesModifierTests {
-    private func setupViewModel() async -> GraphViewModel {
-        let storage = MockGraphStorage()
-        let physicsEngine = PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
-        let model = await MainActor.run { GraphModel(storage: storage, physicsEngine: physicsEngine) }
-        return await MainActor.run { GraphViewModel(model: model) }
+    @MainActor private func setupViewModel() async -> GraphViewModel {
+        let model = GraphModel(storage: MockGraphStorage(), physicsEngine: PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300)))
+        return GraphViewModel(model: model)
     }
     
     private func createModifier(viewModel: GraphViewModel,
@@ -912,37 +526,35 @@ struct GraphGesturesModifierTests {
             maxZoom: 5.0,
             crownPosition: .constant(0.0),
             onUpdateZoomRanges: {},
-            isAddingEdge: .constant(false)
+            isAddingEdge: .constant(false),
+            isDragging: .constant(false)
         )
     }
     
     @MainActor @Test func testHitTestNodesInScreenSpace() async {
         let viewModel = await setupViewModel()
         _ = createModifier(viewModel: viewModel,
-                                      selectedNodeID: .constant(nil),
-                                      selectedEdgeID: .constant(nil))
+                           selectedNodeID: .constant(nil),
+                           selectedEdgeID: .constant(nil))
         
         let nodes = [AnyNode(Node(label: 1, position: CGPoint(x: 100, y: 100)))]
-        let context = GestureContext(zoomScale: 1.0, offset: CGSize.zero, viewSize: CGSize(width: 300, height: 300), effectiveCentroid: CGPoint.zero)
+        let context = GraphEditorShared.HitTestContext(zoomScale: 1.0, offset: CGSize.zero, viewSize: CGSize(width: 300, height: 300), effectiveCentroid: CGPoint.zero)
         // Compute screen pos: viewCenter (150,150) + zoom * (model - centroid) + offset = (150,150) + 1*(100-0,100-0) + (0,0) = (250,250)
         let screenTapPos = CGPoint(x: 250, y: 250)
-        let hitContext = HitTestContext(zoomScale: context.zoomScale, offset: context.offset, viewSize: context.viewSize, effectiveCentroid: context.effectiveCentroid)
-        let hitNode = HitTestHelper.closestNode(at: screenTapPos, visibleNodes: nodes, context: hitContext)
+        let hitContext = GraphEditorShared.HitTestContext(zoomScale: context.zoomScale, offset: context.offset, viewSize: context.viewSize, effectiveCentroid: context.effectiveCentroid)
+        let hitNode = GestureUtils.closestNode(at: screenTapPos, visibleNodes: nodes, context: hitContext)  // Use GestureUtils (assuming it's where closestNode is now)
         #expect(hitNode != nil, "Should hit node within radius")
     }
     
     @Test func testPointToLineDistance() async {
         let viewModel = await setupViewModel()
-        let modifier = createModifier(viewModel: viewModel,
-                                      selectedNodeID: .constant(nil),
-                                      selectedEdgeID: .constant(nil))
         let dist = await MainActor.run {
-            modifier.pointToLineDistance(point: CGPoint(x: 0, y: 1), from: CGPoint.zero, endPoint: CGPoint(x: 2, y: 0))
+            GestureUtils.pointToLineDistance(point: CGPoint(x: 0, y: 1), from: CGPoint.zero, to: CGPoint(x: 2, y: 0))  // Updated to static call on GestureUtils
         }
         #expect(dist == 1.0, "Perpendicular distance to line")
     }
     
-    @Test func testHandleTap() async {
+    @MainActor @Test func testHandleTap() async {
         let viewModel = await setupViewModel()
         var testSelectedNodeID: NodeID?
         var testSelectedEdgeID: UUID?
@@ -971,4 +583,235 @@ struct GraphGesturesModifierTests {
         #expect(testSelectedEdgeID == nil, "No edge selected")
     }
 }
+----------------------------------------------------------------------------------------------------
+File: GraphModelTests.swift
+Path: GraphEditorWatchTests/GraphModelTests.swift
+Last modified: 2025-10-09 08:09:11
+
+Contents:
+//
+//  GraphModelTests.swift
+//  GraphEditor
+//
+//  Created by handcart on 9/22/25.
+//
+
+import Testing
+import Foundation
+import CoreGraphics
+@testable import GraphEditorWatch
+@testable import GraphEditorShared
+import XCTest
+import SwiftUI
+
+struct GraphModelTests {
+    private func mockPhysicsEngine() -> GraphEditorShared.PhysicsEngine {
+        GraphEditorShared.PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
+    }
+    
+    private func setupDefaults(for storage: MockGraphStorage) async throws {
+        let node1 = AnyNode(Node(label: 1, position: CGPoint(x: 100, y: 100)))
+        let node2 = AnyNode(Node(label: 2, position: CGPoint(x: 200, y: 200)))
+        let node3 = AnyNode(Node(label: 3, position: CGPoint(x: 150, y: 150)))
+        let edge1 = GraphEdge(from: node1.id, target: node2.id)
+        let edge2 = GraphEdge(from: node2.id, target: node3.id)
+        let edge3 = GraphEdge(from: node3.id, target: node1.id)
+        try await storage.save(nodes: [node1, node2, node3], edges: [edge1, edge2, edge3])
+    }
+    
+    private func generateNodesAndEdges(seed: Int) async -> ([AnyNode], [GraphEdge]) {
+        struct SeededRandomNumberGenerator: RandomNumberGenerator {
+            private var state: UInt64
+            init(seed: UInt64) {
+                state = seed
+            }
+            mutating func next() -> UInt64 {
+                state &+= 1442695040888963407
+                state &*= 6364136223846793005
+                return state
+            }
+        }
+        var rng = SeededRandomNumberGenerator(seed: UInt64(seed))
+        var nodesToAssign: [AnyNode] = []
+        for _ in 0..<5 {
+            let label = Int.random(in: 0..<10, using: &rng)
+            let positionX = CGFloat.random(in: 0..<300, using: &rng)
+            let positionY = CGFloat.random(in: 0..<300, using: &rng)
+            nodesToAssign.append(AnyNode(Node(label: label, position: CGPoint(x: positionX, y: positionY))))
+        }
+        var edgesToAssign: [GraphEdge] = []
+        for _ in 0..<3 {
+            let fromIndex = Int.random(in: 0..<nodesToAssign.count, using: &rng)
+            let targetIndex = Int.random(in: 0..<nodesToAssign.count, using: &rng)
+            edgesToAssign.append(GraphEdge(from: nodesToAssign[fromIndex].id, target: nodesToAssign[targetIndex].id))
+        }
+        return (nodesToAssign, edgesToAssign)
+    }
+    
+    private func runSimulation(on model: GraphModel) async {
+        let physics = await MainActor.run { model.physicsEngine }
+        physics.resetSimulation()
+        let maxSteps = Constants.Physics.maxSimulationSteps
+        for _ in 0..<maxSteps {
+            let nodes = await model.nodes.map { $0.unwrapped }
+            let edges = await model.edges
+            let (updatedNodes, isActive) = physics.simulationStep(nodes: nodes, edges: edges)
+            await MainActor.run { model.nodes = updatedNodes.map(AnyNode.init) }
+            physics.alpha *= (1 - Constants.Physics.alphaDecay)
+            if !isActive { break }
+        }
+    }
+    
+    @Test(arguments: 1..<5) func testConvergencePropertyBased(seed: Int) async throws {
+        let storage = MockGraphStorage()
+        let model = await MainActor.run { GraphModel(storage: storage, physicsEngine: mockPhysicsEngine()) }
+        await model.load()
+        let (nodesToAssign, edgesToAssign) = await generateNodesAndEdges(seed: seed)
+        await MainActor.run {
+            model.nodes = nodesToAssign
+            model.edges = edgesToAssign
+        }
+        await runSimulation(on: model)
+        let totalVel = (await model.nodes).reduce(0.0) { $0 + hypot($1.velocity.x, $1.velocity.y) }
+        #expect(totalVel < 4.0, "Simulation converged to low velocity for seed \(seed)")
+    }
+    
+    @MainActor @Test func testUndoRedoMixedOperations() async throws {
+        let storage = MockGraphStorage()
+        let model = GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
+        await model.load()
+        await model.addNode(at: CGPoint.zero)
+        await runSimulation(on: model)
+        await model.snapshot()  // Explicit snapshot after initial simulation to capture positions
+        let initialNodes = model.nodes
+        let initialNodeCount = initialNodes.count
+        let initialEdgeCount = model.edges.count
+        let nodeToDelete = initialNodes[0].id
+        let connectedEdges = model.edges.filter { $0.from == nodeToDelete || $0.target == nodeToDelete }.count
+        await model.snapshot()  // Explicit before delete
+        await model.deleteNode(withID: nodeToDelete)
+        await runSimulation(on: model)
+        await model.addNode(at: CGPoint(x: 50, y: 50))
+        await runSimulation(on: model)
+        await model.undo(resume: false)
+        #expect(model.nodes.count == initialNodeCount - 1, "Undo reverts to post-delete")
+        #expect(model.edges.count == initialEdgeCount - connectedEdges, "Edges match post-delete")
+        await model.undo(resume: false)
+        #expect(model.nodes.count == initialNodeCount, "Second undo restores initial")
+        #expect(model.edges.count == initialEdgeCount, "Edges restored")
+        let restoredNodes = model.nodes
+        #expect(zip(restoredNodes.sorted(by: { $0.id.uuidString < $1.id.uuidString }), initialNodes.sorted(by: { $0.id.uuidString < $1.id.uuidString })).allSatisfy { approximatelyEqual($0.position, $1.position, accuracy: 1e-5) && approximatelyEqual($0.velocity, $1.velocity, accuracy: 1e-5) }, "Positions and velocities restored")
+        await model.redo(resume: false)
+        #expect(model.nodes.count == initialNodeCount - 1, "Redo applies delete")
+        await model.redo(resume: false)
+        #expect(model.nodes.count == initialNodeCount, "Redo applies add")
+    }
+    
+    @Test func testInitializationWithDefaults() async throws {
+        let storage = MockGraphStorage()
+        try await setupDefaults(for: storage)
+        let model = await MainActor.run { GraphModel(storage: storage, physicsEngine: mockPhysicsEngine()) }
+        await model.load()
+        #expect(await MainActor.run { model.nodes.count } >= 3, "Should load default or saved nodes")
+        #expect(await MainActor.run { model.edges.count } >= 3, "Should load default edges")
+    }
+    
+    @Test func testDeleteNodeAndEdges() async throws {
+        let storage = MockGraphStorage()
+        try await setupDefaults(for: storage)
+        let model = await MainActor.run { GraphModel(storage: storage, physicsEngine: mockPhysicsEngine()) }
+        await model.load()
+        let nodes = await model.nodes
+        try #require(!nodes.isEmpty, "Assumes default nodes exist")
+        let nodeToDelete = nodes[0].id
+        let initialEdgeCount = await model.edges.count
+        let connectedEdges = (await model.edges).filter { $0.from == nodeToDelete || $0.target == nodeToDelete }.count
+        await model.deleteNode(withID: nodeToDelete)
+        #expect(await MainActor.run { model.nodes.count } == nodes.count - 1, "Node deleted")
+        #expect(await MainActor.run { model.edges.count } == initialEdgeCount - connectedEdges, "Connected edges deleted")
+    }
+    
+    @Test func testSaveLoadRoundTrip() async throws {
+        let storage = MockGraphStorage()
+        try await setupDefaults(for: storage)
+        let model = await MainActor.run { GraphModel(storage: storage, physicsEngine: mockPhysicsEngine()) }
+        await model.load()
+        let originalNodeCount = await MainActor.run { model.nodes.count }
+        let originalEdges = await model.edges
+        await model.addNode(at: CGPoint.zero)
+        await runSimulation(on: model)
+        let postAddNodes = await model.nodes  // Capture after add and simulation
+        await model.snapshot()  // Triggers save() with stabilized positions
+        let newModel = await MainActor.run { GraphModel(storage: storage, physicsEngine: mockPhysicsEngine()) }
+        await newModel.load()
+        // Skip runSimulation(on: newModel) - loaded positions should match saved exactly; re-sim amplifies FP errors
+        #expect(await MainActor.run { newModel.nodes.count } == originalNodeCount + 1, "Loaded nodes include added one")
+        #expect(await newModel.edges == originalEdges, "Edges unchanged")
+        let loadedNodes = (await newModel.nodes).sorted(by: { $0.id.uuidString < $1.id.uuidString })
+        let expectedNodes = postAddNodes.sorted(by: { $0.id.uuidString < $1.id.uuidString })
+        #expect(zip(loadedNodes, expectedNodes).allSatisfy {
+            $0.label == $1.label && approximatelyEqual($0.position, $1.position, accuracy: 1e-2)  // Further relaxed for any JSON/FP rounding
+        }, "Loaded nodes match expected")
+    }
+    
+    @MainActor @Test func testUndoRedoRoundTrip() async {
+        let storage = MockGraphStorage()
+        let physicsEngine = PhysicsEngine(simulationBounds: CGSize(width: 500, height: 500))
+        let model = GraphModel(storage: storage, physicsEngine: physicsEngine)
+        try? await model.loadGraph()  // Explicit load to start empty
+        let initialNode = AnyNode(Node(id: UUID(), label: 1, position: .zero))
+        await model.snapshot()  // Pre-add initial (appends empty)
+        model.nodes = [initialNode]  // "Add" initial
+        let newNode = AnyNode(Node(id: UUID(), label: 2, position: .zero))
+        await model.snapshot()  // Pre-add new (appends [initial])
+        model.nodes.append(newNode)  // Add new
+        await model.undo()  // Back to 1 node
+        #expect(model.nodes.count == 1, "Undo removes node")
+        #expect(model.nodes[0].id == initialNode.id, "Initial state restored")
+        #expect(model.redoStack.count == 1, "Redo stack populated")
+        await model.redo()  // Forward to 2 nodes
+        #expect(model.nodes.count == 2, "Redo adds node")
+        #expect(model.undoStack.count == 2, "Undo stack updated")
+    }
+    
+    internal func approximatelyEqual(_ lhs: CGPoint, _ rhs: CGPoint, accuracy: CGFloat) -> Bool {
+        hypot(lhs.x - rhs.x, lhs.y - rhs.y) < accuracy
+    }
+}
+----------------------------------------------------------------------------------------------------
+File: MenuViewTests.swift
+Path: GraphEditorWatchTests/MenuViewTests.swift
+Last modified: 2025-09-25 14:19:07
+
+Contents:
+//
+//  MenuViewTests.swift
+//  GraphEditor
+//
+//  Created by handcart on 9/25/25.
+//
+import Testing
+import SwiftUI
+@testable import GraphEditorWatch
+@testable import GraphEditorShared
+
+struct MenuViewTests {
+    private func setupViewModel() async -> GraphViewModel {
+        let storage = MockGraphStorage()
+        let physicsEngine = PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
+        let model = await GraphModel(storage: storage, physicsEngine: physicsEngine)
+        return await GraphViewModel(model: model)
+    }
+
+    @Test func testEditSectionDeleteNode() async {
+        let viewModel = await setupViewModel()
+        let node = AnyNode(Node(label: 1, position: .zero))
+        await MainActor.run { viewModel.model.nodes = [node] }
+        _ = EditSection(viewModel: viewModel, selectedNodeID: node.id, selectedEdgeID: nil, onDismiss: {}, onEditNode: {})
+        
+        // Simulate button tap (manual test logic; for full UI test, use XCUITest)
+        await viewModel.deleteNode(withID: node.id)
+        #expect(await viewModel.model.nodes.isEmpty, "Node deleted")
+    }
+}
 --------------------------------------------------
diff --git a/swift_ui_context_parts/part-7.txt b/swift_ui_context_parts/part-7.txt
index fdaef5e..e99d3c6 100644
--- a/swift_ui_context_parts/part-7.txt
+++ b/swift_ui_context_parts/part-7.txt
@@ -1,246 +1,13 @@
 ## Focused Project Concatenation
 This file includes only UI, interactivity, model, and core logic files.
 Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
-Current date: 2025-10-10 13:25:47
+Current date: 2025-10-12 10:03:05
 Table of Contents:
-1. GraphEditorWatchTests/GraphModelTests.swift
-2. GraphEditorWatchTests/MenuViewTests.swift
-3. GraphEditorWatchUITests/GraphEditorWatchUITests.swift
-4. GraphEditorWatchUITests/GraphEditorWatchUITestsLaunchTests.swift--------------------------------------------------
-File: GraphModelTests.swift
-Path: GraphEditorWatchTests/GraphModelTests.swift
-Last modified: 2025-10-09 08:09:11
-
-Contents:
-//
-//  GraphModelTests.swift
-//  GraphEditor
-//
-//  Created by handcart on 9/22/25.
-//
-
-import Testing
-import Foundation
-import CoreGraphics
-@testable import GraphEditorWatch
-@testable import GraphEditorShared
-import XCTest
-import SwiftUI
-
-struct GraphModelTests {
-    private func mockPhysicsEngine() -> GraphEditorShared.PhysicsEngine {
-        GraphEditorShared.PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
-    }
-    
-    private func setupDefaults(for storage: MockGraphStorage) async throws {
-        let node1 = AnyNode(Node(label: 1, position: CGPoint(x: 100, y: 100)))
-        let node2 = AnyNode(Node(label: 2, position: CGPoint(x: 200, y: 200)))
-        let node3 = AnyNode(Node(label: 3, position: CGPoint(x: 150, y: 150)))
-        let edge1 = GraphEdge(from: node1.id, target: node2.id)
-        let edge2 = GraphEdge(from: node2.id, target: node3.id)
-        let edge3 = GraphEdge(from: node3.id, target: node1.id)
-        try await storage.save(nodes: [node1, node2, node3], edges: [edge1, edge2, edge3])
-    }
-    
-    private func generateNodesAndEdges(seed: Int) async -> ([AnyNode], [GraphEdge]) {
-        struct SeededRandomNumberGenerator: RandomNumberGenerator {
-            private var state: UInt64
-            init(seed: UInt64) {
-                state = seed
-            }
-            mutating func next() -> UInt64 {
-                state &+= 1442695040888963407
-                state &*= 6364136223846793005
-                return state
-            }
-        }
-        var rng = SeededRandomNumberGenerator(seed: UInt64(seed))
-        var nodesToAssign: [AnyNode] = []
-        for _ in 0..<5 {
-            let label = Int.random(in: 0..<10, using: &rng)
-            let positionX = CGFloat.random(in: 0..<300, using: &rng)
-            let positionY = CGFloat.random(in: 0..<300, using: &rng)
-            nodesToAssign.append(AnyNode(Node(label: label, position: CGPoint(x: positionX, y: positionY))))
-        }
-        var edgesToAssign: [GraphEdge] = []
-        for _ in 0..<3 {
-            let fromIndex = Int.random(in: 0..<nodesToAssign.count, using: &rng)
-            let targetIndex = Int.random(in: 0..<nodesToAssign.count, using: &rng)
-            edgesToAssign.append(GraphEdge(from: nodesToAssign[fromIndex].id, target: nodesToAssign[targetIndex].id))
-        }
-        return (nodesToAssign, edgesToAssign)
-    }
-    
-    private func runSimulation(on model: GraphModel) async {
-        let physics = await MainActor.run { model.physicsEngine }
-        physics.resetSimulation()
-        let maxSteps = Constants.Physics.maxSimulationSteps
-        for _ in 0..<maxSteps {
-            let nodes = await model.nodes.map { $0.unwrapped }
-            let edges = await model.edges
-            let (updatedNodes, isActive) = physics.simulationStep(nodes: nodes, edges: edges)
-            await MainActor.run { model.nodes = updatedNodes.map(AnyNode.init) }
-            physics.alpha *= (1 - Constants.Physics.alphaDecay)
-            if !isActive { break }
-        }
-    }
-    
-    @Test(arguments: 1..<5) func testConvergencePropertyBased(seed: Int) async throws {
-        let storage = MockGraphStorage()
-        let model = await MainActor.run { GraphModel(storage: storage, physicsEngine: mockPhysicsEngine()) }
-        await model.load()
-        let (nodesToAssign, edgesToAssign) = await generateNodesAndEdges(seed: seed)
-        await MainActor.run {
-            model.nodes = nodesToAssign
-            model.edges = edgesToAssign
-        }
-        await runSimulation(on: model)
-        let totalVel = (await model.nodes).reduce(0.0) { $0 + hypot($1.velocity.x, $1.velocity.y) }
-        #expect(totalVel < 4.0, "Simulation converged to low velocity for seed \(seed)")
-    }
-    
-    @MainActor @Test func testUndoRedoMixedOperations() async throws {
-        let storage = MockGraphStorage()
-        let model = GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
-        await model.load()
-        await model.addNode(at: CGPoint.zero)
-        await runSimulation(on: model)
-        await model.snapshot()  // Explicit snapshot after initial simulation to capture positions
-        let initialNodes = model.nodes
-        let initialNodeCount = initialNodes.count
-        let initialEdgeCount = model.edges.count
-        let nodeToDelete = initialNodes[0].id
-        let connectedEdges = model.edges.filter { $0.from == nodeToDelete || $0.target == nodeToDelete }.count
-        await model.snapshot()  // Explicit before delete
-        await model.deleteNode(withID: nodeToDelete)
-        await runSimulation(on: model)
-        await model.addNode(at: CGPoint(x: 50, y: 50))
-        await runSimulation(on: model)
-        await model.undo(resume: false)
-        #expect(model.nodes.count == initialNodeCount - 1, "Undo reverts to post-delete")
-        #expect(model.edges.count == initialEdgeCount - connectedEdges, "Edges match post-delete")
-        await model.undo(resume: false)
-        #expect(model.nodes.count == initialNodeCount, "Second undo restores initial")
-        #expect(model.edges.count == initialEdgeCount, "Edges restored")
-        let restoredNodes = model.nodes
-        #expect(zip(restoredNodes.sorted(by: { $0.id.uuidString < $1.id.uuidString }), initialNodes.sorted(by: { $0.id.uuidString < $1.id.uuidString })).allSatisfy { approximatelyEqual($0.position, $1.position, accuracy: 1e-5) && approximatelyEqual($0.velocity, $1.velocity, accuracy: 1e-5) }, "Positions and velocities restored")
-        await model.redo(resume: false)
-        #expect(model.nodes.count == initialNodeCount - 1, "Redo applies delete")
-        await model.redo(resume: false)
-        #expect(model.nodes.count == initialNodeCount, "Redo applies add")
-    }
-    
-    @Test func testInitializationWithDefaults() async throws {
-        let storage = MockGraphStorage()
-        try await setupDefaults(for: storage)
-        let model = await MainActor.run { GraphModel(storage: storage, physicsEngine: mockPhysicsEngine()) }
-        await model.load()
-        #expect(await MainActor.run { model.nodes.count } >= 3, "Should load default or saved nodes")
-        #expect(await MainActor.run { model.edges.count } >= 3, "Should load default edges")
-    }
-    
-    @Test func testDeleteNodeAndEdges() async throws {
-        let storage = MockGraphStorage()
-        try await setupDefaults(for: storage)
-        let model = await MainActor.run { GraphModel(storage: storage, physicsEngine: mockPhysicsEngine()) }
-        await model.load()
-        let nodes = await model.nodes
-        try #require(!nodes.isEmpty, "Assumes default nodes exist")
-        let nodeToDelete = nodes[0].id
-        let initialEdgeCount = await model.edges.count
-        let connectedEdges = (await model.edges).filter { $0.from == nodeToDelete || $0.target == nodeToDelete }.count
-        await model.deleteNode(withID: nodeToDelete)
-        #expect(await MainActor.run { model.nodes.count } == nodes.count - 1, "Node deleted")
-        #expect(await MainActor.run { model.edges.count } == initialEdgeCount - connectedEdges, "Connected edges deleted")
-    }
-    
-    @Test func testSaveLoadRoundTrip() async throws {
-        let storage = MockGraphStorage()
-        try await setupDefaults(for: storage)
-        let model = await MainActor.run { GraphModel(storage: storage, physicsEngine: mockPhysicsEngine()) }
-        await model.load()
-        let originalNodeCount = await MainActor.run { model.nodes.count }
-        let originalEdges = await model.edges
-        await model.addNode(at: CGPoint.zero)
-        await runSimulation(on: model)
-        let postAddNodes = await model.nodes  // Capture after add and simulation
-        await model.snapshot()  // Triggers save() with stabilized positions
-        let newModel = await MainActor.run { GraphModel(storage: storage, physicsEngine: mockPhysicsEngine()) }
-        await newModel.load()
-        // Skip runSimulation(on: newModel) - loaded positions should match saved exactly; re-sim amplifies FP errors
-        #expect(await MainActor.run { newModel.nodes.count } == originalNodeCount + 1, "Loaded nodes include added one")
-        #expect(await newModel.edges == originalEdges, "Edges unchanged")
-        let loadedNodes = (await newModel.nodes).sorted(by: { $0.id.uuidString < $1.id.uuidString })
-        let expectedNodes = postAddNodes.sorted(by: { $0.id.uuidString < $1.id.uuidString })
-        #expect(zip(loadedNodes, expectedNodes).allSatisfy {
-            $0.label == $1.label && approximatelyEqual($0.position, $1.position, accuracy: 1e-2)  // Further relaxed for any JSON/FP rounding
-        }, "Loaded nodes match expected")
-    }
-    
-    @MainActor @Test func testUndoRedoRoundTrip() async {
-        let storage = MockGraphStorage()
-        let physicsEngine = PhysicsEngine(simulationBounds: CGSize(width: 500, height: 500))
-        let model = GraphModel(storage: storage, physicsEngine: physicsEngine)
-        try? await model.loadGraph()  // Explicit load to start empty
-        let initialNode = AnyNode(Node(id: UUID(), label: 1, position: .zero))
-        await model.snapshot()  // Pre-add initial (appends empty)
-        model.nodes = [initialNode]  // "Add" initial
-        let newNode = AnyNode(Node(id: UUID(), label: 2, position: .zero))
-        await model.snapshot()  // Pre-add new (appends [initial])
-        model.nodes.append(newNode)  // Add new
-        await model.undo()  // Back to 1 node
-        #expect(model.nodes.count == 1, "Undo removes node")
-        #expect(model.nodes[0].id == initialNode.id, "Initial state restored")
-        #expect(model.redoStack.count == 1, "Redo stack populated")
-        await model.redo()  // Forward to 2 nodes
-        #expect(model.nodes.count == 2, "Redo adds node")
-        #expect(model.undoStack.count == 2, "Undo stack updated")
-    }
-    
-    internal func approximatelyEqual(_ lhs: CGPoint, _ rhs: CGPoint, accuracy: CGFloat) -> Bool {
-        hypot(lhs.x - rhs.x, lhs.y - rhs.y) < accuracy
-    }
-}
-----------------------------------------------------------------------------------------------------
-File: MenuViewTests.swift
-Path: GraphEditorWatchTests/MenuViewTests.swift
-Last modified: 2025-09-25 14:19:07
-
-Contents:
-//
-//  MenuViewTests.swift
-//  GraphEditor
-//
-//  Created by handcart on 9/25/25.
-//
-import Testing
-import SwiftUI
-@testable import GraphEditorWatch
-@testable import GraphEditorShared
-
-struct MenuViewTests {
-    private func setupViewModel() async -> GraphViewModel {
-        let storage = MockGraphStorage()
-        let physicsEngine = PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
-        let model = await GraphModel(storage: storage, physicsEngine: physicsEngine)
-        return await GraphViewModel(model: model)
-    }
-
-    @Test func testEditSectionDeleteNode() async {
-        let viewModel = await setupViewModel()
-        let node = AnyNode(Node(label: 1, position: .zero))
-        await MainActor.run { viewModel.model.nodes = [node] }
-        _ = EditSection(viewModel: viewModel, selectedNodeID: node.id, selectedEdgeID: nil, onDismiss: {}, onEditNode: {})
-        
-        // Simulate button tap (manual test logic; for full UI test, use XCUITest)
-        await viewModel.deleteNode(withID: node.id)
-        #expect(await viewModel.model.nodes.isEmpty, "Node deleted")
-    }
-}
-----------------------------------------------------------------------------------------------------
+1. GraphEditorWatchUITests/GraphEditorWatchUITests.swift
+2. GraphEditorWatchUITests/GraphEditorWatchUITestsLaunchTests.swift--------------------------------------------------
 File: GraphEditorWatchUITests.swift
 Path: GraphEditorWatchUITests/GraphEditorWatchUITests.swift
-Last modified: 2025-10-10 13:17:22
+Last modified: 2025-10-10 14:04:57
 
 Contents:
 //
@@ -253,7 +20,6 @@ Contents:
 import XCTest
 
 extension XCUIApplication {
-    //@discardableResult
     func waitForElement(_ element: XCUIElement, timeout: TimeInterval = 5.0, file: StaticString = #file, line: UInt = #line) {
         XCTAssertTrue(element.waitForExistence(timeout: timeout), "Element did not appear: \(element)", file: file, line: line)
     }
