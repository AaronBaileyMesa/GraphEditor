## Focused Project Concatenation
This file includes only UI, interactivity, model, and core logic files.
Excluded: Tests/*, UITests/*, Package.swift, AppDelegate.swift, and other non-UI items.
Current date: 2025-08-21 11:51:10

Table of Contents:
1. GraphEditorShared/Sources/GraphEditorShared/AttractionCalculator.swift
2. GraphEditorShared/Sources/GraphEditorShared/CenteringCalculator.swift
3. GraphEditorShared/Sources/GraphEditorShared/Constants.swift
4. GraphEditorShared/Sources/GraphEditorShared/GraphModel.swift
5. GraphEditorShared/Sources/GraphEditorShared/GraphSimulator.swift
6. GraphEditorShared/Sources/GraphEditorShared/GraphTypes.swift
7. GraphEditorShared/Sources/GraphEditorShared/NodeProtocol.swift
8. GraphEditorShared/Sources/GraphEditorShared/PersistenceManager.swift
9. GraphEditorShared/Sources/GraphEditorShared/PhysicsEngine.swift
10. GraphEditorShared/Sources/GraphEditorShared/PositionUpdater.swift
11. GraphEditorShared/Sources/GraphEditorShared/Protocols.swift
12. GraphEditorShared/Sources/GraphEditorShared/Quadtree.swift
13. GraphEditorShared/Sources/GraphEditorShared/RepulsionCalculator.swift
14. GraphEditorShared/Sources/GraphEditorShared/ToggleNode.swift
15. GraphEditorShared/Sources/GraphEditorShared/Utilities.swift
16. GraphEditorWatch/GraphEditorWatch.swift
17. GraphEditorWatch/Models/AppConstants.swift
18. GraphEditorWatch/ViewModels/GraphViewModel.swift
19. GraphEditorWatch/Views/ContentView.swift
20. GraphEditorWatch/Views/GraphCanvasView.swift
21. GraphEditorWatch/Views/GraphGesturesModifier.swift
22. GraphEditorWatch/Views/MenuView.swift
23. GraphEditorWatch/Views/NodeView.swift
24. GraphEditorWatchTests/GraphEditorWatchTests.swift
25. GraphEditorWatchUITests/GraphEditorWatchUITests.swift
26. GraphEditorWatchUITests/GraphEditorWatchUITestsLaunchTests.swift

--------------------------------------------------
File: AttractionCalculator.swift
Path: GraphEditorShared/Sources/GraphEditorShared/AttractionCalculator.swift
Last modified: 2025-08-12 09:46:40

Contents:
//
//  AttractionCalculator.swift
//  GraphEditorShared
//
//  Created by handcart on 8/12/25.
//

import Foundation
import CoreGraphics

struct AttractionCalculator {
    let useAsymmetricAttraction: Bool
    let symmetricFactor: CGFloat

    init(useAsymmetricAttraction: Bool, symmetricFactor: CGFloat) {
        self.useAsymmetricAttraction = useAsymmetricAttraction
        self.symmetricFactor = symmetricFactor
    }

    func applyAttractions(forces: [NodeID: CGPoint], edges: [GraphEdge], nodes: [any NodeProtocol]) -> [NodeID: CGPoint] {
        var updatedForces = forces
        for edge in edges {
            guard let fromNode = nodes.first(where: { $0.id == edge.from }),
                  let toNode = nodes.first(where: { $0.id == edge.to }) else { continue }
            let deltaX = toNode.position.x - fromNode.position.x
            let deltaY = toNode.position.y - fromNode.position.y
            let dist = max(hypot(deltaX, deltaY), Constants.Physics.distanceEpsilon)
            let forceMagnitude = Constants.Physics.stiffness * (dist - Constants.Physics.idealLength)
            let forceDirectionX = deltaX / dist
            let forceDirectionY = deltaY / dist
            let forceX = forceDirectionX * forceMagnitude
            let forceY = forceDirectionY * forceMagnitude
            
            let symForceX = forceX * self.symmetricFactor
            let symForceY = forceY * self.symmetricFactor
            
            let currentForceFrom = updatedForces[fromNode.id] ?? .zero
            updatedForces[fromNode.id] = CGPoint(x: currentForceFrom.x + symForceX, y: currentForceFrom.y + symForceY)
            
            let currentForceTo = updatedForces[toNode.id] ?? .zero
            if useAsymmetricAttraction {
                updatedForces[toNode.id] = CGPoint(x: currentForceTo.x - forceX * (1 + self.symmetricFactor), y: currentForceTo.y - forceY * (1 + self.symmetricFactor))
            } else {
                updatedForces[toNode.id] = CGPoint(x: currentForceTo.x - forceX + symForceX, y: currentForceTo.y - forceY + symForceY)
            }
        }
        return updatedForces
    }

    private func springForce(from: CGPoint, to: CGPoint, idealLength: CGFloat) -> CGPoint {
        let dx = to.x - from.x
        let dy = to.y - from.y
        let distance = max(hypot(dx, dy), Constants.Physics.distanceEpsilon)
        let forceMagnitude = Constants.Physics.stiffness * (distance - idealLength)
        return CGPoint(x: (dx / distance) * forceMagnitude, y: (dy / distance) * forceMagnitude)
    }
}
--------------------------------------------------
--------------------------------------------------
File: CenteringCalculator.swift
Path: GraphEditorShared/Sources/GraphEditorShared/CenteringCalculator.swift
Last modified: 2025-08-12 09:46:40

Contents:
//
//  CenteringCalculator.swift
//  GraphEditorShared
//
//  Created by handcart on 8/12/25.
//

import Foundation
import CoreGraphics

struct CenteringCalculator {
    let simulationBounds: CGSize

    init(simulationBounds: CGSize) {
        self.simulationBounds = simulationBounds
    }

    func applyCentering(forces: [NodeID: CGPoint], nodes: [any NodeProtocol]) -> [NodeID: CGPoint] {
        var updatedForces = forces
        let center = CGPoint(x: simulationBounds.width / 2, y: simulationBounds.height / 2)
        for node in nodes {
            let deltaX = center.x - node.position.x
            let deltaY = center.y - node.position.y
            let distToCenter = hypot(deltaX, deltaY)
            let forceX = deltaX * Constants.Physics.centeringForce * (1 + distToCenter / max(simulationBounds.width, simulationBounds.height))
            let forceY = deltaY * Constants.Physics.centeringForce * (1 + distToCenter / max(simulationBounds.width, simulationBounds.height))
            let currentForce = updatedForces[node.id] ?? .zero
            updatedForces[node.id] = CGPoint(x: currentForce.x + forceX, y: currentForce.y + forceY)
        }
        return updatedForces
    }
}
--------------------------------------------------
--------------------------------------------------
File: Constants.swift
Path: GraphEditorShared/Sources/GraphEditorShared/Constants.swift
Last modified: 2025-08-18 10:51:53

Contents:
//
//  Constants.swift
//  GraphEditorShared
//
//  Created by handcart on 8/6/25.
//


// Sources/GraphEditorShared/Constants.swift

import CoreGraphics

public enum Constants {
    public enum Physics {
        public static let stiffness: CGFloat = 0.4  // Reduced from 0.8 for softer springs
        public static let repulsion: CGFloat = 1200  // Reduced from 2200 for less aggressive push
        public static let damping: CGFloat = 0.85  // Reduced from 0.99 for faster settling
        public static let idealLength: CGFloat = 80  // Slightly increased for more space
        public static let centeringForce: CGFloat = 0.03  // Reduced from 0.06 to avoid over-pull
        public static let distanceEpsilon: CGFloat = 1e-3
        public static let timeStep: CGFloat = 0.02  // Slightly reduced for finer steps
        public static let velocityThreshold: CGFloat = 0.5  // Increased from 0.2 for earlier stop
        public static let maxSimulationSteps = 500  // Further reduced from 1000 for quick convergence
        public static let minQuadSize: CGFloat = 1e-6
        public static let maxQuadtreeDepth = 20
        public static let maxNodesForQuadtree = 200
        public static let minCollisionDist: CGFloat = 35.0  // New: For anti-collision separation
    }
    
    public enum App {
        public static let nodeModelRadius: CGFloat = 10.0
        public static let hitScreenRadius: CGFloat = 40.0  // Larger for watchOS tap targets
        public static let tapThreshold: CGFloat = 10.0  // Pixels for tap vs. drag distinction
        public static let numZoomLevels: Int = 20  // For crown mapping
    }
    
    // Add more enums as needed (e.g., UI, Testing)
}
--------------------------------------------------
--------------------------------------------------
File: GraphModel.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphModel.swift
Last modified: 2025-08-19 11:24:26

Contents:
// Sources/GraphEditorShared/GraphModel.swift

import os.log
import SwiftUI
import Combine
import Foundation

#if os(watchOS)
import WatchKit
#endif

private let logger = OSLog(subsystem: "io.handcart.GraphEditor", category: "storage")

@available(iOS 13.0, watchOS 6.0, *)
public class GraphModel: ObservableObject {
    @Published public var nodes: [any NodeProtocol] = []
    @Published public var edges: [GraphEdge] = []

    @Published public var isSimulating: Bool = false
    private var simulationTimer: Timer? = nil
    
    private var undoStack: [GraphState] = []
    private var redoStack: [GraphState] = []
    private let maxUndo = 10
    public var nextNodeLabel = 1  // Internal for testability; auto-increments node labels
    
    private let storage: GraphStorage
    public let physicsEngine: PhysicsEngine  // Changed to public
    
    private lazy var simulator: GraphSimulator = {
        GraphSimulator(
            getNodes: { [weak self] in self?.nodes ?? [] },
            setNodes: { [weak self] nodes in self?.nodes = nodes },
            getEdges: { [weak self] in self?.edges ?? [] },
            
            getVisibleNodes: { [weak self] in self?.visibleNodes() ?? [] },
            getVisibleEdges: { [weak self] in self?.visibleEdges() ?? [] },
            
            physicsEngine: self.physicsEngine,
            onStable: { [weak self] in
                guard let self = self else { return }
                var centeredNodes = self.physicsEngine.centerNodes(nodes: self.nodes)
                // New: Reset velocities to prevent re-triggering simulation
                centeredNodes = centeredNodes.map { node in
                    node.with(position: node.position, velocity: .zero)
                }
                self.nodes = centeredNodes
                self.objectWillChange.send()
            }
        )
    }()
    
    // Indicates if undo is possible.
    public var canUndo: Bool {
        !undoStack.isEmpty
    }
    
    // Indicates if redo is possible.
    public var canRedo: Bool {
        !redoStack.isEmpty
    }
    
    // Single initializer with optional nextNodeLabel for testing.
    public init(storage: GraphStorage = PersistenceManager(), physicsEngine: PhysicsEngine, nextNodeLabel: Int? = nil) {
        self.storage = storage
        self.physicsEngine = physicsEngine
        
        var tempNodes: [any NodeProtocol] = []
        var tempEdges: [GraphEdge] = []
        var tempNextLabel = nextNodeLabel ?? 1
        
        do {
            let loaded = try storage.load()
            tempNodes = loaded.nodes
            tempEdges = loaded.edges
            tempNextLabel = (tempNodes.map { $0.label }.max() ?? 0) + 1
        } catch {
            os_log("Load failed: %{public}s", log: logger, type: .error, error.localizedDescription)
            // Proceed with defaults below
        }
        
        if tempNodes.isEmpty && tempEdges.isEmpty {
            (tempNodes, tempEdges, tempNextLabel) = Self.createDefaultGraph(startingLabel: tempNextLabel)
            do {
                try storage.save(nodes: tempNodes, edges: tempEdges)
            } catch {
                os_log("Save defaults failed: %{public}s", log: logger, type: .error, error.localizedDescription)
            }
        }
        
        self.nodes = tempNodes
        self.edges = tempEdges
        self.nextNodeLabel = tempNextLabel  // Always set (computed above)
    }
    
    public func clearGraph() {
        snapshot()
        nodes = []
        edges = []
        nextNodeLabel = 1  // Explicit reset
        physicsEngine.resetSimulation()
        startSimulation()
        try? storage.clear()
    }
    
    // Static factory for default graph creation.
    private static func createDefaultGraph(startingLabel: Int) -> ([any NodeProtocol], [GraphEdge], Int) {
        let defaultNodes: [Node] = [
            Node(label: startingLabel, position: CGPoint(x: 100, y: 100)),
            Node(label: startingLabel + 1, position: CGPoint(x: 200, y: 200)),
            Node(label: startingLabel + 2, position: CGPoint(x: 150, y: 300))
        ]
        let defaultEdges: [GraphEdge] = [
            GraphEdge(from: defaultNodes[0].id, to: defaultNodes[1].id),
            GraphEdge(from: defaultNodes[1].id, to: defaultNodes[2].id),
            GraphEdge(from: defaultNodes[2].id, to: defaultNodes[0].id)
        ]
        return (defaultNodes, defaultEdges, startingLabel + 3)
    }
    
    // Creates a snapshot of the current state for undo/redo and saves.
    public func snapshot() {
        let state = GraphState(nodes: nodes, edges: edges)
        undoStack.append(state)
        if undoStack.count > maxUndo {
            undoStack.removeFirst()
        }
        redoStack.removeAll()
        do {
            try storage.save(nodes: nodes, edges: edges)
        } catch {
            os_log("Failed to save snapshot: %{public}s", log: logger, type: .error, error.localizedDescription)
        }
    }
    
    // Undoes the last action if possible, with haptic feedback.
    public func undo() {
        guard !undoStack.isEmpty else {
#if os(watchOS)
            WKInterfaceDevice.current().play(.failure)
#endif
            return
        }
        let current = GraphState(nodes: nodes, edges: edges)
        redoStack.append(current)
        let previous = undoStack.removeLast()
        nodes = previous.nodes
        edges = previous.edges
        self.physicsEngine.resetSimulation()  // Ready for new simulation
#if os(watchOS)
        WKInterfaceDevice.current().play(.click)
#endif
        do {
            try storage.save(nodes: nodes, edges: edges)
        } catch {
            os_log("Failed to save after undo: %{public}s", log: logger, type: .error, error.localizedDescription)
        }
    }
    
    public func redo() {
        guard !redoStack.isEmpty else {
#if os(watchOS)
            WKInterfaceDevice.current().play(.failure)
#endif
            return
        }
        let current = GraphState(nodes: nodes, edges: edges)
        undoStack.append(current)
        let next = redoStack.removeLast()
        nodes = next.nodes
        edges = next.edges
        self.physicsEngine.resetSimulation()  // Ready for new simulation
#if os(watchOS)
        WKInterfaceDevice.current().play(.click)
#endif
        do {
            try storage.save(nodes: nodes, edges: edges)
        } catch {
            os_log("Failed to save after redo: %{public}s", log: logger, type: .error, error.localizedDescription)
        }
    }
    
    public func saveGraph() {
        do {
            try storage.save(nodes: nodes, edges: edges)
        } catch {
            os_log("Failed to save graph: %{public}s", log: logger, type: .error, error.localizedDescription)
        }
    }
    
    public func deleteNode(withID id: NodeID) {
        snapshot()
        nodes.removeAll { $0.id == id }
        edges.removeAll { $0.from == id || $0.to == id }
        self.physicsEngine.resetSimulation()
    }
    
    public func deleteSelectedEdge(id: UUID?) {
        guard let id = id else { return }
        snapshot()
        edges.removeAll { $0.id == id }
        self.physicsEngine.resetSimulation()
        startSimulation()
    }
    
    public func addNode(at position: CGPoint) {
        if nodes.count >= 100 {
            return
        }
        let newNode = Node(label: nextNodeLabel, position: position, radius: 10.0)
        nodes.append(newNode)
        nextNodeLabel += 1
        let centeredNodes = physicsEngine.centerNodes(nodes: nodes)
        nodes = centeredNodes
        self.physicsEngine.resetSimulation()
    }
    
    public func updateNode(_ updatedNode: any NodeProtocol) {
        if let index = nodes.firstIndex(where: { $0.id == updatedNode.id }) {
            nodes[index] = updatedNode
            objectWillChange.send()  // Ensure views refresh
            startSimulation()  // Optional: Restart sim if toggle affects layout
        }
    }
    

    
    public func startSimulation() {
#if os(watchOS)
        guard WKApplication.shared().applicationState == .active else {
            return  // Don't simulate if backgrounded
        }
#endif
        simulator.startSimulation { [weak self] in
            self?.objectWillChange.send()
        }
    }
    
    public func stopSimulation() {
        simulator.stopSimulation()
    }
    
    public func pauseSimulation() {
        stopSimulation()
        physicsEngine.isPaused = true  // Assumes isPaused var in PhysicsEngine
    }
    
    public func resumeSimulation() {
        physicsEngine.isPaused = false
        startSimulation()
    }
    
    
    public func boundingBox() -> CGRect {
        self.physicsEngine.boundingBox(nodes: nodes)
    }
    

    private func buildRoots() -> [any NodeProtocol] {
        var incoming = Set<NodeID>()
        for edge in edges {
            incoming.insert(edge.to)
        }
        return nodes.filter { !incoming.contains($0.id) }
    }
    // Visibility methods
    public func visibleNodes() -> [any NodeProtocol] {
        var visible: [any NodeProtocol] = []
        var visited = Set<NodeID>()
        let adjacency = buildAdjacencyList()
        let roots = buildRoots()
        for root in roots {
            if !visited.contains(root.id) {
                dfsVisible(node: root, adjacency: adjacency, visited: &visited, visible: &visible)
            }
        }
        return visible
    }
    
    private func dfsVisible(node: any NodeProtocol, adjacency: [NodeID: [NodeID]], visited: inout Set<NodeID>, visible: inout [any NodeProtocol]) {
        visited.insert(node.id)
        visible.append(node)  // Always append (even if collapsed)
        if !node.isExpanded { return }
        if let children = adjacency[node.id] {
            for childID in children {
                if !visited.contains(childID), let child = nodes.first(where: { $0.id == childID }) {
                    dfsVisible(node: child, adjacency: adjacency, visited: &visited, visible: &visible)
                }
            }
        }
    }
    
    public func visibleEdges() -> [GraphEdge] {
        let visibleIDs = Set(visibleNodes().map { $0.id })
        return edges.filter { visibleIDs.contains($0.from) && visibleIDs.contains($0.to) }
    }
    
    public func isBidirectionalBetween(_ id1: NodeID, _ id2: NodeID) -> Bool {
        edges.contains { $0.from == id1 && $0.to == id2 } &&
        edges.contains { $0.from == id2 && $0.to == id1 }
    }
    
    public func edgesBetween(_ id1: NodeID, _ id2: NodeID) -> [GraphEdge] {
        edges.filter { ($0.from == id1 && $0.to == id2) || ($0.from == id2 && $0.to == id1) }
    }
    
    private func buildAdjacencyList() -> [NodeID: [NodeID]] {
        var adj = [NodeID: [NodeID]]()
        for edge in edges {
            adj[edge.from, default: []].append(edge.to)
        }
        return adj
    }
    
    public func addToggleNode(at position: CGPoint) {
        nodes.append(ToggleNode(label: nextNodeLabel, position: position))
        nextNodeLabel += 1
        if nodes.count >= 100 { return }
        physicsEngine.resetSimulation()
    }
    
    // In GraphModel.swift, replace the existing addChild with this:
    public func addChild(to parentID: NodeID, at position: CGPoint? = nil, isToggle: Bool = false) {
        guard let parent = nodes.first(where: { $0.id == parentID }) else { return }
        let childPosition = position ?? CGPoint(x: parent.position.x + 50, y: parent.position.y + 50)
        let childLabel = nextNodeLabel
        nextNodeLabel += 1
        
        let child: any NodeProtocol = isToggle ?
        ToggleNode(label: childLabel, position: childPosition) :
        Node(label: childLabel, position: childPosition)
        
        nodes.append(child)
        let newEdge = GraphEdge(from: parentID, to: child.id)
        
        // Check for cycles before adding edge
        if hasCycle(adding: newEdge) {
            // Optionally: Log or alert user
            print("Cycle detected; edge not added.")
            return
        }
        
        edges.append(newEdge)
        physicsEngine.resetSimulation()
        startSimulation()
    }
    
    // Add this new helper function at the bottom of GraphModel (e.g., after resumeSimulation):
    public func hasCycle(adding edge: GraphEdge) -> Bool {
        var adj = buildAdjacencyList()
        adj[edge.from, default: []].append(edge.to)
        
        // DFS cycle detection from new edge's from-node
        var visited = Set<NodeID>()
        var recStack = Set<NodeID>()
        
        func dfs(_ node: NodeID) -> Bool {
            visited.insert(node)
            recStack.insert(node)
            if let neighbors = adj[node] {
                for neighbor in neighbors {
                    if !visited.contains(neighbor) {
                        if dfs(neighbor) { return true }
                    } else if recStack.contains(neighbor) {
                        return true
                    }
                }
            }
            recStack.remove(node)
            return false
        }
        
        return dfs(edge.from)
    }
    // Added: Public method to load graph from storage (avoids direct private access)
        public func loadFromStorage() throws {
            let loaded = try storage.load()
            nodes = loaded.nodes
            edges = loaded.edges
            nextNodeLabel = (nodes.map { $0.label }.max() ?? 0) + 1
            objectWillChange.send()
        }
        
        // Added: Public wrappers for view state (delegate to storage)
        public func saveViewState(offset: CGPoint, zoomScale: CGFloat, selectedNodeID: UUID?, selectedEdgeID: UUID?) throws {
            try storage.saveViewState(offset: offset, zoomScale: zoomScale, selectedNodeID: selectedNodeID, selectedEdgeID: selectedEdgeID)
        }
        
        public func loadViewState() throws -> (offset: CGPoint, zoomScale: CGFloat, selectedNodeID: UUID?, selectedEdgeID: UUID?)? {
            try storage.loadViewState()
        }
    }

    @available(iOS 13.0, watchOS 6.0, *)
    extension GraphModel {
        
        public func graphDescription(selectedID: NodeID?, selectedEdgeID: UUID?) -> String {
        let edgeCount = edges.count
        let edgeWord = edgeCount == 1 ? "edge" : "edges"  // New: Handle plural
        var desc = "Graph with \(nodes.count) nodes and \(edgeCount) directed \(edgeWord)."
        if let selectedEdgeID = selectedEdgeID, let selectedEdge = edges.first(where: { $0.id == selectedEdgeID }),
           let fromNode = nodes.first(where: { $0.id == selectedEdge.from }),
           let toNode = nodes.first(where: { $0.id == selectedEdge.to }) {
            desc += " Directed edge from node \(fromNode.label) to node \(toNode.label) selected."
        } else if let selectedID = selectedID, let selectedNode = nodes.first(where: { $0.id == selectedID }) {
            let outgoingLabels = edges
                .filter { $0.from == selectedID }
                .compactMap { edge in
                    let toID = edge.to
                    return nodes.first { $0.id == toID }?.label
                }
                .sorted()
                .map { String($0) }
                .joined(separator: ", ")
            let incomingLabels = edges
                .filter { $0.to == selectedID }
                .compactMap { edge in
                    let fromID = edge.from
                    return nodes.first { $0.id == fromID }?.label
                }
                .sorted()
                .map { String($0) }
                .joined(separator: ", ")
            let outgoingText = outgoingLabels.isEmpty ? "none" : outgoingLabels
            let incomingText = incomingLabels.isEmpty ? "none" : incomingLabels
            desc += " Node \(selectedNode.label) selected, outgoing to: \(outgoingText); incoming from: \(incomingText)."
        } else {
            desc += " No node or edge selected."
        }
        return desc
    }
    
}
--------------------------------------------------
--------------------------------------------------
File: GraphSimulator.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphSimulator.swift
Last modified: 2025-08-18 11:13:36

Contents:
// Sources/GraphEditorShared/GraphSimulator.swift

import Foundation
import os.log  // For logging if needed

#if os(watchOS)
import WatchKit  // Only if using haptics; otherwise remove
#endif

@available(iOS 13.0, watchOS 6.0, *)
/// Manages physics simulation loops for graph updates.
class GraphSimulator {
    private var timer: Timer? = nil  // Ensure this declaration is here
    private var recentVelocities: [CGFloat] = []
    private let velocityChangeThreshold: CGFloat = 0.01
    private let velocityHistoryCount = 5
    
    let physicsEngine: PhysicsEngine
    private let getVisibleNodes: () -> [any NodeProtocol]
    private let getVisibleEdges: () -> [GraphEdge]
    
    private let getNodes: () -> [any NodeProtocol]  // Updated: Polymorphic
    private let setNodes: ([any NodeProtocol]) -> Void  // Updated: Polymorphic
    private let getEdges: () -> [GraphEdge]
    private let onStable: (() -> Void)?  // New: Optional callback
    
    init(getNodes: @escaping () -> [any NodeProtocol],
         setNodes: @escaping ([any NodeProtocol]) -> Void,
         getEdges: @escaping () -> [GraphEdge],
         getVisibleNodes: @escaping () -> [any NodeProtocol],
         getVisibleEdges: @escaping () -> [GraphEdge],
         physicsEngine: PhysicsEngine,
         onStable: (() -> Void)? = nil) {  // New parameter
        self.getNodes = getNodes
        self.setNodes = setNodes
        self.getEdges = getEdges
        self.physicsEngine = physicsEngine
        self.onStable = onStable
        
        self.getVisibleNodes = getVisibleNodes
        self.getVisibleEdges = getVisibleEdges
    }
    
    func startSimulation(onUpdate: @escaping () -> Void) {
        #if os(watchOS)
        guard WKApplication.shared().applicationState == .active else {
            return  // Don't simulate if backgrounded
        }
        #endif
        timer?.invalidate()
        physicsEngine.resetSimulation()
        recentVelocities.removeAll()
        
        let nodeCount = getNodes().count
        if nodeCount < 5 { return }
        
        // Dynamic interval: Slower for larger graphs; further slow in low power mode
        var baseInterval: TimeInterval = nodeCount < 20 ? 1.0 / 30.0 : (nodeCount < 50 ? 1.0 / 15.0 : 1.0 / 10.0)
        if ProcessInfo.processInfo.isLowPowerModeEnabled {
            baseInterval *= 2.0  // Double interval to save battery
        }
        
        timer = Timer.scheduledTimer(withTimeInterval: baseInterval, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            
            DispatchQueue.global(qos: .userInitiated).async {
                let nodes = self.getNodes()
                let visibleNodes = self.getVisibleNodes()
                let visibleEdges = self.getVisibleEdges()
                let (forces, quadtree) = self.physicsEngine.repulsionCalculator.computeRepulsions(nodes: visibleNodes)  // Updated: Unpack tuple

                var updatedForces = forces  // Temp var
                updatedForces = self.physicsEngine.attractionCalculator.applyAttractions(forces: updatedForces, edges: visibleEdges, nodes: visibleNodes)
                updatedForces = self.physicsEngine.centeringCalculator.applyCentering(forces: updatedForces, nodes: visibleNodes)

                var shouldContinue = false
                let subSteps = nodes.count < 5 ? 2 : (nodes.count < 10 ? 5 : (nodes.count < 30 ? 3 : 1))

                var updatedNodes = nodes
                for _ in 0..<subSteps {
                    let (tempNodes, stepActive) = self.physicsEngine.positionUpdater.updatePositionsAndVelocities(nodes: updatedNodes, forces: updatedForces, edges: self.getEdges(), quadtree: quadtree)  // Updated: Pass quadtree
                    updatedNodes = tempNodes
                    shouldContinue = shouldContinue || stepActive  // Accumulate
                }
                
                let totalVelocity = updatedNodes.reduce(0.0) { $0 + hypot($1.velocity.x, $1.velocity.y) }
                
                DispatchQueue.main.async {
                    self.setNodes(updatedNodes)
                    onUpdate()
                    
                    // Early stop if already stable
                    if !shouldContinue || totalVelocity < Constants.Physics.velocityThreshold * CGFloat(nodes.count) {
                        self.stopSimulation()
                        self.onStable?()  // New: Call when stable
                        return
                    }
                    self.recentVelocities.append(totalVelocity)
                    if self.recentVelocities.count > self.velocityHistoryCount {
                        self.recentVelocities.removeFirst()
                    }
                    
                    if self.recentVelocities.count == self.velocityHistoryCount {
                        let maxVel = self.recentVelocities.max() ?? 1.0
                        let minVel = self.recentVelocities.min() ?? 0.0
                        let relativeChange = (maxVel - minVel) / maxVel
                        // In the relativeChange check, also call onStable on stop
                        if relativeChange < self.velocityChangeThreshold {
                            self.stopSimulation()
                            self.onStable?()  // New
                            return
                        }
                    }
                }
            }
        }
    }
    
    func stopSimulation() {
        timer?.invalidate()
        timer = nil
    }
}
--------------------------------------------------
--------------------------------------------------
File: GraphTypes.swift
Path: GraphEditorShared/Sources/GraphEditorShared/GraphTypes.swift
Last modified: 2025-08-13 11:11:13

Contents:
import SwiftUI
import Foundation

public typealias NodeID = UUID

@available(iOS 13.0, *)
@available(watchOS 9.0, *)
public struct Node: NodeProtocol {
    public let id: NodeID
    public let label: Int
    public var position: CGPoint
    public var velocity: CGPoint = .zero
    public var radius: CGFloat = 10.0
    public var isExpanded: Bool = true  // Add: Satisfy protocol (always true for basic Node)
    public var fillColor: Color { .red }  // Explicit red for basic nodes

    // Update init to include radius
    public init(id: NodeID = NodeID(), label: Int, position: CGPoint, velocity: CGPoint = .zero, radius: CGFloat = 10.0) {
        self.id = id
        self.label = label
        self.position = position
        self.velocity = velocity
        self.radius = radius
    }
    
    public func with(position: CGPoint, velocity: CGPoint) -> Self {
        Node(id: id, label: label, position: position, velocity: velocity, radius: radius)
    }

    // Update CodingKeys and decoder/encoder for radius
    enum CodingKeys: String, CodingKey {
        case id, label, radius  // Add radius
        case positionX, positionY
        case velocityX, velocityY
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(NodeID.self, forKey: .id)
        label = try container.decode(Int.self, forKey: .label)
        radius = try container.decodeIfPresent(CGFloat.self, forKey: .radius) ?? 10.0  // Decode or default
        let posX = try container.decode(CGFloat.self, forKey: .positionX)
        let posY = try container.decode(CGFloat.self, forKey: .positionY)
        position = CGPoint(x: posX, y: posY)
        let velX = try container.decode(CGFloat.self, forKey: .velocityX)
        let velY = try container.decode(CGFloat.self, forKey: .velocityY)
        velocity = CGPoint(x: velX, y: velY)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(label, forKey: .label)
        try container.encode(radius, forKey: .radius)  // Encode radius
        try container.encode(position.x, forKey: .positionX)
        try container.encode(position.y, forKey: .positionY)
        try container.encode(velocity.x, forKey: .velocityX)
        try container.encode(velocity.y, forKey: .velocityY)
    }
}

// Represents an edge connecting two nodes.
public struct GraphEdge: Identifiable, Equatable, Codable {
    public let id: NodeID
    public let from: NodeID
    public let to: NodeID
    
    enum CodingKeys: String, CodingKey {
        case id, from, to
    }
    
    public init(id: NodeID = NodeID(), from: NodeID, to: NodeID) {
        self.id = id
        self.from = from
        self.to = to
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(NodeID.self, forKey: .id)
        from = try container.decode(NodeID.self, forKey: .from)
        to = try container.decode(NodeID.self, forKey: .to)
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(from, forKey: .from)
        try container.encode(to, forKey: .to)
    }
}

// Snapshot of the graph state for undo/redo.
@available(iOS 13.0, *)
@available(watchOS 9.0, *)
public struct GraphState {
    public let nodes: [any NodeProtocol]
    public let edges: [GraphEdge]
    
    public init(nodes: [any NodeProtocol], edges: [GraphEdge]) {
        self.nodes = nodes
        self.edges = edges
    }
}

public enum NodeWrapper: Codable {
    case node(Node)
    case toggleNode(ToggleNode)
    
    enum CodingKeys: String, CodingKey {
        case type, data
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(String.self, forKey: .type)
        switch type {
        case "node":
            let data = try container.decode(Node.self, forKey: .data)
            self = .node(data)
        case "toggleNode":
            let data = try container.decode(ToggleNode.self, forKey: .data)
            self = .toggleNode(data)
        default:
            throw DecodingError.dataCorruptedError(forKey: .type, in: container, debugDescription: "Unknown node type")
        }
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
        case .node(let node):
            try container.encode("node", forKey: .type)
            try container.encode(node, forKey: .data)
        case .toggleNode(let toggleNode):
            try container.encode("toggleNode", forKey: .type)
            try container.encode(toggleNode, forKey: .data)
        }
    }
    
    public var value: any NodeProtocol {
        switch self {
        case .node(let node): return node
        case .toggleNode(let toggleNode): return toggleNode
        }
    }
}
--------------------------------------------------
--------------------------------------------------
File: NodeProtocol.swift
Path: GraphEditorShared/Sources/GraphEditorShared/NodeProtocol.swift
Last modified: 2025-08-17 21:47:32

Contents:
// Sources/GraphEditorShared/NodeProtocol.swift

import SwiftUI
import Foundation

private var nodeTextCache: [String: GraphicsContext.ResolvedText] = [:]
private let maxCacheSize = 100  // Arbitrary limit; adjust based on testing
private let nodeCacheQueue = DispatchQueue(label: "nodeTextCache", attributes: .concurrent)
private var insertionOrder: [String] = []  // New: Track order


/// Protocol for graph nodes, enabling polymorphism for types like standard or toggleable nodes.
/// Conformers must provide core properties; defaults are available for common behaviors.
@available(iOS 13.0, *)
@available(watchOS 9.0, *)
public protocol NodeProtocol: Identifiable, Equatable, Codable where ID == NodeID {
    /// Unique identifier for the node.
    var id: NodeID { get }
    
    /// Permanent label for the node (e.g., for display and accessibility).
    var label: Int { get }
    
    /// Current position in the graph canvas.
    var position: CGPoint { get set }
    
    /// Velocity vector for physics simulation.
    var velocity: CGPoint { get set }
    
    /// Radius for rendering and hit detection.
    var radius: CGFloat { get set }
    
    /// Expansion state for hierarchical nodes (e.g., true shows children).
    var isExpanded: Bool { get set }
    
    /// Creates a copy with updated position and velocity.
    func with(position: CGPoint, velocity: CGPoint) -> Self
    
    /// Renders the node as a SwiftUI view, customizable by zoom and selection.
    /// - Parameters:
    ///   - zoomScale: Current zoom level of the canvas.
    ///   - isSelected: Whether the node is selected (e.g., for border highlight).
    /// - Returns: A SwiftUI view representing the node.
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    func renderView(zoomScale: CGFloat, isSelected: Bool) -> AnyView
    
    /// Handles tap gestures, returning a mutated copy (immutable pattern).
    /// - Returns: Updated node after tap (e.g., toggled state).
    func handlingTap() -> Self
    
    /// Indicates if the node is visible in the graph.
    var isVisible: Bool { get }
    
    /// Configurable fill color for the node's roundel.
    var fillColor: Color { get }
    
    /// Determines if child nodes (via outgoing edges) should be hidden.
    /// - Returns: True if children should be hidden (e.g., collapsed toggle).
    func shouldHideChildren() -> Bool
    
    /// Draws the node in a GraphicsContext for efficient Canvas rendering.
    /// - Parameters:
    ///   - context: The GraphicsContext to draw into.
    ///   - position: Center position for drawing.
    ///   - zoomScale: Current zoom level.
    ///   - isSelected: Whether to draw selection highlights.
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    func draw(in context: GraphicsContext, at position: CGPoint, zoomScale: CGFloat, isSelected: Bool)
}

/// Extension providing default implementations for non-rendering behaviors.
/// These can be overridden in conformers for custom logic.
@available(iOS 13.0, *)
@available(watchOS 9.0, *)
public extension NodeProtocol {
    /// Default: No change on tap.
    func handlingTap() -> Self { self }
    
    /// Default: Node is always visible.
    var isVisible: Bool { true }
    
    var fillColor: Color { .red }  // Default to red for all nodes
    
    var isExpanded: Bool {
        get { true }  // Default: Always expanded (non-toggle nodes ignore)
        set { }  // No-op setter for non-mutating types
    }
    
    func shouldHideChildren() -> Bool {
        !isExpanded  // Default: Hide if not expanded
    }
}

/// Extension providing default rendering implementations using GraphicsContext.
/// Override for custom node appearances (e.g., different shapes/colors).
@available(iOS 15.0, *)
@available(watchOS 9.0, *)
public extension NodeProtocol {
    func renderView(zoomScale: CGFloat, isSelected: Bool) -> AnyView {
        AnyView(Canvas { context, _ in
            self.draw(in: context, at: .zero, zoomScale: zoomScale, isSelected: isSelected)
        })
    }
    
    func draw(in context: GraphicsContext, at position: CGPoint, zoomScale: CGFloat, isSelected: Bool) {
        let scaledRadius = radius * zoomScale
        let borderWidth: CGFloat = isSelected ? 4 * zoomScale : 0
        let borderRadius = scaledRadius + borderWidth / 2
        
        if borderWidth > 0 {
            let borderPath = Path(ellipseIn: CGRect(x: position.x - borderRadius, y: position.y - borderRadius, width: 2 * borderRadius, height: 2 * borderRadius))
            context.stroke(borderPath, with: .color(.yellow), lineWidth: borderWidth)
        }
        
        let innerPath = Path(ellipseIn: CGRect(x: position.x - scaledRadius, y: position.y - scaledRadius, width: 2 * scaledRadius, height: 2 * scaledRadius))
        context.fill(innerPath, with: .color(.red))
        
        // Always draw label (removed if isSelected)
        let fontSize = UIFontMetrics.default.scaledValue(for: 12) * zoomScale
        let labelKey = "\(label)-\(fontSize)"
        let resolved: GraphicsContext.ResolvedText = nodeCacheQueue.sync {
            if let cached = nodeTextCache[labelKey] { return cached }
            let text = Text("\(label)").foregroundColor(.white).font(.system(size: fontSize))
            let resolved = context.resolve(text)
            nodeCacheQueue.async(flags: .barrier) {
                nodeTextCache[labelKey] = resolved
                insertionOrder.append(labelKey)  // Add to order
                if nodeTextCache.count > maxCacheSize {
                    let oldestKey = insertionOrder.removeFirst()  // True oldest
                    nodeTextCache.removeValue(forKey: oldestKey)
                }
            }
            return resolved
        }
        let labelPosition = CGPoint(x: position.x, y: position.y - (radius * zoomScale + 10 * zoomScale))
        context.draw(resolved, at: labelPosition, anchor: .center)
    }
}
--------------------------------------------------
--------------------------------------------------
File: PersistenceManager.swift
Path: GraphEditorShared/Sources/GraphEditorShared/PersistenceManager.swift
Last modified: 2025-08-15 15:21:36

Contents:
// Sources/GraphEditorShared/PersistenceManager.swift

import Foundation
import os.log

private let logger = OSLog(subsystem: "io.handcart.GraphEditor", category: "storage")

@available(iOS 13.0, watchOS 6.0, *)
/// Error types for graph storage operations.
public enum GraphStorageError: Error {
    case encodingFailed(Error)
    case writingFailed(Error)
    case loadingFailed(Error)
    case decodingFailed(Error)
    case inconsistentFiles(String)  // New: For cases where one file exists but not the other
}

/// File-based JSON persistence conforming to GraphStorage.
@available(iOS 13.0, watchOS 6.0, *)
public class PersistenceManager: GraphStorage {
    private let baseURL: URL
    private let nodesFileName = "graphNodes.json"
    private let edgesFileName = "graphEdges.json"
    
    public init(baseURL: URL) {
        self.baseURL = baseURL
        try? FileManager.default.createDirectory(at: baseURL, withIntermediateDirectories: true)
    }
    
    public convenience init() {
        let documents = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        self.init(baseURL: documents.appendingPathComponent("GraphEditor"))
    }
    
    public func save(nodes: [any NodeProtocol], edges: [GraphEdge]) throws {
        let wrappedNodes = nodes.map { node in
            if let n = node as? Node {
                return NodeWrapper.node(n)
            } else if let tn = node as? ToggleNode {
                return NodeWrapper.toggleNode(tn)
            } else {
                fatalError("Unsupported node type: \(type(of: node))")
            }
        }
        let encoder = JSONEncoder()
        do {
            let nodeData = try encoder.encode(wrappedNodes)
            let nodeURL = baseURL.appendingPathComponent(nodesFileName)
            try nodeData.write(to: nodeURL)
            
            let edgeData = try encoder.encode(edges)
            let edgeURL = baseURL.appendingPathComponent(edgesFileName)
            try edgeData.write(to: edgeURL)
        } catch let error as EncodingError {
            os_log("Encoding failed: %{public}s", log: logger, type: .error, error.localizedDescription)
            throw GraphStorageError.encodingFailed(error)
        } catch {
            os_log("Writing failed: %{public}s", log: logger, type: .error, error.localizedDescription)
            throw GraphStorageError.writingFailed(error)
        }
    }

    public func load() throws -> (nodes: [any NodeProtocol], edges: [GraphEdge]) {
        let fm = FileManager.default
        let nodeURL = baseURL.appendingPathComponent(nodesFileName)
        let edgeURL = baseURL.appendingPathComponent(edgesFileName)
        
        let nodesExist = fm.fileExists(atPath: nodeURL.path)
        let edgesExist = fm.fileExists(atPath: edgeURL.path)
        
        if !nodesExist && !edgesExist {
            return ([], [])
        }
        
        // Handle inconsistency: Delete orphan and return empty
        if nodesExist != edgesExist {
            let message = nodesExist ? "Edges file missing but nodes exist; deleting orphan nodes file" : "Nodes file missing but edges exist; deleting orphan edges file"
            os_log("%{public}s", log: logger, type: .error, message)
            if nodesExist {
                try? fm.removeItem(at: nodeURL)
            } else {
                try? fm.removeItem(at: edgeURL)
            }
            return ([], [])  // Graceful empty return
        }
        
        // Both exist: Load and decode
        let decoder = JSONDecoder()
        
        let nodeData: Data
        do {
            nodeData = try Data(contentsOf: nodeURL)
        } catch {
            os_log("Loading nodes failed: %{public}s", log: logger, type: .error, error.localizedDescription)
            throw GraphStorageError.loadingFailed(error)
        }
        let loadedWrapped: [NodeWrapper]
        do {
            loadedWrapped = try decoder.decode([NodeWrapper].self, from: nodeData)
        } catch {
            os_log("Decoding nodes failed: %{public}s", log: logger, type: .error, error.localizedDescription)
            throw GraphStorageError.decodingFailed(error)
        }
        let loadedNodes = loadedWrapped.map { $0.value }
        
        let edgeData: Data
        do {
            edgeData = try Data(contentsOf: edgeURL)
        } catch {
            os_log("Loading edges failed: %{public}s", log: logger, type: .error, error.localizedDescription)
            throw GraphStorageError.loadingFailed(error)
        }
        let loadedEdges: [GraphEdge]
        do {
            loadedEdges = try decoder.decode([GraphEdge].self, from: edgeData)
        } catch {
            os_log("Decoding edges failed: %{public}s", log: logger, type: .error, error.localizedDescription)
            throw GraphStorageError.decodingFailed(error)
        }
        
        return (loadedNodes, loadedEdges)
    }
    public func clear() throws {
        let fm = FileManager.default
        let nodeURL = baseURL.appendingPathComponent(nodesFileName)
        let edgeURL = baseURL.appendingPathComponent(edgesFileName)
        
        if fm.fileExists(atPath: nodeURL.path) {
            try fm.removeItem(at: nodeURL)
        }
        if fm.fileExists(atPath: edgeURL.path) {
            try fm.removeItem(at: edgeURL)
        }
    }

    // Updated helper struct
    struct ViewState: Codable {
        let offset: CGPoint
        let zoomScale: CGFloat
        let selectedNodeID: UUID?  // NodeID is UUID from GraphTypes.swift
        let selectedEdgeID: UUID?  // Matches @Published in GraphViewModel
    }

    // Updated save method
    public func saveViewState(offset: CGPoint, zoomScale: CGFloat, selectedNodeID: UUID?, selectedEdgeID: UUID?) throws {
        let state = ViewState(offset: offset, zoomScale: zoomScale, selectedNodeID: selectedNodeID, selectedEdgeID: selectedEdgeID)
        let data = try JSONEncoder().encode(state)
        UserDefaults.standard.set(data, forKey: "graphViewState")
        // In saveViewState()
        UserDefaults.standard.set(data, forKey: "graphViewState")
        UserDefaults.standard.synchronize()  // Add this
    }

    // Updated load method
    public func loadViewState() throws -> (offset: CGPoint, zoomScale: CGFloat, selectedNodeID: UUID?, selectedEdgeID: UUID?)? {
        guard let data = UserDefaults.standard.data(forKey: "graphViewState") else { return nil }
        let state = try JSONDecoder().decode(ViewState.self, from: data)
        return (offset: state.offset, zoomScale: state.zoomScale, selectedNodeID: state.selectedNodeID, selectedEdgeID: state.selectedEdgeID)
    }
}
--------------------------------------------------
--------------------------------------------------
File: PhysicsEngine.swift
Path: GraphEditorShared/Sources/GraphEditorShared/PhysicsEngine.swift
Last modified: 2025-08-18 11:12:35

Contents:
//
//  PhysicsEngine.swift
//  GraphEditorShared
//
//  Created by handcart on 8/1/25.
//

import os.log
import SwiftUI
import Foundation
import CoreGraphics

@available(iOS 13.0, *)
@available(watchOS 9.0, *)
public class PhysicsEngine {
    private let physicsLogger = OSLog(subsystem: "io.handcart.GraphEditor", category: "physics")
    let simulationBounds: CGSize
    private var stepCount: Int = 0
    private let maxNodesForQuadtree = 200
    private let symmetricFactor: CGFloat = 0.5
    internal let repulsionCalculator: RepulsionCalculator
    internal let attractionCalculator: AttractionCalculator
    internal let centeringCalculator: CenteringCalculator
    internal let positionUpdater: PositionUpdater
    
    public init(simulationBounds: CGSize) {
        self.simulationBounds = simulationBounds
        self.repulsionCalculator = RepulsionCalculator(maxNodesForQuadtree: 200, simulationBounds: simulationBounds)
        self.attractionCalculator = AttractionCalculator(useAsymmetricAttraction: self.useAsymmetricAttraction, symmetricFactor: self.symmetricFactor)
        self.centeringCalculator = CenteringCalculator(simulationBounds: simulationBounds)
        self.positionUpdater = PositionUpdater(simulationBounds: simulationBounds)  // Added missing arg
    }
    
    private var simulationSteps = 0
    
    public func resetSimulation() {
        simulationSteps = 0
        stepCount = 0
    }
    
    public var useAsymmetricAttraction: Bool = false  // Default to false for stability
    public var isPaused: Bool = false
    
    @discardableResult
    public func simulationStep(nodes: [any NodeProtocol], edges: [GraphEdge]) -> ([any NodeProtocol], Bool) {
        if isPaused { return (nodes, false) }
        stepCount += 1
        if stepCount > Constants.Physics.maxSimulationSteps { return (nodes, false) }
        
        let (forces, quadtree) = repulsionCalculator.computeRepulsions(nodes: nodes)  // Updated: Unpack tuple
        
        var updatedForces = forces  // Temp var to avoid mutating forces directly
        updatedForces = attractionCalculator.applyAttractions(forces: updatedForces, edges: edges, nodes: nodes)
        updatedForces = centeringCalculator.applyCentering(forces: updatedForces, nodes: nodes)
        
        // New: Log totals every 2 steps to avoid spam
        if stepCount % 2 == 0 {
            let totalForce = updatedForces.values.reduce(0.0) { $0 + hypot($1.x, $1.y) }
            let totalVel = nodes.reduce(0.0) { $0 + hypot($1.velocity.x, $1.velocity.y) }
            os_log("Step %{public}d: Total force magnitude = %{public}.2f, Total velocity = %{public}.2f", log: physicsLogger, type: .debug, stepCount, totalForce, totalVel)
        }

        let (updatedNodes, isActive) = positionUpdater.updatePositionsAndVelocities(nodes: nodes, forces: updatedForces, edges: edges, quadtree: quadtree)  // Updated: Pass quadtree
        return (updatedNodes, isActive)
    }
    
    public func boundingBox(nodes: [any NodeProtocol]) -> CGRect {
        guard !nodes.isEmpty else { return .zero }
        var minX = nodes[0].position.x, minY = nodes[0].position.y
        var maxX = nodes[0].position.x, maxY = nodes[0].position.y
        for node in nodes {
            minX = min(minX, node.position.x - node.radius)
            minY = min(minY, node.position.y - node.radius)
            maxX = max(maxX, node.position.x + node.radius)
            maxY = max(maxY, node.position.y + node.radius)
        }
        return CGRect(x: minX, y: minY, width: maxX - minX, height: maxY - minY)
    }
    
    public func centerNodes(nodes: [any NodeProtocol], around center: CGPoint? = nil) -> [any NodeProtocol] {
        guard !nodes.isEmpty else { return [] }
        let targetCenter = center ?? CGPoint(x: simulationBounds.width / 2, y: simulationBounds.height / 2)
        
        // Compute current centroid
        let totalX = nodes.reduce(0.0) { $0 + $1.position.x }
        let totalY = nodes.reduce(0.0) { $0 + $1.position.y }
        let centroid = CGPoint(x: totalX / CGFloat(nodes.count), y: totalY / CGFloat(nodes.count))
        
        // Create updated nodes with translation
        let dx = targetCenter.x - centroid.x
        let dy = targetCenter.y - centroid.y
        return nodes.map { node in
            let newPosition = CGPoint(x: node.position.x + dx, y: node.position.y + dy)
            return node.with(position: newPosition, velocity: node.velocity)
        }
    }
}
--------------------------------------------------
--------------------------------------------------
File: PositionUpdater.swift
Path: GraphEditorShared/Sources/GraphEditorShared/PositionUpdater.swift
Last modified: 2025-08-19 11:36:48

Contents:
//
//  PositionUpdater.swift
//  GraphEditorShared
//
//  Created by handcart on 8/12/25.
//

import Foundation
import CoreGraphics

struct PositionUpdater {
    let simulationBounds: CGSize
    
    init(simulationBounds: CGSize) {
        self.simulationBounds = simulationBounds
    }
    
    func updatePositionsAndVelocities(nodes: [any NodeProtocol], forces: [NodeID: CGPoint], edges: [GraphEdge], quadtree: Quadtree?) -> ([any NodeProtocol], Bool) {
        var tentativeUpdates: [NodeID: (position: CGPoint, velocity: CGPoint)] = [:]
        for node in nodes {
            let force = forces[node.id] ?? .zero
            var newVelocity = CGPoint(x: node.velocity.x + force.x * Constants.Physics.timeStep, y: node.velocity.y + force.y * Constants.Physics.timeStep)
            newVelocity = CGPoint(x: newVelocity.x * Constants.Physics.damping, y: newVelocity.y * Constants.Physics.damping)
            var newPosition = CGPoint(x: node.position.x + newVelocity.x * Constants.Physics.timeStep, y: node.position.y + newVelocity.y * Constants.Physics.timeStep)
            
            // Tentative bounds clamp and softer bounce
            let oldPosition = newPosition
            newPosition.x = max(0, min(simulationBounds.width, newPosition.x))
            newPosition.y = max(0, min(simulationBounds.height, newPosition.y))
            if newPosition.x != oldPosition.x {
                newVelocity.x = -newVelocity.x * 0.8
            }
            if newPosition.y != oldPosition.y {
                newVelocity.y = -newVelocity.y * 0.8
            }
            
            // Insert anti-collision separation here
            let minDist: CGFloat = 35.0  // Or Constants.Physics.minCollisionDist if defined
            if let qt = quadtree {
                let nearby = qt.queryNearby(position: newPosition, radius: minDist)
                for other in nearby where other.id != node.id {
                    let delta = newPosition - other.position
                    let d = hypot(delta.x, delta.y)
                    if d < minDist && d > 0 {
                        newPosition += (delta / d) * (minDist - d) / 2
                    }
                }
            } else {
                // Fallback to original O(n^2) for small graphs
                for other in nodes where other.id != node.id {
                    let delta = newPosition - other.position
                    let d = hypot(delta.x, delta.y)
                    if d < minDist && d > 0 {
                        newPosition += (delta / d) * (minDist - d) / 2
                    }
                }
            }
            
            // FIXED: Store the computed values (this was missing, causing nil in second loop)
            tentativeUpdates[node.id] = (position: newPosition, velocity: newVelocity)
        }
        
        // Build multi-parent map: child -> [parents]
        var parentMap = [NodeID: [NodeID]]()
        for edge in edges {
            parentMap[edge.to, default: []].append(edge.from)
        }
        
        // Second pass: Apply clamping using tentative parent updates and create final updated nodes
        var updatedNodes: [any NodeProtocol] = []
        var totalVelocity: CGFloat = 0.0
        for node in nodes {
            var newPosition = tentativeUpdates[node.id]!.position
            var newVelocity = tentativeUpdates[node.id]!.velocity
            
            if let parents = parentMap[node.id], !parents.isEmpty {
                let collapsedParents = parents.filter { parentID in
                    nodes.first(where: { $0.id == parentID })?.isExpanded == false
                }
                if !collapsedParents.isEmpty {
                    // Average tentative positions of collapsed parents
                    var avgPos = CGPoint.zero
                    for parentID in collapsedParents {
                        avgPos = avgPos + tentativeUpdates[parentID]!.position
                    }
                    avgPos = avgPos / CGFloat(collapsedParents.count)
                    newPosition = avgPos
                    newVelocity = .zero
                }
            }
            
            let updatedNode = node.with(position: newPosition, velocity: newVelocity)
            updatedNodes.append(updatedNode)
            totalVelocity += hypot(newVelocity.x, newVelocity.y)
        }
        
        // Check if stable based on total velocity
        let isActive = totalVelocity >= Constants.Physics.velocityThreshold * CGFloat(nodes.count)
        
        return (updatedNodes, isActive)
    }
}
--------------------------------------------------
--------------------------------------------------
File: Protocols.swift
Path: GraphEditorShared/Sources/GraphEditorShared/Protocols.swift
Last modified: 2025-08-15 13:19:34

Contents:
//
//  GraphStorage.swift
//  GraphEditorShared
//
//  Created by handcart on 8/1/25.
//

import SwiftUI
// Sources/GraphEditorShared/Protocols.swift

@available(iOS 13.0, watchOS 6.0, *)
public protocol GraphStorage {
    /// Saves the graph nodes and edges, throwing on failure (e.g., encoding or writing errors).
    func save(nodes: [any NodeProtocol], edges: [GraphEdge]) throws
    /// Loads the graph nodes and edges, throwing on failure (e.g., file not found or decoding errors).
    func load() throws -> (nodes: [any NodeProtocol], edges: [GraphEdge])
    func clear() throws  // Unchanged
    func saveViewState(offset: CGPoint, zoomScale: CGFloat, selectedNodeID: UUID?, selectedEdgeID: UUID?) throws
    func loadViewState() throws -> (offset: CGPoint, zoomScale: CGFloat, selectedNodeID: UUID?, selectedEdgeID: UUID?)?
}

// In GraphEditorShared/Sources/GraphEditorShared/Protocols.swift (add inside protocol GraphStorage)



// Add a protocol extension for defaults (at bottom of file)
extension GraphStorage {
    func saveViewState(offset: CGPoint, zoomScale: CGFloat, selectedNodeID: UUID?, selectedEdgeID: UUID?) throws {
        // Default: Do nothing (for storages that don't support view state)
    }
    
    func loadViewState() throws -> (offset: CGPoint, zoomScale: CGFloat, selectedNodeID: UUID?, selectedEdgeID: UUID?)? {
        return nil  // Default: No state
    }
}
--------------------------------------------------
--------------------------------------------------
File: Quadtree.swift
Path: GraphEditorShared/Sources/GraphEditorShared/Quadtree.swift
Last modified: 2025-08-18 10:52:44

Contents:
// Sources/GraphEditorShared/Quadtree.swift

import Foundation
import CoreGraphics

@available(iOS 13.0, *)
@available(watchOS 9.0, *)
public class Quadtree {  // Made public for consistency/test access
    let bounds: CGRect
    public var centerOfMass: CGPoint = .zero
    public var totalMass: CGFloat = 0
    public var children: [Quadtree]? = nil
    var nodes: [any NodeProtocol] = []  // Updated: Existential array
    
    public init(bounds: CGRect) {
        self.bounds = bounds
    }
    
    public func insert(_ node: any NodeProtocol, depth: Int = 0) {
        guard bounds.width >= Constants.Physics.minQuadSize && bounds.height >= Constants.Physics.minQuadSize else {
            nodes.append(node)
            updateCenterOfMass(with: node)
            return
        }
        guard depth <= Constants.Physics.maxQuadtreeDepth else {
            nodes.append(node)
            updateCenterOfMass(with: node)
            return
        }
        
        if let children = children {
            // Existing subdivided quad: Insert into child
            let quadrant = getQuadrant(for: node.position)
            children[quadrant].insert(node, depth: depth + 1)
            aggregateFromChildren()  // Update aggregates post-insert
        } else if !nodes.isEmpty {
            // Leaf with nodes: Subdivide and redistribute
            subdivide()
            guard let children = children else {
                // Failed to subdivide (too small); append to leaf
                nodes.append(node)
                updateCenterOfMass(with: node)
                return
            }
            for existing in nodes {
                let quadrant = getQuadrant(for: existing.position)
                children[quadrant].insert(existing, depth: depth + 1)
            }
            nodes = []
            let quadrant = getQuadrant(for: node.position)
            children[quadrant].insert(node, depth: depth + 1)
            aggregateFromChildren()
        } else {
            // Empty leaf: Append
            nodes.append(node)
            updateCenterOfMass(with: node)
        }
    }
    
    public func batchInsert(_ batchNodes: [any NodeProtocol], depth: Int = 0) {
        guard depth <= Constants.Physics.maxQuadtreeDepth,
              bounds.width >= Constants.Physics.minQuadSize,
              bounds.height >= Constants.Physics.minQuadSize else {
            nodes.append(contentsOf: batchNodes)
            for node in batchNodes {
                updateCenterOfMass(with: node)  // Incremental updates
            }
            return
        }
        
        if let children = children {
            // Existing subdivided quad: Distribute to children, defer aggregation
            var childBatches: [[any NodeProtocol]] = Array(repeating: [], count: 4)
            for node in batchNodes {
                let quadrant = getQuadrant(for: node.position)
                childBatches[quadrant].append(node)
            }
            for i in 0..<4 {
                if !childBatches[i].isEmpty {
                    children[i].batchInsert(childBatches[i], depth: depth + 1)
                }
            }
            aggregateFromChildren()  // Aggregate once after all inserts
        } else if !nodes.isEmpty || !batchNodes.isEmpty {
            // Leaf: If needs subdivide, do so and redistribute all
            let allNodes = nodes + batchNodes
            if allNodes.count > 1 {  // Subdivide threshold (e.g., >1 for batch)
                subdivide()
                guard let children = children else {
                    // Failed: Append to leaf
                    nodes.append(contentsOf: batchNodes)
                    for node in batchNodes {
                        updateCenterOfMass(with: node)
                    }
                    return
                }
                var childBatches: [[any NodeProtocol]] = Array(repeating: [], count: 4)
                for node in allNodes {
                    let quadrant = getQuadrant(for: node.position)
                    childBatches[quadrant].append(node)
                }
                nodes = []
                for i in 0..<4 {
                    if !childBatches[i].isEmpty {
                        children[i].batchInsert(childBatches[i], depth: depth + 1)
                    }
                }
                aggregateFromChildren()  // Aggregate once
            } else {
                // No subdivide needed: Append and update
                nodes.append(contentsOf: batchNodes)
                for node in batchNodes {
                    updateCenterOfMass(with: node)
                }
            }
        }
    }

    private func aggregateFromChildren() {
        // Recompute totalMass and centerOfMass from children (bottom-up)
        centerOfMass = .zero
        totalMass = 0
        guard let children = children else { return }
        for child in children {
            if child.totalMass > 0 {
                centerOfMass = (centerOfMass * totalMass + child.centerOfMass * child.totalMass) / (totalMass + child.totalMass)
                totalMass += child.totalMass
            }
        }
    }
    
    private func subdivide() {
        let halfWidth = bounds.width / 2
        let halfHeight = bounds.height / 2
        if halfWidth < Constants.Physics.minQuadSize || halfHeight < Constants.Physics.minQuadSize {  // Use constant
            return  // Too small
        }
        children = [
            Quadtree(bounds: CGRect(x: bounds.minX, y: bounds.minY, width: halfWidth, height: halfHeight)),
            Quadtree(bounds: CGRect(x: bounds.minX + halfWidth, y: bounds.minY, width: halfWidth, height: halfHeight)),
            Quadtree(bounds: CGRect(x: bounds.minX, y: bounds.minY + halfHeight, width: halfWidth, height: halfHeight)),
            Quadtree(bounds: CGRect(x: bounds.minX + halfWidth, y: bounds.minY + halfHeight, width: halfWidth, height: halfHeight))
        ]
    }
    
    private func getQuadrant(for point: CGPoint) -> Int {
        let midX = bounds.midX
        let midY = bounds.midY
        if point.x < midX {
            if point.y < midY { return 0 }
            else { return 2 }
        } else {
            if point.y < midY { return 1 }
            else { return 3 }
        }
    }
    
    private func updateCenterOfMass(with node: any NodeProtocol) {
        // Incremental update (works for both leaves and internals); assume mass=1 per node
        centerOfMass = (centerOfMass * totalMass + node.position) / (totalMass + 1)
        totalMass += 1
    }
    
    public func computeForce(on queryNode: any NodeProtocol, theta: CGFloat = 0.5) -> CGPoint {
        guard totalMass > 0 else { return .zero }
        if !nodes.isEmpty {
            // Leaf: Exact repulsion for each node in array
            var force: CGPoint = .zero
            for leafNode in nodes where leafNode.id != queryNode.id {
                force += repulsionForce(from: leafNode.position, to: queryNode.position)
            }
            return force
        }
        // Internal: Approximation
        let delta = centerOfMass - queryNode.position
        let dist = max(delta.magnitude, Constants.Physics.distanceEpsilon)  // Updated
        if bounds.width / dist < theta || children == nil {
            return repulsionForce(from: centerOfMass, to: queryNode.position, mass: totalMass)
        } else {
            var force: CGPoint = .zero
            if let children = children {
                for child in children {
                    force += child.computeForce(on: queryNode, theta: theta)
                }
            }
            return force
        }
    }
    
    public func queryNearby(position: CGPoint, radius: CGFloat) -> [any NodeProtocol] {
        var results: [any NodeProtocol] = []
        func traverse(qt: Quadtree) {
            // Check if quad intersects circle
            let closestX = max(qt.bounds.minX, min(position.x, qt.bounds.maxX))
            let closestY = max(qt.bounds.minY, min(position.y, qt.bounds.maxY))
            let distToQuad = hypot(closestX - position.x, closestY - position.y)
            if distToQuad > radius + hypot(qt.bounds.width/2, qt.bounds.height/2) { return }  // No intersection
            
            if let children = qt.children {
                for child in children {
                    traverse(qt: child)
                }
            } else {
                for node in qt.nodes {
                    let delta = node.position - position
                    if hypot(delta.x, delta.y) < radius {
                        results.append(node)
                    }
                }
            }
        }
        traverse(qt: self)
        return results
    }
    
    private func repulsionForce(from: CGPoint, to: CGPoint, mass: CGFloat = 1) -> CGPoint {
        let deltaX = to.x - from.x
        let deltaY = to.y - from.y
        let distSquared = deltaX * deltaX + deltaY * deltaY
        if distSquared < Constants.Physics.distanceEpsilon * Constants.Physics.distanceEpsilon {  // Updated
            // Jitter slightly to avoid zero
            return CGPoint(x: CGFloat.random(in: -0.01...0.01), y: CGFloat.random(in: -0.01...0.01)) * Constants.Physics.repulsion * mass
        }
        let dist = sqrt(distSquared)
        let forceMagnitude = Constants.Physics.repulsion * mass / distSquared
        return CGPoint(x: deltaX / dist * forceMagnitude, y: deltaY / dist * forceMagnitude)
    }
}
--------------------------------------------------
--------------------------------------------------
File: RepulsionCalculator.swift
Path: GraphEditorShared/Sources/GraphEditorShared/RepulsionCalculator.swift
Last modified: 2025-08-18 11:12:14

Contents:
//
//  RepulsionCalculator.swift
//  GraphEditorShared
//
//  Created by handcart on 8/12/25.
//

import Foundation
import CoreGraphics

struct RepulsionCalculator {
    private let maxNodesForQuadtree: Int
    private let simulationBounds: CGSize

    init(maxNodesForQuadtree: Int, simulationBounds: CGSize) {
        self.maxNodesForQuadtree = maxNodesForQuadtree
        self.simulationBounds = simulationBounds
    }

    func computeRepulsions(nodes: [any NodeProtocol]) -> ([NodeID: CGPoint], Quadtree?) {
        var forces: [NodeID: CGPoint] = [:]
        let useQuadtree = nodes.count > maxNodesForQuadtree && simulationBounds.width >= Constants.Physics.minQuadSize && simulationBounds.height >= Constants.Physics.minQuadSize
        let quadtree: Quadtree? = useQuadtree ? buildQuadtree(nodes: nodes) : nil

        for node in nodes {
            var repulsion: CGPoint = .zero
            if let quadtree = quadtree {
                let dynamicTheta: CGFloat = nodes.count > 100 ? 1.5 : (nodes.count > 50 ? 1.2 : 0.8)
                repulsion = quadtreeRepulsion(for: node, quadtree: quadtree, theta: dynamicTheta)  // Updated call
            } else {
                for otherNode in nodes where otherNode.id != node.id {
                    repulsion += repulsionForce(repellerPosition: otherNode.position, queryPosition: node.position)
                }
            }
            forces[node.id] = (forces[node.id] ?? .zero) + repulsion
        }
        return (forces, quadtree)  // New: Return tuple
    }

    public func buildQuadtree(nodes: [any NodeProtocol]) -> Quadtree {
        let boundingBox = boundingBox(nodes: nodes)  // Calls local func
        let quadtree = Quadtree(bounds: boundingBox)
        for node in nodes {
            quadtree.insert(node)
        }
        return quadtree
        // Removed duplicated block
    }

    private func repulsionForce(repellerPosition: CGPoint, queryPosition: CGPoint, mass: CGFloat = 1.0) -> CGPoint {
        let dx = queryPosition.x - repellerPosition.x
        let dy = queryPosition.y - repellerPosition.y
        let distanceSquared = max(dx * dx + dy * dy, Constants.Physics.distanceEpsilon)
        let distance = sqrt(distanceSquared)
        let forceMagnitude = Constants.Physics.repulsion * mass / distanceSquared
        return CGPoint(x: (dx / distance) * forceMagnitude, y: (dy / distance) * forceMagnitude)
    }
    
    private func quadtreeRepulsion(for node: any NodeProtocol, quadtree: Quadtree, theta: CGFloat) -> CGPoint {  // Added theta
        var force = CGPoint.zero
        func calculateRepulsion(qt: Quadtree) {
            if qt.children == nil {
                for other in qt.nodes where other.id != node.id {
                    force += repulsionForce(repellerPosition: other.position, queryPosition: node.position, mass: 1.0)
                }
                return
            }

            let dx = qt.centerOfMass.x - node.position.x
            let dy = qt.centerOfMass.y - node.position.y
            let distance = hypot(dx, dy)
            let width = qt.bounds.width

            if width / distance < theta && distance > 0 {  // Use theta
                let approxForce = repulsionForce(repellerPosition: qt.centerOfMass, queryPosition: node.position, mass: qt.totalMass)
                force += approxForce
            } else {
                if let children = qt.children {
                    calculateRepulsion(qt: children[0])
                    calculateRepulsion(qt: children[1])
                    calculateRepulsion(qt: children[2])
                    calculateRepulsion(qt: children[3])
                }
            }
        }

        calculateRepulsion(qt: quadtree)
        return force
    }

    // Added missing boundingBox func
    private func boundingBox(nodes: [any NodeProtocol]) -> CGRect {
        guard !nodes.isEmpty else { return .zero }
        var minX = nodes[0].position.x, minY = nodes[0].position.y
        var maxX = nodes[0].position.x, maxY = nodes[0].position.y
        for node in nodes {
            minX = min(minX, node.position.x - node.radius)
            minY = min(minY, node.position.y - node.radius)
            maxX = max(maxX, node.position.x + node.radius)
            maxY = max(maxY, node.position.y + node.radius)
        }
        return CGRect(x: minX, y: minY, width: maxX - minX, height: maxY - minY)
    }
}
--------------------------------------------------
--------------------------------------------------
File: ToggleNode.swift
Path: GraphEditorShared/Sources/GraphEditorShared/ToggleNode.swift
Last modified: 2025-08-13 13:47:33

Contents:
// Sources/GraphEditorShared/ToggleNode.swift

import SwiftUI
import Foundation

@available(iOS 13.0, *)
@available(watchOS 9.0, *)
public struct ToggleNode: NodeProtocol {
    public let id: NodeID
    public let label: Int
    public var position: CGPoint
    public var velocity: CGPoint = .zero
    public var radius: CGFloat = 10.0
    public var isExpanded: Bool = true  // Default to expanded
    public var fillColor: Color { isExpanded ? .green : .red }

    public init(id: NodeID = NodeID(), label: Int, position: CGPoint, velocity: CGPoint = .zero, radius: CGFloat = 10.0, isExpanded: Bool = true) {
        self.id = id
        self.label = label
        self.position = position
        self.velocity = velocity
        self.radius = radius
        self.isExpanded = isExpanded
    }

    public func with(position: CGPoint, velocity: CGPoint) -> Self {
        ToggleNode(id: id, label: label, position: position, velocity: velocity, radius: radius, isExpanded: isExpanded)
    }

    // In ToggleNode.swift, replace handlingTap with:
    public func handlingTap() -> Self {
        print("ToggleNode \(label) tapped. Expansion state before: \(isExpanded), after: \(!isExpanded)")
        var updated = self
        updated.isExpanded.toggle()
        return updated
    }

    // Override: Custom draw with +/- icon
    @available(iOS 15.0, *)
    @available(watchOS 9.0, *)
    public func draw(in context: GraphicsContext, at position: CGPoint, zoomScale: CGFloat, isSelected: Bool) {
        let scaledRadius = radius * zoomScale
        let borderWidth: CGFloat = isSelected ? 4 * zoomScale : 0
        let borderRadius = scaledRadius + borderWidth / 2

        if borderWidth > 0 {
            let borderPath = Path(ellipseIn: CGRect(x: position.x - borderRadius, y: position.y - borderRadius, width: 2 * borderRadius, height: 2 * borderRadius))
            context.stroke(borderPath, with: .color(.yellow), lineWidth: borderWidth)
        }

        let innerPath = Path(ellipseIn: CGRect(x: position.x - scaledRadius, y: position.y - scaledRadius, width: 2 * scaledRadius, height: 2 * scaledRadius))
        context.fill(innerPath, with: .color(fillColor))  // Use self.fillColor (e.g., .green if expanded, .red if collapsed)
        
        // Draw +/- icon
        let iconText = isExpanded ? "-" : "+"
        let fontSize = max(8.0, 12.0 * zoomScale)  // Readable min size
        let text = Text(iconText).foregroundColor(.white).font(.system(size: fontSize, weight: .bold))
        let resolved = context.resolve(text)
        context.draw(resolved, at: position, anchor: .center)  // Center in node

        // Draw label above (as in protocol default)
        let labelFontSize = max(8.0, 12.0 * zoomScale)
        let labelText = Text("\(label)").foregroundColor(.white).font(.system(size: labelFontSize))
        let labelResolved = context.resolve(labelText)
        let labelPosition = CGPoint(x: position.x, y: position.y - (scaledRadius + 10 * zoomScale))
        context.draw(labelResolved, at: labelPosition, anchor: .center)
    }

    // Codable conformance (for persistence)
    enum CodingKeys: String, CodingKey {
        case id, label, radius, isExpanded
        case positionX, positionY
        case velocityX, velocityY
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(NodeID.self, forKey: .id)
        label = try container.decode(Int.self, forKey: .label)
        radius = try container.decodeIfPresent(CGFloat.self, forKey: .radius) ?? 10.0
        isExpanded = try container.decodeIfPresent(Bool.self, forKey: .isExpanded) ?? true
        let posX = try container.decode(CGFloat.self, forKey: .positionX)
        let posY = try container.decode(CGFloat.self, forKey: .positionY)
        position = CGPoint(x: posX, y: posY)
        let velX = try container.decode(CGFloat.self, forKey: .velocityX)
        let velY = try container.decode(CGFloat.self, forKey: .velocityY)
        velocity = CGPoint(x: velX, y: velY)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(label, forKey: .label)
        try container.encode(radius, forKey: .radius)
        try container.encode(isExpanded, forKey: .isExpanded)
        try container.encode(position.x, forKey: .positionX)
        try container.encode(position.y, forKey: .positionY)
        try container.encode(velocity.x, forKey: .velocityX)
        try container.encode(velocity.y, forKey: .velocityY)
    }
}
--------------------------------------------------
--------------------------------------------------
File: Utilities.swift
Path: GraphEditorShared/Sources/GraphEditorShared/Utilities.swift
Last modified: 2025-08-21 08:05:59

Contents:
import Foundation
import CoreGraphics

public extension Double {
    func clamped(to range: ClosedRange<Double>) -> Double {
        max(range.lowerBound, min(self, range.upperBound))
    }
}

public extension CGFloat {
    func clamped(to range: ClosedRange<CGFloat>) -> CGFloat {
        Swift.max(range.lowerBound, Swift.min(self, range.upperBound))
    }
}

public extension CGFloat {
    func rounded(to decimalPlaces: Int) -> CGFloat {
        let divisor = pow(10.0, CGFloat(decimalPlaces))
        return (self * divisor).rounded() / divisor
    }
}

public extension CGPoint {
    func normalized() -> CGPoint {
            let len = hypot(x, y)
            return len > 0 ? self / len : .zero
        }
    
    static func + (lhs: CGPoint, rhs: CGPoint) -> CGPoint {
        CGPoint(x: lhs.x + rhs.x, y: lhs.y + rhs.y)
    }
    
    static func - (lhs: CGPoint, rhs: CGPoint) -> CGPoint {
        CGPoint(x: lhs.x - rhs.x, y: lhs.y - rhs.y)
    }
    
    static func * (lhs: CGPoint, rhs: CGFloat) -> CGPoint {
        CGPoint(x: lhs.x * rhs, y: lhs.y * rhs)
    }
    
    static func / (lhs: CGPoint, rhs: CGFloat) -> CGPoint {
        CGPoint(x: lhs.x / rhs, y: lhs.y / rhs)
    }
    
    static func += (lhs: inout CGPoint, rhs: CGPoint) {
        lhs = lhs + rhs
    }
    
    static func -= (lhs: inout CGPoint, rhs: CGPoint) {
        lhs = lhs - rhs
    }
    
    static func *= (lhs: inout CGPoint, rhs: CGFloat) {
        lhs = lhs * rhs
    }
    
    static func + (lhs: CGPoint, rhs: CGSize) -> CGPoint {
        CGPoint(x: lhs.x + rhs.width, y: lhs.y + rhs.height)
    }
    
    static func += (lhs: inout CGPoint, rhs: CGSize) {
        lhs = lhs + rhs
    }
    
    var magnitude: CGFloat {
        hypot(x, y)
    }
}

public extension CGSize {
    static func / (lhs: CGSize, rhs: CGFloat) -> CGSize {
        CGSize(width: lhs.width / rhs, height: lhs.height / rhs)
    }
    
    static func + (lhs: CGSize, rhs: CGSize) -> CGSize {
        CGSize(width: lhs.width + rhs.width, height: lhs.height + rhs.height)
    }
    
    static func += (lhs: inout CGSize, rhs: CGSize) {
        lhs = lhs + rhs
    }
}

// Shared utility functions
public func distance(_ a: CGPoint, _ b: CGPoint) -> CGFloat {
    hypot(a.x - b.x, a.y - b.y)
}
--------------------------------------------------
--------------------------------------------------
File: GraphEditorWatch.swift
Path: GraphEditorWatch/GraphEditorWatch.swift
Last modified: 2025-08-13 09:04:04

Contents:
//
//  GraphEditorWatch.swift
//  GraphEditorWatch Watch App
//
//  Created by handcart on 8/1/25.
//

import SwiftUI
import WatchKit

@main
struct GraphEditorWatch: App {
    @WKApplicationDelegateAdaptor(AppDelegate.self) private var delegate: AppDelegate

    var body: some Scene {
        WindowGroup {
            ContentView()
                .onAppear {
                    // Force focus on the crown sequencer to resolve setup warnings
                    WKExtension.shared().visibleInterfaceController?.crownSequencer.focus()
                }
        }
    }
}
--------------------------------------------------
--------------------------------------------------
File: AppConstants.swift
Path: GraphEditorWatch/Models/AppConstants.swift
Last modified: 2025-08-07 18:42:52

Contents:
//
//  AppConstants.swift
//  GraphEditor
//
//  Created by handcart on 8/3/25.
//


import CoreGraphics

struct AppConstants {
    // Graph visuals
    static let nodeModelRadius: CGFloat = 10.0
    static let hitScreenRadius: CGFloat = 30.0
    static let tapThreshold: CGFloat = 10.0
    
    // Zooming
    static let numZoomLevels = 10
    static let defaultMinZoom: CGFloat = 0.2
    static let defaultMaxZoom: CGFloat = 5.0
}
--------------------------------------------------
--------------------------------------------------
File: GraphViewModel.swift
Path: GraphEditorWatch/ViewModels/GraphViewModel.swift
Last modified: 2025-08-20 15:01:58

Contents:
//  GraphViewModel.swift
//  GraphEditor
//
//  Created by handcart on 8/1/25.

import SwiftUI
import Combine
import GraphEditorShared
import WatchKit  // For WKApplication

class GraphViewModel: ObservableObject {
    @Published var model: GraphModel
    @Published var selectedEdgeID: UUID? = nil  // New: For edge selection
    @Published var selectedNodeID: UUID? = nil  // Add this; matches bindings in views
    @Published var offset: CGPoint = .zero
    @Published var zoomScale: CGFloat = 1.0
    private var saveTimer: Timer? = nil
    
    private var cancellable: AnyCancellable?
    
    var canUndo: Bool {
        model.canUndo
    }
    
    var canRedo: Bool {
        model.canRedo
    }
    
    private var pauseObserver: NSObjectProtocol?
    private var resumeObserver: NSObjectProtocol?
    
    // New: Timer for debounced resumes
    private var resumeTimer: Timer?
    
    var effectiveCentroid: CGPoint {
        let visibleNodes = model.visibleNodes()
        if let id = selectedNodeID, let node = visibleNodes.first(where: { $0.id == id }) {
            return node.position
        } else if let id = selectedEdgeID, let edge = model.edges.first(where: { $0.id == id }),
                  let from = visibleNodes.first(where: { $0.id == edge.from }),
                  let to = visibleNodes.first(where: { $0.id == edge.to }) {
            return CGPoint(x: (from.position.x + to.position.x) / 2, y: (from.position.y + to.position.y) / 2)
        }
        return visibleNodes.centroid() ?? .zero
    }
    
    init(model: GraphModel) {
        self.model = model
        cancellable = model.objectWillChange.sink { [weak self] _ in
            self?.objectWillChange.send()
        }
        pauseObserver = NotificationCenter.default.addObserver(forName: .graphSimulationPause, object: nil, queue: .main) { [weak self] _ in
            self?.model.pauseSimulation()
        }
        resumeObserver = NotificationCenter.default.addObserver(forName: .graphSimulationResume, object: nil, queue: .main) { [weak self] _ in
            self?.resumeSimulationAfterDelay()
        }
        
        // Call new methods to load on init (preserves original behavior without duplication)
        loadGraph()
        loadViewState()
    }
    
    // New method to save (call from views)
    func saveViewState() {
        saveTimer?.invalidate()
        saveTimer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: false) { [weak self] _ in
            guard let self = self else { return }
            print("Debounced save: selectedNodeID = \(self.selectedNodeID?.uuidString ?? "nil")")  // Optional debug
            try? self.model.saveViewState(offset: self.offset, zoomScale: self.zoomScale, selectedNodeID: self.selectedNodeID, selectedEdgeID: self.selectedEdgeID)
        }
    }
    
    // Added: Reloads graph data from storage (mirrors init logic)
    func loadGraph() {
        do {
            try model.loadFromStorage()  // Use public wrapper (avoids private 'storage' access)
        } catch {
            print("Load graph failed: \(error.localizedDescription)")  // Or log as in model
        }
        objectWillChange.send()
    }
    
    // Added: Loads and applies view state (extracted from original init)
    func loadViewState() {
        if let state = try? model.loadViewState() {
            print("Loaded view state: selectedNodeID = \(state.selectedNodeID?.uuidString ?? "nil")")
            self.offset = state.offset
            self.zoomScale = state.zoomScale
            self.selectedNodeID = state.selectedNodeID
            self.selectedEdgeID = state.selectedEdgeID
            self.objectWillChange.send()  // Refresh views with loaded selection
        }
        
        print("Loaded ID: \(selectedNodeID?.uuidString ?? "nil"), Node exists? \(model.nodes.contains { $0.id == selectedNodeID ?? UUID() })")  // Adjust to unwrap
    }
    
    deinit {
        // Clean up to avoid leaks
        if let pauseObserver = pauseObserver {
            NotificationCenter.default.removeObserver(pauseObserver)
        }
        if let resumeObserver = resumeObserver {
            NotificationCenter.default.removeObserver(resumeObserver)
        }
        resumeTimer?.invalidate()
    }
    
    func snapshot() {
        model.snapshot()
    }
    
    func undo() {
        model.undo()
    }
    
    func redo() {
        model.redo()
    }
    
    func deleteNode(withID id: NodeID) {
        model.deleteNode(withID: id)
    }
    
    func deleteSelectedEdge(id: UUID?) {
        model.deleteSelectedEdge(id: id)
    }
    
    func addNode(at position: CGPoint) {
        model.addNode(at: position)
    }
    
    func updateNode(_ updatedNode: any NodeProtocol) {
        model.updateNode(updatedNode)
    }
    
    func addToggleNode(at position: CGPoint) {
        model.addToggleNode(at: position)
    }
    
    func addChild(to parentID: NodeID) {
        model.addChild(to: parentID)
    }
    
    func clearGraph() {
        model.clearGraph()
    }
    
    func pauseSimulation() {
        model.pauseSimulation()
    }
    
    func resumeSimulation() {
        model.resumeSimulation()
    }
    
    // New: Debounced resume with app state check
    func resumeSimulationAfterDelay() {
        resumeTimer?.invalidate()
        resumeTimer = Timer.scheduledTimer(withTimeInterval: 0.3, repeats: false) { [weak self] _ in
            guard let self = self else { return }
            if WKApplication.shared().applicationState == .active {
                self.model.resumeSimulation()
            }
        }
    }
    
    func handleTap() {  // Call this before/after selection in gesture
        model.pauseSimulation()
        resumeSimulationAfterDelay()  // Use debounced method
    }
}
--------------------------------------------------
--------------------------------------------------
File: ContentView.swift
Path: GraphEditorWatch/Views/ContentView.swift
Last modified: 2025-08-21 11:48:26

Contents:
//  ContentView.swift
//  GraphEditor
//
//  Created by handcart on 8/1/25.

import SwiftUI
import WatchKit
import GraphEditorShared
import Foundation
import CoreGraphics  // For CGRect in clampOffset

struct NodeWrapper: Equatable {
    var node: (any NodeProtocol)?
    static func == (lhs: NodeWrapper, rhs: NodeWrapper) -> Bool {
        lhs.node?.id == rhs.node?.id
    }
}

struct InnerViewConfig {
    let geo: GeometryProxy
    let viewModel: GraphViewModel
    let zoomScale: Binding<CGFloat>
    let offset: Binding<CGSize>
    let draggedNode: Binding<NodeWrapper>
    let dragOffset: Binding<CGPoint>
    let potentialEdgeTarget: Binding<NodeWrapper>
    let panStartOffset: Binding<CGSize?>
    let showMenu: Binding<Bool>
    let showOverlays: Binding<Bool>
    let maxZoom: CGFloat
    let crownPosition: Binding<Double>
    let updateZoomRangesHandler: () -> Void
    let selectedNodeID: Binding<NodeID?>
    let selectedEdgeID: Binding<UUID?>
    let canvasFocus: FocusState<Bool>.Binding
    let onCenterGraph: () -> Void
}

struct ContentView: View {
    @StateObject var viewModel: GraphViewModel
    @State private var zoomScale: CGFloat = 1.0
    @State private var offset: CGSize = .zero
    @State private var draggedNode: NodeWrapper = NodeWrapper(node: nil)
    @State private var dragOffset: CGPoint = .zero
    @State private var potentialEdgeTarget: NodeWrapper = NodeWrapper(node: nil)
    @State private var panStartOffset: CGSize? = nil
    @State private var showMenu: Bool = false
    @State private var showOverlays = false
    @State private var minZoom: CGFloat = 0.1
    @State private var maxZoom: CGFloat = 2.5
    @State private var crownPosition: Double = 0.5
    @State private var ignoreNextCrownChange: Bool = false
    @State private var isZooming: Bool = false
    @Environment(\.scenePhase) private var scenePhase
    @State private var previousCrownPosition: Double = 0.5
    @State private var clampTimer: Timer?
    @State private var resumeTimer: Timer? = nil
    @State private var logOffsetChanges = true
    @State private var isPanning: Bool = false
    @State private var zoomTimer: Timer? = nil
    @State private var isLoaded: Bool = false
    @State private var previousSelection: (NodeID?, UUID?) = (nil, nil)
    @State private var viewSize: CGSize = .zero
    @FocusState private var isCanvasFocused: Bool
    
    init(storage: GraphStorage = PersistenceManager(),
         physicsEngine: PhysicsEngine = PhysicsEngine(simulationBounds: WKInterfaceDevice.current().screenBounds.size)) {
        let model = GraphModel(storage: storage, physicsEngine: physicsEngine)
        _viewModel = StateObject(wrappedValue: GraphViewModel(model: model))
    }
    
    private func recenterOn(position: CGPoint) {
        let centroid = viewModel.effectiveCentroid
        let targetOffsetX = -(position.x - centroid.x) * zoomScale
        let targetOffsetY = -(position.y - centroid.y) * zoomScale
        withAnimation {
            offset = CGSize(width: targetOffsetX, height: targetOffsetY)
        }
    }
    
    private func adjustedOffset(for newZoom: CGFloat, currentCenter: CGPoint) -> CGSize {
        let newOffsetX = -(currentCenter.x - viewSize.width / (2 * newZoom)) * newZoom
        let newOffsetY = -(currentCenter.y - viewSize.height / (2 * newZoom)) * newZoom
        print("Adjusted offset to preserve center: (\(newOffsetX), \(newOffsetY))")
        return CGSize(width: newOffsetX, height: newOffsetY)
    }
    
    private func clampOffset(animate: Bool = true) {
        let oldOffset = offset
        let graphBounds = viewModel.model.physicsEngine.boundingBox(nodes: viewModel.model.nodes)
        let scaledWidth = (graphBounds.width * zoomScale).rounded(to: 2)
        let scaledHeight = (graphBounds.height * zoomScale).rounded(to: 2)
        let effectiveViewWidth = viewSize.width
        let effectiveViewHeight = viewSize.height
        let extraPadding: CGFloat = 200.0  // Large: Allow off-screen panning
        let panRoomX = max(0, (scaledWidth - effectiveViewWidth) / 2 + extraPadding)
        let panRoomY = max(0, (scaledHeight - effectiveViewHeight) / 2 + extraPadding)
        let threshold: CGFloat = 100.0  // Higher: Only clamp if far off
        
        var clampedX = offset.width
        var clampedY = offset.height
        
        // Skip clamp if zoomed out (allow free pan)
        if scaledWidth < effectiveViewWidth || scaledHeight < effectiveViewHeight {
            // Only force center if extremely off (e.g., graph invisible)
            if abs(offset.width) > effectiveViewWidth || abs(offset.height) > effectiveViewHeight {
                clampedX = 0
                clampedY = 0
            }
        } else if abs(offset.width) > panRoomX + threshold {
            clampedX = offset.width.clamped(to: -panRoomX...panRoomX).rounded(to: 2)
        } else if abs(offset.height) > panRoomY + threshold {
            clampedY = offset.height.clamped(to: -panRoomY...panRoomY).rounded(to: 2)
        }
        
        let newOffset = CGSize(width: clampedX, height: clampedY)
        if animate {
            withAnimation(.easeOut(duration: 0.2)) {
                offset = newOffset
            }
        } else {
            offset = newOffset
        }
        if logOffsetChanges && (abs(offset.width - oldOffset.width) > 0.01 || abs(offset.height - oldOffset.height) > 0.01) {
            print("ClampOffset adjusted from width \(oldOffset.width), height \(oldOffset.height) to width \(offset.width), height \(offset.height). Triggered by deselection? \(viewModel.selectedNodeID == nil && viewModel.selectedEdgeID == nil)")
        }
    }
    private func onUpdateZoomRanges() {
        let graphBounds = viewModel.model.physicsEngine.boundingBox(nodes: viewModel.model.nodes)
        let padding: CGFloat = 20.0
        let contentWidth = graphBounds.width + padding * 2
        let contentHeight = graphBounds.height + padding * 2
        maxZoom = 2.5
        zoomScale = zoomScale.clamped(to: minZoom...maxZoom)
        clampOffset()
    }
        
    var body: some View {
        GeometryReader { geo in
            let config = InnerViewConfig(
                geo: geo,
                viewModel: viewModel,
                zoomScale: $zoomScale,
                offset: $offset,
                draggedNode: $draggedNode,
                dragOffset: $dragOffset,
                potentialEdgeTarget: $potentialEdgeTarget,
                panStartOffset: $panStartOffset,
                showMenu: $showMenu,
                showOverlays: $showOverlays,
                maxZoom: maxZoom,
                crownPosition: $crownPosition,
                updateZoomRangesHandler: { onUpdateZoomRanges() },
                selectedNodeID: $viewModel.selectedNodeID,  // Assuming @Published
                selectedEdgeID: $viewModel.selectedEdgeID,  // Assuming @Published
                canvasFocus: _isCanvasFocused,
                onCenterGraph: {
                    recenterOn(position: viewModel.effectiveCentroid)
                    clampOffset()
                }
            )
            InnerView(config: config)
        }
        .overlay(alignment: .bottom) {
            Button {
                showMenu.toggle()
            } label: {
                Image(systemName: showMenu ? "point.3.filled.connected.trianglepath.dotted" : "line.3.horizontal")
                    .font(.system(size: 24))
                    .foregroundColor(.primary)
                    .frame(width: 44, height: 44)
                    .background(Color.gray.opacity(0.1))  // Subtle fill; remove for full transparency
                    .clipShape(Circle())
                    .contentShape(Circle())  // Circular tappable area
            }
            .buttonStyle(.plain)  // Removes default padding/background
            .padding(.bottom, 8)  // Space from bottom edge
        }
        .onAppear {
            viewSize = WKInterfaceDevice.current().screenBounds.size
        }
        .onChange(of: scenePhase) { newPhase in
            if newPhase == .active {
                viewModel.resumeSimulationAfterDelay()
            } else if newPhase == .inactive {
                viewModel.pauseSimulation()
            }
        }
        .onChange(of: viewModel.model.nodes.count) { _ in
            onUpdateZoomRanges()
        }
        .onChange(of: viewModel.selectedNodeID) { _ in
            if let id = viewModel.selectedNodeID, let node = viewModel.model.nodes.first(where: { $0.id == id }) {
                recenterOn(position: node.position)
                clampOffset()
            }
        }
        .onChange(of: viewModel.selectedEdgeID) { _ in
            guard let id = viewModel.selectedEdgeID else { return }
            guard let edge = viewModel.model.edges.first(where: { $0.id == id }) else { return }
            guard let from = viewModel.model.nodes.first(where: { $0.id == edge.from }) else { return }
            guard let to = viewModel.model.nodes.first(where: { $0.id == edge.to }) else { return }
            
            let mid = CGPoint(x: (from.position.x + to.position.x) / 2, y: (from.position.y + to.position.y) / 2)
            recenterOn(position: mid)
            clampOffset()
        }
        .focusable()
        .digitalCrownRotation($crownPosition, from: 0.0, through: 1.0, sensitivity: .low, isContinuous: true, isHapticFeedbackEnabled: true)
        .ignoresSafeArea()
        .onAppear {
            viewSize = WKInterfaceDevice.current().screenBounds.size
            isCanvasFocused = true  // Force focus on load
        }
        .onChange(of: showMenu) { newValue in
            print("Show menu changed to \(newValue)")
            if !newValue {
                isCanvasFocused = true  // Refocus canvas when menu closes
            }
        }
        .onChange(of: crownPosition) { newValue in
            print("Crown event received: \(newValue)")
            if ignoreNextCrownChange {
                ignoreNextCrownChange = false
                return
            }
            print("Crown position changed to \(newValue). Updating zoom.")
            onUpdateZoomRanges()  // Ensure min/max are up-to-date
            
            // Quantize to discrete levels
            // Exponential mapping for natural zoom (small rotations = fine control, large = fast zoom)
            let zoomSensitivity: CGFloat = 2.0  // Adjust: higher = faster zoom per rotation
            let normalized = CGFloat(newValue)  // 0.0 to 1.0 from crown
            let newZoom = minZoom * pow(maxZoom / minZoom, normalized * zoomSensitivity)
            let clampedNewZoom = newZoom.clamped(to: minZoom...maxZoom).rounded(to: 3)
            
            // Pause simulation
            viewModel.model.isSimulating = false
            viewModel.model.stopSimulation()
            
            // Preserve center: Get model point at screen center before zoom
            let screenCenter = CGPoint(x: viewSize.width / 2, y: viewSize.height / 2)
            let preZoomModelCenter = CGPoint(
                x: ((screenCenter.x - offset.width) / zoomScale + viewModel.effectiveCentroid.x).rounded(to: 2),
                y: ((screenCenter.y - offset.height) / zoomScale + viewModel.effectiveCentroid.y).rounded(to: 2)
            )
            
            // Temporarily set new zoom
            let oldZoom = zoomScale
            zoomScale = clampedNewZoom
            
            // Adjust offset to keep preZoomModelCenter at screen center
            let newOffsetX = (screenCenter.x - (preZoomModelCenter.x - viewModel.effectiveCentroid.x) * newZoom).rounded(to: 2)
            let newOffsetY = (screenCenter.y - (preZoomModelCenter.y - viewModel.effectiveCentroid.y) * newZoom).rounded(to: 2)
            
            withAnimation(.easeInOut(duration: 0.25)) {
                offset = CGSize(width: newOffsetX, height: newOffsetY)
                zoomScale = newZoom
            }
            
            // Clamp only if significant change, after animation
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                let oldOffset = offset
                clampOffset()
                // Skip log/clamp if change is tiny (precision noise)
                if abs(offset.width - oldOffset.width) < 0.01 && abs(offset.height - oldOffset.height) < 0.01 {
                    offset = oldOffset  // Revert micro-adjustment
                }
            }
            
            isZooming = true
            zoomTimer?.invalidate()
            zoomTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: false) { _ in  // Longer debounce
                isZooming = false
                viewModel.model.isSimulating = true
                viewModel.model.startSimulation()
            }
        }        .onChange(of: isCanvasFocused) { newValue in
            print("Canvas focus changed to \(newValue)")  // Debug focus state
        }
    }
}

extension CGFloat {
    func clamped(to range: ClosedRange<CGFloat>) -> CGFloat {
        Swift.max(range.lowerBound, Swift.min(self, range.upperBound))
    }
}

#Preview {
    ContentView()
}

struct InnerView: View {
    let config: InnerViewConfig
    
    var body: some View {
        let draggedNodeBinding = Binding<(any NodeProtocol)?>(
            get: { config.draggedNode.wrappedValue.node },
            set: { config.draggedNode.wrappedValue = NodeWrapper(node: $0) }
        )
        let potentialEdgeTargetBinding = Binding<(any NodeProtocol)?>(
            get: { config.potentialEdgeTarget.wrappedValue.node },
            set: { config.potentialEdgeTarget.wrappedValue = NodeWrapper(node: $0) }
        )
        let isSimulatingBinding = Binding.constant(config.viewModel.model.isSimulating)
        
        let canvasView: some View = GraphCanvasView(
            viewModel: config.viewModel,
            zoomScale: config.zoomScale,
            offset: config.offset,
            draggedNode: draggedNodeBinding,
            dragOffset: config.dragOffset,
            potentialEdgeTarget: potentialEdgeTargetBinding,
            selectedNodeID: config.selectedNodeID,
            viewSize: config.geo.size,
            panStartOffset: config.panStartOffset,
            showMenu: config.showMenu,
            maxZoom: config.maxZoom,
            crownPosition: config.crownPosition,
            onUpdateZoomRanges: config.updateZoomRangesHandler,
            selectedEdgeID: config.selectedEdgeID,
            showOverlays: config.showOverlays
        )
        .accessibilityIdentifier("GraphCanvas")
        .focused(config.canvasFocus)
        .focusable(true)

         if config.showMenu.wrappedValue {
             MenuView(
                 viewModel: config.viewModel,
                 showOverlays: config.showOverlays,
                 showMenu: config.showMenu,
                 onCenterGraph: config.onCenterGraph
             )
             .navigationTitle("Menu")  // Optional: Improve navigation
         } else {
             canvasView
         }
    }
}
--------------------------------------------------
--------------------------------------------------
File: GraphCanvasView.swift
Path: GraphEditorWatch/Views/GraphCanvasView.swift
Last modified: 2025-08-21 11:05:33

Contents:
import SwiftUI
import WatchKit
import GraphEditorShared

// New: Custom wrapper for reliable crown focus
struct FocusableView<Content: View>: View {
    let content: Content
    @FocusState private var isFocused: Bool
    
    init(@ViewBuilder content: () -> Content) {
        self.content = content()
    }
    
    var body: some View {
        content
            .focused($isFocused)
            .onAppear {
                isFocused = true
            }
            .onChange(of: isFocused) { oldValue, newValue in  // Or just { _, newValue in
                if newValue {
                    print("View focused for crown")  // Optional debug
                }
            }
        
    }
    
}

/* Remove if possible
class CrownHandler: NSObject, ObservableObject, WKCrownDelegate {
    @Published var accumulator: Double = 0.0
    
    func crownDidRotate(_ crownSequencer: WKCrownSequencer?, rotationalDelta: Double) {
        accumulator += Double(rotationalDelta) * 10.0  // Sensitivity; adjust
    }
}
*/

struct GraphCanvasView: View {
    let viewModel: GraphViewModel
    @Binding var zoomScale: CGFloat
    @Binding var offset: CGSize
    @Binding var draggedNode: (any NodeProtocol)?
    @Binding var dragOffset: CGPoint
    @Binding var potentialEdgeTarget: (any NodeProtocol)?
    @Binding var selectedNodeID: NodeID?
    let viewSize: CGSize
    @Binding var panStartOffset: CGSize?
    @Binding var showMenu: Bool
    let maxZoom: CGFloat
    @Binding var crownPosition: Double
    let onUpdateZoomRanges: () -> Void
    @State private var previousZoomScale: CGFloat = 1.0
    @State private var zoomTimer: Timer? = nil
    @Binding var selectedEdgeID: UUID?
    @Binding var showOverlays: Bool
    
    init(
        viewModel: GraphViewModel,
        zoomScale: Binding<CGFloat>,
        offset: Binding<CGSize>,
        draggedNode: Binding<(any NodeProtocol)?>,
        dragOffset: Binding<CGPoint>,
        potentialEdgeTarget: Binding<(any NodeProtocol)?>,
        selectedNodeID: Binding<NodeID?>,
        viewSize: CGSize,
        panStartOffset: Binding<CGSize?>,
        showMenu: Binding<Bool>,
        maxZoom: CGFloat,
        crownPosition: Binding<Double>,
        onUpdateZoomRanges: @escaping () -> Void,
        selectedEdgeID: Binding<UUID?>,
        showOverlays: Binding<Bool>
    ) {
        self.viewModel = viewModel
        _zoomScale = zoomScale
        _offset = offset
        _draggedNode = draggedNode
        _dragOffset = dragOffset
        _potentialEdgeTarget = potentialEdgeTarget
        _selectedNodeID = selectedNodeID
        self.viewSize = viewSize
        _panStartOffset = panStartOffset
        _showMenu = showMenu
        self.maxZoom = maxZoom
        _crownPosition = crownPosition
        self.onUpdateZoomRanges = onUpdateZoomRanges
        _selectedEdgeID = selectedEdgeID
        _showOverlays = showOverlays
    }
    
    
    // Define zoomLevels array
    private let zoomLevels: [CGFloat] = {
        let minZoom: CGFloat = 0.5
        let maxZoom: CGFloat = 2.5
        let steps = Constants.App.numZoomLevels
        let stepSize = (maxZoom - minZoom) / CGFloat(steps - 1)
        return (0..<steps).map { minZoom + CGFloat($0) * stepSize }
    }()
    
    // Define simulationBounds
    private let simulationBounds: CGSize = CGSize(width: 300, height: 300)  // Match PhysicsEngine bounds
    
    // Clamp function to cap extreme offsets
    private func clampOffset(_ offset: CGSize) -> CGSize {
        let maxOffset: CGFloat = 500.0  // Arbitrary cap; adjust based on graph size
        return CGSize(
            width: max(-maxOffset, min(offset.width, maxOffset)),
            height: max(-maxOffset, min(offset.height, maxOffset))
        )
    }
    
    private func displayPosition(for worldPos: CGPoint, effectiveCentroid: CGPoint, panOffset: CGPoint, viewCenter: CGPoint) -> CGPoint {
        let relative = CGPoint(x: worldPos.x - effectiveCentroid.x, y: worldPos.y - effectiveCentroid.y)
        let scaled = CGPoint(x: relative.x * zoomScale, y: relative.y * zoomScale)
        return CGPoint(x: scaled.x + viewCenter.x + panOffset.x, y: scaled.y + viewCenter.y + panOffset.y)
    }
    
    private var canvasBase: some View {
        GeometryReader { geometry in
            let viewSize = geometry.size
            let viewCenter = CGPoint(x: viewSize.width / 2, y: viewSize.height / 2)
            let panOffset = CGPoint(x: offset.width, y: offset.height)
            let visibleNodes = viewModel.model.visibleNodes()
            
            let effectiveCentroid = computeEffectiveCentroid(visibleNodes: visibleNodes)
            
            let visibleRect = computeVisibleRect(panOffset: panOffset, effectiveCentroid: effectiveCentroid, viewCenter: viewCenter, viewSize: viewSize)
            
            let culledNodes = cullNodes(visibleNodes: visibleNodes, visibleRect: visibleRect)
            
            let culledEdges = cullEdges(visibleEdges: viewModel.model.visibleEdges(), culledNodes: culledNodes, visibleRect: visibleRect)
            
            ZStack {
                Circle()
                    .fill(Color.gray.opacity(0.2))
                    .frame(width: min(viewSize.width, viewSize.height) * 0.4,
                           height: min(viewSize.width, viewSize.height) * 0.4)
                    
                    // Render nodes as Views for transitions
                    ForEach(culledNodes, id: \.id) { node in
                        let isDragged = draggedNode?.id == node.id
                        let worldPos = isDragged ? CGPoint(x: node.position.x + dragOffset.x, y: node.position.y + dragOffset.y) : node.position
                        NodeView(node: node, isSelected: selectedNodeID == node.id, zoomScale: zoomScale)
                            .position(displayPosition(for: worldPos, effectiveCentroid: effectiveCentroid, panOffset: panOffset, viewCenter: viewCenter))  // Use worldPos
                            .transition(.asymmetric(
                                insertion: .scale(scale: 0.1, anchor: .center).combined(with: .opacity),
                                removal: .opacity
                            ))
                            .animation(.easeInOut(duration: 0.3), value: node.id)  // Trigger on appearance/change
                    }
                    
                    // Keep edges in Canvas for performance, but add animation for sync
                    Canvas { context, _ in
                        drawEdges(in: context, culledEdges: culledEdges, effectiveCentroid: effectiveCentroid, panOffset: panOffset, viewCenter: viewCenter)
                        
                        if let dragged = draggedNode, let target = potentialEdgeTarget {
                            let fromPos = CGPoint(x: dragged.position.x + dragOffset.x, y: dragged.position.y + dragOffset.y)
                            let toPos = target.position
                            let fromDisplay = displayPosition(for: fromPos, effectiveCentroid: effectiveCentroid, panOffset: panOffset, viewCenter: viewCenter)
                            let toDisplay = displayPosition(for: toPos, effectiveCentroid: effectiveCentroid, panOffset: panOffset, viewCenter: viewCenter)
                            context.stroke(Path { path in
                                path.move(to: fromDisplay)
                                path.addLine(to: toDisplay)
                            }, with: .color(.green), style: StrokeStyle(lineWidth: 2.0, dash: [5.0]))
                        }
                    }
                    .drawingGroup()
                    .animation(.easeInOut(duration: 0.3), value: culledEdges.map { $0.id })  // Sync animation with edge IDs
                    
                    if showOverlays {
                        overlaysView(visibleNodes: visibleNodes, effectiveCentroid: effectiveCentroid, panOffset: panOffset, viewCenter: viewCenter)
                    }
                }
                .frame(width: geometry.size.width, height: geometry.size.height)
                .offset(x: offset.width, y: offset.height)
                .scaleEffect(zoomScale)
                .offset(x: offset.width, y: offset.height)
             
        }
        .ignoresSafeArea()
        .onAppear {
            print("showMenu on appear: \(showMenu)")  // Should print false
        }
    }
    
    private func computeEffectiveCentroid(visibleNodes: [any NodeProtocol]) -> CGPoint {
        if let selectedID = selectedNodeID, let selected = visibleNodes.first(where: { $0.id == selectedID }) {
            return selected.position
        } else if let selectedEdge = selectedEdgeID, let edge = viewModel.model.edges.first(where: { $0.id == selectedEdge }),
                  let from = visibleNodes.first(where: { $0.id == edge.from }), let to = visibleNodes.first(where: { $0.id == edge.to }) {
            return CGPoint(x: (from.position.x + to.position.x) / 2, y: (from.position.y + to.position.y) / 2)
        }
        return visibleNodes.centroid() ?? .zero
    }
    
    private func computeVisibleRect(panOffset: CGPoint, effectiveCentroid: CGPoint, viewCenter: CGPoint, viewSize: CGSize) -> CGRect {
        let originX = effectiveCentroid.x + (-viewCenter.x - panOffset.x) / zoomScale
        let originY = effectiveCentroid.y + (-viewCenter.y - panOffset.y) / zoomScale
        let worldWidth = viewSize.width / zoomScale
        let worldHeight = viewSize.height / zoomScale
        let visibleRect = CGRect(x: originX, y: originY, width: worldWidth, height: worldHeight)
        
        let bufferWorld = 50.0 / zoomScale
        return visibleRect.insetBy(dx: -bufferWorld, dy: -bufferWorld)
    }
    
    private func cullNodes(visibleNodes: [any NodeProtocol], visibleRect: CGRect) -> [any NodeProtocol] {
        visibleNodes.filter { node in
            let buffer = node.radius / 2
            let nodeRectOrigin = CGPoint(x: node.position.x - (node.radius + buffer), y: node.position.y - (node.radius + buffer))
            let nodeRectSize = CGSize(width: (node.radius + buffer) * 2, height: (node.radius + buffer) * 2)
            let nodeRect = CGRect(origin: nodeRectOrigin, size: nodeRectSize)
            return visibleRect.intersects(nodeRect)
        }
    }
    
    private func cullEdges(visibleEdges: [GraphEdge], culledNodes: [any NodeProtocol], visibleRect: CGRect) -> [GraphEdge] {
        visibleEdges.filter { edge in
            guard let fromNode = viewModel.model.nodes.first(where: { $0.id == edge.from }),
                  let toNode = viewModel.model.nodes.first(where: { $0.id == edge.to }) else { return false }
            let bufferWorld = 10.0 / zoomScale
            let minX = min(fromNode.position.x, toNode.position.x) - bufferWorld
            let minY = min(fromNode.position.y, toNode.position.y) - bufferWorld
            let width = abs(fromNode.position.x - toNode.position.x) + 2 * bufferWorld
            let height = abs(fromNode.position.y - toNode.position.y) + 2 * bufferWorld
            let lineRect = CGRect(x: minX, y: minY, width: width, height: height)
            return visibleRect.intersects(lineRect)
        }
    }
    
    private func drawEdges(in context: GraphicsContext, culledEdges: [GraphEdge], effectiveCentroid: CGPoint, panOffset: CGPoint, viewCenter: CGPoint) {
        var processedEdges = Set<UUID>()  // Avoid duplicate bidirectional draws
        
        for edge in culledEdges {
            if processedEdges.contains(edge.id) { continue }
            processedEdges.insert(edge.id)
            
            guard let fromNode = viewModel.model.nodes.first(where: { $0.id == edge.from }),
                  let toNode = viewModel.model.nodes.first(where: { $0.id == edge.to }) else { continue }
            
            let fromPos = (draggedNode?.id == fromNode.id ? CGPoint(x: fromNode.position.x + dragOffset.x, y: fromNode.position.y + dragOffset.y) : fromNode.position)
            let toPos = (draggedNode?.id == toNode.id ? CGPoint(x: toNode.position.x + dragOffset.x, y: toNode.position.y + dragOffset.y) : toNode.position)
            
            let fromDisplay = displayPosition(for: fromPos, effectiveCentroid: effectiveCentroid, panOffset: panOffset, viewCenter: viewCenter)
            let toDisplay = displayPosition(for: toPos, effectiveCentroid: effectiveCentroid, panOffset: panOffset, viewCenter: viewCenter)
            
            let direction = CGPoint(x: toDisplay.x - fromDisplay.x, y: toDisplay.y - fromDisplay.y)
            let length = hypot(direction.x, direction.y)
            if length <= 0 { continue }
            
            let unitDir = CGPoint(x: direction.x / length, y: direction.y / length)
            let scaledFromRadius = fromNode.radius * zoomScale + 2  // Slight inset
            let scaledToRadius = toNode.radius * zoomScale + 2
            let lineStart = CGPoint(x: fromDisplay.x + unitDir.x * scaledFromRadius, y: fromDisplay.y + unitDir.y * scaledFromRadius)
            let lineEnd = CGPoint(x: toDisplay.x - unitDir.x * scaledToRadius, y: toDisplay.y - unitDir.y * scaledToRadius)
            
            let isSelected = edge.id == selectedEdgeID
            let lineWidth = isSelected ? 4.0 : 2.0
            let color = isSelected ? Color.red : Color.blue
            
            // Bidirectional check
            if let reverseEdge = viewModel.model.edges.first(where: { $0.from == edge.to && $0.to == edge.from }) {
                processedEdges.insert(reverseEdge.id)  // Skip reverse
                
                // Draw two curved lines
                let midPoint = CGPoint(x: (fromDisplay.x + toDisplay.x) / 2, y: (fromDisplay.y + toDisplay.y) / 2)
                let perpDir = CGPoint(x: -unitDir.y * (8.0 * zoomScale), y: unitDir.x * (8.0 * zoomScale))  // Break up
                let control1 = CGPoint(x: midPoint.x + perpDir.x, y: midPoint.y + perpDir.y)
                context.stroke(Path { path in
                    path.move(to: lineStart)
                    path.addQuadCurve(to: lineEnd, control: control1)
                }, with: .color(color), style: StrokeStyle(lineWidth: lineWidth, lineJoin: .round))
                drawArrowhead(in: context, at: lineEnd, direction: unitDir, size: 8.0 * min(zoomScale, 1.0), color: color)
                
                // Reverse curve (opposite offset)
                let control2 = CGPoint(x: midPoint.x - perpDir.x, y: midPoint.y - perpDir.y)
                let revStart = CGPoint(x: toDisplay.x - unitDir.x * scaledToRadius, y: toDisplay.y - unitDir.y * scaledToRadius)
                let revEnd = CGPoint(x: fromDisplay.x + unitDir.x * scaledFromRadius, y: fromDisplay.y + unitDir.y * scaledFromRadius)
                let revDir = CGPoint(x: -unitDir.x, y: -unitDir.y)
                context.stroke(Path { path in
                    path.move(to: revStart)
                    path.addQuadCurve(to: revEnd, control: control2)
                }, with: .color(color), style: StrokeStyle(lineWidth: lineWidth, lineJoin: .round))
                drawArrowhead(in: context, at: revEnd, direction: revDir, size: 8.0 * min(zoomScale, 1.0), color: color)
                if isSelected {
                    let midpoint = midPoint
                    let fromLabel = fromNode.label
                    let toLabel = toNode.label
                    let edgeLabel = "\(min(fromLabel, toLabel))↔\(max(fromLabel, toLabel))"  // Combined bidirectional label
                    let fontSize = max(8.0, 12.0 * zoomScale)  // Min size for readability
                    let text = Text(edgeLabel).foregroundColor(.white).font(.system(size: fontSize))
                    context.draw(context.resolve(text), at: midpoint, anchor: .center)
                }
            } else {
                // Single straight line
                context.stroke(Path { path in
                    path.move(to: lineStart)
                    path.addLine(to: lineEnd)
                }, with: .color(color), style: StrokeStyle(lineWidth: lineWidth, lineJoin: .round))
                drawArrowhead(in: context, at: lineEnd, direction: unitDir, size: 8.0 * min(zoomScale, 1.0), color: color)
            }
            
            if isSelected {
                let midpoint = CGPoint(x: (fromDisplay.x + toDisplay.x) / 2, y: (fromDisplay.y + toDisplay.y) / 2)
                let edgeLabel = "\(fromNode.label)→\(toNode.label)"
                let fontSize = max(8.0, 12.0 * zoomScale)  // Min size for readability
                let text = Text(edgeLabel).foregroundColor(.white).font(.system(size: fontSize))
                context.draw(context.resolve(text), at: midpoint, anchor: .center)
            }
        }
    }
    
    private func drawArrowhead(in context: GraphicsContext, at point: CGPoint, direction: CGPoint, size: CGFloat, color: Color) {
        let arrowSize = size * min(zoomScale, 1.0)  // Scale with zoom, cap at 1x
        let perpDir = CGPoint(x: -direction.y, y: direction.x)
        let arrowTip = point
        let arrowBase1X = arrowTip.x - direction.x * arrowSize + perpDir.x * (arrowSize / 2)
        let arrowBase1Y = arrowTip.y - direction.y * arrowSize + perpDir.y * (arrowSize / 2)
        let arrowBase1 = CGPoint(x: arrowBase1X, y: arrowBase1Y)
        let arrowBase2X = arrowTip.x - direction.x * arrowSize - perpDir.x * (arrowSize / 2)
        let arrowBase2Y = arrowTip.y - direction.y * arrowSize - perpDir.y * (arrowSize / 2)
        let arrowBase2 = CGPoint(x: arrowBase2X, y: arrowBase2Y)
        
        let arrowPath = Path { path in
            path.move(to: arrowTip)
            path.addLine(to: arrowBase1)
            path.addLine(to: arrowBase2)
            path.closeSubpath()
        }
        context.fill(arrowPath, with: .color(color), style: FillStyle(antialiased: true))
    }
    
    private func overlaysView(visibleNodes: [any NodeProtocol], effectiveCentroid: CGPoint, panOffset: CGPoint, viewCenter: CGPoint) -> some View {
        Group {
            if !visibleNodes.isEmpty {
                let modelBBox = viewModel.model.boundingBox()
                let minDisplay = displayPosition(for: CGPoint(x: modelBBox.minX, y: modelBBox.minY), effectiveCentroid: effectiveCentroid, panOffset: panOffset, viewCenter: viewCenter)
                let maxDisplay = displayPosition(for: CGPoint(x: modelBBox.maxX, y: modelBBox.maxY), effectiveCentroid: effectiveCentroid, panOffset: panOffset, viewCenter: viewCenter)
                let displayWidth = maxDisplay.x - minDisplay.x
                let displayHeight = maxDisplay.y - minDisplay.y
                let displayCenter = CGPoint(x: minDisplay.x + displayWidth / 2, y: minDisplay.y + displayHeight / 2)
                
                Rectangle()
                    .stroke(Color.blue, lineWidth: 1.0)
                    .frame(width: displayWidth, height: displayHeight)
                    .position(displayCenter)
            }
            
            if let centroid = visibleNodes.centroid() {
                let displayPos = displayPosition(for: centroid, effectiveCentroid: effectiveCentroid, panOffset: panOffset, viewCenter: viewCenter)
                Circle()
                    .fill(Color.yellow)
                    .frame(width: 4, height: 4)
                    .position(displayPos)
            }
            
            // New: Hierarchy indicators (dashed lines to hidden children)
            ForEach(viewModel.model.nodes.filter { !$0.isVisible && ($0 as? ToggleNode)?.isExpanded == false }, id: \.id) { hiddenNode in
                if let parentID = viewModel.model.edges.first(where: { $0.to == hiddenNode.id })?.from,
                   let parent = viewModel.model.nodes.first(where: { $0.id == parentID }) {
                    let fromDisplay = displayPosition(for: parent.position, effectiveCentroid: effectiveCentroid, panOffset: panOffset, viewCenter: viewCenter)
                    let toDisplay = displayPosition(for: hiddenNode.position, effectiveCentroid: effectiveCentroid, panOffset: panOffset, viewCenter: viewCenter)
                    Path { path in
                        path.move(to: fromDisplay)
                        path.addLine(to: toDisplay)
                    }
                    .stroke(Color.gray.opacity(0.5), style: StrokeStyle(lineWidth: 1.0, dash: [5.0]))
                }
            }
        }
    }
    
    private var interactiveCanvas: some View {
        canvasBase
    }
    
    private var accessibleCanvas: some View {
        interactiveCanvas
            .accessibilityElement(children: .combine)
            .accessibilityLabel(viewModel.model.graphDescription(selectedID: selectedNodeID, selectedEdgeID: selectedEdgeID))
            .accessibilityHint("Long press for menu. Tap to select.")
            .accessibilityChildren {
                ForEach(viewModel.model.visibleNodes(), id: \.id) { node in
                    Text("Node \(node.label) at (\(Int(node.position.x)), \(Int(node.position.y)))")
                        .accessibilityAction(named: "Select") {
                            selectedNodeID = node.id
                            WKInterfaceDevice.current().play(.click)
                        }
                }
            }
    }
    
    struct AnimatableEdge: Shape {
        var from: CGPoint
        var to: CGPoint
        
        var animatableData: AnimatablePair<CGPoint.AnimatableData, CGPoint.AnimatableData> {
            get { AnimatablePair(from.animatableData, to.animatableData) }
            set {
                from.animatableData = newValue.first
                to.animatableData = newValue.second
            }
        }
        
        func path(in rect: CGRect) -> Path {
            var path = Path()
            path.move(to: from)
            path.addLine(to: to)
            return path
        }
    }
    
    var body: some View {
        Group {
            accessibleCanvas
                .modifier(GraphGesturesModifier(
                    viewModel: viewModel,
                    zoomScale: $zoomScale,
                    offset: $offset,
                    draggedNode: $draggedNode,
                    dragOffset: $dragOffset,
                    potentialEdgeTarget: $potentialEdgeTarget,
                    selectedNodeID: $selectedNodeID,
                    selectedEdgeID: $selectedEdgeID,
                    viewSize: viewSize,
                    panStartOffset: $panStartOffset,
                    showMenu: $showMenu,
                    maxZoom: maxZoom,
                    crownPosition: $crownPosition,
                    onUpdateZoomRanges: onUpdateZoomRanges
                ))
        }
        .onChange(of: selectedNodeID) {
            viewModel.saveViewState()
        }
        .onChange(of: selectedEdgeID) {
            viewModel.saveViewState()
        }
        .ignoresSafeArea()
    }
}

extension Array where Element == any NodeProtocol {
    func centroid() -> CGPoint? {
        guard !isEmpty else { return nil }
        var totalX: CGFloat = 0.0
        var totalY: CGFloat = 0.0
        for node in self {
            totalX += node.position.x
            totalY += node.position.y
        }
        return CGPoint(x: totalX / CGFloat(count), y: totalY / CGFloat(count))
    }
}

extension CGRect {
    init(center: CGPoint, size: CGSize) {
        self.init(x: center.x - size.width / 2, y: center.y - size.height / 2, width: size.width, height: size.height)
    }
}
--------------------------------------------------
--------------------------------------------------
File: GraphGesturesModifier.swift
Path: GraphEditorWatch/Views/GraphGesturesModifier.swift
Last modified: 2025-08-21 10:41:58

Contents:
//
//  GraphGesturesModifier.swift
//  GraphEditorWatch
//
//  Created by handcart on 2025-08-16

import SwiftUI
import WatchKit
import GraphEditorShared

struct GraphGesturesModifier: ViewModifier {
    let viewModel: GraphViewModel
    @Binding var zoomScale: CGFloat
    @Binding var offset: CGSize
    @Binding var draggedNode: (any NodeProtocol)?
    @Binding var dragOffset: CGPoint
    @Binding var potentialEdgeTarget: (any NodeProtocol)?
    @Binding var selectedNodeID: NodeID?
    @Binding var selectedEdgeID: UUID?
    let viewSize: CGSize
    @Binding var panStartOffset: CGSize?
    @Binding var showMenu: Bool
    let maxZoom: CGFloat
    @Binding var crownPosition: Double
    let onUpdateZoomRanges: () -> Void
    
    @State private var dragStartNode: (any NodeProtocol)? = nil
    @State private var isMovingSelectedNode: Bool = false
    @State private var longPressTimer: Timer? = nil
    @State private var isLongPressTriggered: Bool = false
    @State private var hasStartedGesture: Bool = false
    @State private var dragTimer: Timer? = nil
    
    private let dragStartThreshold: CGFloat = 5.0
    
    
    private func screenToModel(_ screenPos: CGPoint, zoomScale: CGFloat, offset: CGSize, viewSize: CGSize) -> CGPoint {
        guard zoomScale > 0 else {
            print("Warning: Invalid zoomScale (\(zoomScale)) in screenToModel—returning .zero")
            return .zero  // Fallback to avoid crashes; adjust as needed
        }
        
        let viewCenter = CGPoint(x: viewSize.width / 2, y: viewSize.height / 2)
        let panOffset = CGPoint(x: offset.width, y: offset.height)
        let effectiveCentroid = focalPointForCentering()
        
        let translated = CGPoint(
            x: screenPos.x - viewCenter.x - panOffset.x,
            y: screenPos.y - viewCenter.y - panOffset.y
        )
        let unscaled = CGPoint(
            x: (translated.x / zoomScale).rounded(to: 2),  // Round for precision
            y: (translated.y / zoomScale).rounded(to: 2)
        )
        return CGPoint(
            x: (unscaled.x + effectiveCentroid.x).rounded(to: 2),
            y: (unscaled.y + effectiveCentroid.y).rounded(to: 2)
        )
    }
    
    private func focalPointForCentering() -> CGPoint {
        let visibleNodes = viewModel.model.visibleNodes()
        guard !visibleNodes.isEmpty else { return .zero }  // New: Guard against empty graph
        var effectiveCentroid = visibleNodes.centroid() ?? .zero
        if let selectedID = selectedNodeID, let selected = visibleNodes.first(where: { $0.id == selectedID }) {
            effectiveCentroid = selected.position
        } else if let selectedEdgeID = selectedEdgeID, let edge = viewModel.model.edges.first(where: { $0.id == selectedEdgeID }),
                  let from = visibleNodes.first(where: { $0.id == edge.from }), let to = visibleNodes.first(where: { $0.id == edge.to }) {
            effectiveCentroid = (from.position + to.position) / 2
        }
        return effectiveCentroid
    }
    
    func body(content: Content) -> some View {
        let dragGesture = DragGesture(minimumDistance: 0)
        
            .onChanged { value in
                if isLongPressTriggered { return }
                dragTimer?.invalidate()
                dragTimer = Timer.scheduledTimer(withTimeInterval: 0.016, repeats: false) { _ in
                    
                    // New: Define hit radius once at top for consistency
                    let screenHitRadius: CGFloat = Constants.App.hitScreenRadius  // Fixed on-screen size
                    let modelHitRadius = screenHitRadius / zoomScale  // Dynamic model-space conversion

                    let translationDistance = hypot(value.translation.width, value.translation.height)
                    let touchPos = screenToModel(value.location, zoomScale: zoomScale, offset: offset, viewSize: viewSize)

                    if dragStartNode == nil {
                        let startModelPos = screenToModel(value.startLocation, zoomScale: zoomScale, offset: offset, viewSize: viewSize)
                        if let hitNode = viewModel.model.nodes.first(where: { distance($0.position, startModelPos) < modelHitRadius }) {
                            dragStartNode = hitNode
                            isMovingSelectedNode = (hitNode.id == selectedNodeID)
                        }
                    }

                    if translationDistance > 0.0 {
                        hasStartedGesture = true
                    }

                    if translationDistance < 1.0 && longPressTimer == nil && hasStartedGesture {
                        longPressTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: false) { _ in
                            self.showMenu = true
                            WKInterfaceDevice.current().play(.click)
                            self.isLongPressTriggered = true
                            self.longPressTimer = nil
                        }
                        print("Long-press timer started")
                    }

                    if translationDistance < dragStartThreshold {
                        return
                    }

                    longPressTimer?.invalidate()
                    longPressTimer = nil
                        
                    if isMovingSelectedNode, let node = dragStartNode {
                        dragOffset = CGPoint(x: value.translation.width / zoomScale, y: value.translation.height / zoomScale)
                        draggedNode = node
                    } else {
                        if panStartOffset == nil {
                            panStartOffset = offset
                        }
                        offset = CGSize(width: panStartOffset!.width + value.translation.width,
                                        height: panStartOffset!.height + value.translation.height)
                    }
                    
                    potentialEdgeTarget = viewModel.model.nodes.first {
                        dragStartNode?.id != $0.id && distance($0.position, touchPos) < modelHitRadius  // Use consistent var
                    }
                    
                    // Diagnostic logs for .onChanged (unchanged)
                    let effectiveCentroid = focalPointForCentering()
                    let translated = CGPoint(x: value.location.x - viewSize.width / 2 - offset.width, y: value.location.y - viewSize.height / 2 - offset.height)
                    let unscaled = CGPoint(x: translated.x / zoomScale, y: translated.y / zoomScale)
                    print("--- .onChanged Diagnostic ---")
                    print("Effective Centroid: \(effectiveCentroid)")
                    print("Screen Pos: \(value.location)")
                    print("Translated: \(translated)")
                    print("Unscaled: \(unscaled)")
                    print("Model Pos (touchPos): \(touchPos)")
                    print("Visible Nodes Positions: \(viewModel.model.visibleNodes().map { $0.position })")
                    print("-----------------------------")
                
                    
                }
                return

                }
        
            .onEnded { value in
                hasStartedGesture = false
                if isLongPressTriggered {
                    isLongPressTriggered = false
                    longPressTimer?.invalidate()  // New: Explicit cleanup
                    longPressTimer = nil
                    return
                }
                
                longPressTimer?.invalidate()
                longPressTimer = nil
                
                viewModel.resumeSimulation()
                
                // New: Define hit radius once at top for consistency (with tap tolerance)
                let screenHitRadius: CGFloat = Constants.App.hitScreenRadius * 1.5  // Larger for taps
                let modelHitRadius = screenHitRadius / zoomScale  // Dynamic model-space

                let dragDistance = hypot(value.translation.width, value.translation.height)
                let tapModelPos = screenToModel(value.startLocation, zoomScale: zoomScale, offset: offset, viewSize: viewSize)
                
                if dragDistance < Constants.App.tapThreshold {
                    print("Tap detected at model position: \(tapModelPos). SelectedNodeID before: \(selectedNodeID?.uuidString ?? "nil"), SelectedEdgeID before: \(selectedEdgeID?.uuidString ?? "nil")")
                    
                    if let hitNode = viewModel.model.visibleNodes().first(where: { distance($0.position, tapModelPos) < modelHitRadius }) {
                        print("Node hit detected with tightened radius.")
                        selectedNodeID = (selectedNodeID == hitNode.id) ? nil : hitNode.id
                        selectedEdgeID = nil
                        WKInterfaceDevice.current().play(.click)
                    } else if let hitEdge = viewModel.model.visibleEdges().first(where: { edge in
                        if let from = viewModel.model.nodes.first(where: { $0.id == edge.from }),
                           let to = viewModel.model.nodes.first(where: { $0.id == edge.to }),
                           pointToLineDistance(point: tapModelPos, from: from.position, to: to.position) < modelHitRadius {  // Use consistent var
                            return true
                        }
                        return false
                    }) {
                        print("Edge hit detected with tightened radius.")
                        selectedEdgeID = (selectedEdgeID == hitEdge.id) ? nil : hitEdge.id
                        selectedNodeID = nil
                        WKInterfaceDevice.current().play(.click)
                    } else {
                        print("Background tap confirmed (no hit with tightened radius). Deselecting everything.")
                        selectedNodeID = nil
                        selectedEdgeID = nil
                    }
                    
                    print("SelectedNodeID after tap: \(selectedNodeID?.uuidString ?? "nil"), SelectedEdgeID after: \(selectedEdgeID?.uuidString ?? "nil")")
                    
                    // Diagnostic logs for tap in .onEnded (unchanged)
                    let effectiveCentroid = focalPointForCentering()
                    let translated = CGPoint(x: value.startLocation.x - viewSize.width / 2 - offset.width, y: value.startLocation.y - viewSize.height / 2 - offset.height)
                    let unscaled = CGPoint(x: translated.x / zoomScale, y: translated.y / zoomScale)
                    print("--- Tap (.onEnded) Diagnostic ---")
                    print("Effective Centroid: \(effectiveCentroid)")
                    print("Screen Pos: \(value.startLocation)")
                    print("Translated: \(translated)")
                    print("Unscaled: \(unscaled)")
                    print("Model Pos (tapModelPos): \(tapModelPos)")
                    print("Visible Nodes Positions: \(viewModel.model.visibleNodes().map { $0.position })")
                    print("--------------------------------")
                } else {
                    viewModel.snapshot()
                    if let startNode = dragStartNode, let target = potentialEdgeTarget, target.id != startNode.id {
                        let newEdge = GraphEdge(from: startNode.id, to: target.id)
                        if !viewModel.model.hasCycle(adding: newEdge) &&
                           !viewModel.model.edges.contains(where: { $0.from == startNode.id && $0.to == target.id }) {
                            viewModel.model.edges.append(newEdge)
                            viewModel.model.startSimulation()
                            WKInterfaceDevice.current().play(.success)
                        }
                    } else if isMovingSelectedNode, let node = dragStartNode,
                              let index = viewModel.model.nodes.firstIndex(where: { $0.id == node.id }) {
                        var updatedNode = viewModel.model.nodes[index]
                        updatedNode.position.x += value.translation.width / zoomScale
                        updatedNode.position.y += value.translation.height / zoomScale
                        viewModel.model.nodes[index] = updatedNode
                        viewModel.model.startSimulation()
                        WKInterfaceDevice.current().play(.click)
                    }
                    viewModel.handleTap()
                }
                
                withAnimation(.spring(duration: 0.3, bounce: 0.2)) {
                    onUpdateZoomRanges()
                }
                
                dragStartNode = nil
                isMovingSelectedNode = false
                draggedNode = nil
                dragOffset = .zero
                potentialEdgeTarget = nil
                panStartOffset = nil
                onUpdateZoomRanges()
            }
        content
            .gesture(dragGesture)
    }
    
    private func distance(_ p1: CGPoint, _ p2: CGPoint) -> CGFloat {
        hypot(p1.x - p2.x, p1.y - p2.y)
    }
    
    private func pointToLineDistance(point: CGPoint, from: CGPoint, to: CGPoint) -> CGFloat {
        let lineVec = to - from
        let pointVec = point - from
        let lineLen = hypot(lineVec.x, lineVec.y)
        if lineLen == 0 { return hypot(point.x - from.x, point.y - from.y) }
        let dot = pointVec.x * lineVec.x + pointVec.y * lineVec.y
        let denom = lineLen * lineLen
        let tUnclamped = dot / denom
        let t = max(0, min(1, tUnclamped))
        let projection = from + (lineVec * t)
        return hypot(point.x - projection.x, point.y - projection.y)
    }
}
--------------------------------------------------
--------------------------------------------------
File: MenuView.swift
Path: GraphEditorWatch/Views/MenuView.swift
Last modified: 2025-08-21 11:42:35

Contents:
//
//  MenuView.swift
//  GraphEditor
//
//  Created by handcart on 8/20/25.
//

import SwiftUI
import WatchKit
import GraphEditorShared

struct AddSection: View {
    let viewModel: GraphViewModel
    let selectedNodeID: NodeID?
    let onDismiss: () -> Void

    var body: some View {
        Section(header: Text("Add")) {
            Button("Add Node") {
                viewModel.addNode(at: .zero)
                onDismiss()
            }
            Button("Add Toggle Node") {
                viewModel.addToggleNode(at: .zero)
                onDismiss()
            }
            if let selectedID = selectedNodeID {
                Button("Add Child") {
                    viewModel.addChild(to: selectedID)
                    onDismiss()
                }
            }
        }
    }
}

struct EditSection: View {
    let viewModel: GraphViewModel
    let selectedNodeID: NodeID?
    let selectedEdgeID: UUID?
    let onDismiss: () -> Void

    var body: some View {
        Section(header: Text("Edit")) {
            if let selectedID = selectedNodeID {
                Button("Delete Node", role: .destructive) {
                    viewModel.deleteNode(withID: selectedID)
                    onDismiss()
                }
            }
            if let selectedEdgeID = selectedEdgeID,
               let selectedEdge = viewModel.model.edges.first(where: { $0.id == selectedEdgeID }) {
                let fromID = selectedEdge.from
                let toID = selectedEdge.to
                let isBi = viewModel.model.isBidirectionalBetween(fromID, toID)
                Button(isBi ? "Delete Both Edges" : "Delete Edge", role: .destructive) {
                    viewModel.snapshot()
                    if isBi {
                        let pair = viewModel.model.edgesBetween(fromID, toID)
                        viewModel.model.edges.removeAll { pair.contains($0) }
                    } else {
                        viewModel.model.edges.removeAll { $0.id == selectedEdgeID }
                    }
                    viewModel.model.startSimulation()
                    onDismiss()
                }
            }
            if viewModel.canUndo {
                Button("Undo") {
                    viewModel.undo()
                    onDismiss()
                }
            }
            if viewModel.canRedo {
                Button("Redo") {
                    viewModel.redo()
                    onDismiss()
                }
            }
        }
    }
}

struct ViewSection: View {
    @Binding var showOverlays: Bool
    @Binding var isSimulating: Bool  // Now a Binding for direct Toggle control
    let onCenterGraph: () -> Void
    let onDismiss: () -> Void
    let onSimulationChange: (Bool) -> Void  // New: Handles pause/resume logic

    var body: some View {
        Section(header: Text("View & Simulation")) {
            Toggle("Show Overlays", isOn: $showOverlays)
                .onChange(of: showOverlays) {
                    onDismiss()
                }

            Toggle("Run Simulation", isOn: $isSimulating)
                .onChange(of: isSimulating) { newValue in
                    onSimulationChange(newValue)
                    onDismiss()
                }
            Button("Center Graph") {
                onCenterGraph()
                onDismiss()
            }
        }
    }
}

struct GraphSection: View {
    let viewModel: GraphViewModel
    let onDismiss: () -> Void

    var body: some View {
        Section(header: Text("Graph")) {
            Button("Clear Graph", role: .destructive) {
                viewModel.clearGraph()
                onDismiss()
            }
        }
    }
}

struct MenuView: View {
    @ObservedObject var viewModel: GraphViewModel
    @Binding var showOverlays: Bool
    @Binding var showMenu: Bool
    let onCenterGraph: () -> Void
    
    private var isSimulatingBinding: Binding<Bool> {
        Binding(
            get: { viewModel.model.isSimulating },
            set: { viewModel.model.isSimulating = $0 }
        )
    }
    
    var body: some View {
        List {
            if viewModel.selectedEdgeID == nil {
                AddSection(viewModel: viewModel, selectedNodeID: viewModel.selectedNodeID, onDismiss: { showMenu = false })
            }
            
            if viewModel.selectedNodeID != nil || viewModel.selectedEdgeID != nil || viewModel.canUndo || viewModel.canRedo {
                EditSection(viewModel: viewModel, selectedNodeID: viewModel.selectedNodeID, selectedEdgeID: viewModel.selectedEdgeID, onDismiss: { showMenu = false })
            }
            
            ViewSection(
                showOverlays: $showOverlays,
                isSimulating: isSimulatingBinding,
                onCenterGraph: onCenterGraph, onDismiss: { showMenu = false },
                onSimulationChange: { newValue in
                    viewModel.model.isSimulating = newValue
                    if newValue {
                        viewModel.model.startSimulation()
                    } else {
                        viewModel.model.stopSimulation()
                    }
                }
            )
            
            GraphSection(viewModel: viewModel, onDismiss: { showMenu = false })
        }
        .navigationTitle("Graph Menu")  // Optional
        .ignoresSafeArea(.keyboard)
    }
}

#Preview {
    ContentView()
}
--------------------------------------------------
--------------------------------------------------
File: NodeView.swift
Path: GraphEditorWatch/Views/NodeView.swift
Last modified: 2025-08-16 10:12:42

Contents:
//
//  NodeView.swift
//  GraphEditor
//
//  Created by handcart on 8/13/25.
//

import SwiftUI
import GraphEditorShared


struct NodeView: View {
    let node: any NodeProtocol
    let isSelected: Bool
    let zoomScale: CGFloat
    
    var body: some View {
        ZStack {
            if isSelected {
                Circle()
                    .stroke(Color.yellow, lineWidth: 4 * zoomScale)
                    .frame(width: node.radius * 2 * zoomScale + 4 * zoomScale, height: node.radius * 2 * zoomScale + 4 * zoomScale)
            }
            Circle()
                .fill(node.fillColor)  // Or dynamic based on node type
                .frame(width: node.radius * 2 * zoomScale, height: node.radius * 2 * zoomScale)
            
            // Add icon/label as in ToggleNode.draw
            if let toggleNode = node as? ToggleNode {
                Text(toggleNode.isExpanded ? "-" : "+")
                    .foregroundColor(.white)
                    .font(.system(size: max(8.0, 12.0 * zoomScale), weight: .bold))
            }
            
            Text("\(node.label)")
                .foregroundColor(.white)
                .font(.system(size: max(8.0, 12.0 * zoomScale)))
                .offset(y: -(node.radius + 10) * zoomScale)  // Position above
        }
    }
}
--------------------------------------------------
--------------------------------------------------
File: GraphEditorWatchTests.swift
Path: GraphEditorWatchTests/GraphEditorWatchTests.swift
Last modified: 2025-08-18 10:07:03

Contents:
import Testing
import Foundation
import CoreGraphics
@testable import GraphEditorWatch // Already present
@testable import GraphEditorShared // Changed to @testable for accessing internal members
import XCTest
import SwiftUI

class MockGraphStorage: GraphStorage {
    var nodes: [any NodeProtocol] = []
    var edges: [GraphEdge] = []
    
    func save(nodes: [any NodeProtocol], edges: [GraphEdge]) throws {
        self.nodes = nodes
        self.edges = edges
    }
    
    func load() throws -> (nodes: [any NodeProtocol], edges: [GraphEdge]) {
        (nodes, edges)
    }
    
    func clear() throws {
        nodes = []
        edges = []
    }
}

// Add this helper function at the top of the test file or in the test struct
func approximatelyEqual(_ lhs: CGPoint, _ rhs: CGPoint, accuracy: CGFloat) -> Bool {
    return hypot(lhs.x - rhs.x, lhs.y - rhs.y) < accuracy
}

struct GraphModelTests {
    private func mockPhysicsEngine() -> GraphEditorShared.PhysicsEngine {
        GraphEditorShared.PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300)) // Mock size for tests
    }
    
    @Test func testUndoRedoMixedOperations() {
        let storage = MockGraphStorage()
        let model = GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        let initialNodeCount = model.nodes.count // 3
        let initialEdgeCount = model.edges.count // 3
        
        model.snapshot() // Snapshot 1: initial
        
        // Specify node to delete (e.g., first in cycle removes 2 edges)
        let nodeToDelete = model.nodes[0].id // Explicit
        let connectedEdges = model.edges.filter { $0.from == nodeToDelete || $0.to == nodeToDelete }.count // 2 in triangle
        model.deleteNode(withID: nodeToDelete) // Now 2n, 1e
        model.snapshot() // Snapshot 2: after delete
        
        model.addNode(at: CGPoint.zero) // Now 3n, 1e — no snapshot
        
        #expect(model.nodes.count == initialNodeCount, "After add: count back to initial")
        #expect(model.edges.count == initialEdgeCount - connectedEdges, "Edges reduced by connected count")
        
        model.undo() // To Snapshot 2: after delete
        #expect(model.nodes.count == initialNodeCount - 1, "Undo reverts to post-delete")
        #expect(model.edges.count == initialEdgeCount - connectedEdges, "Edges match post-delete")
        
        model.undo() // To Snapshot 1: initial
        #expect(model.nodes.count == initialNodeCount, "Second undo restores initial")
        #expect(model.edges.count == initialEdgeCount, "Edges restored")
        
        model.redo() // To post-delete
        #expect(model.nodes.count == initialNodeCount - 1, "Redo applies delete")
        
        model.redo() // To post-add
        #expect(model.nodes.count == initialNodeCount, "Redo applies add")
    }
    @Test func testInitializationWithDefaults() {
        let storage = MockGraphStorage()
        let model = GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        #expect(model.nodes.count >= 3, "Should load default or saved nodes")
        #expect(model.edges.count >= 3, "Should load default edges")
    }
    
    @Test func testSnapshotAndUndo() {
        let storage = MockGraphStorage()
        let model = GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        let initialNodes = model.nodes
        model.snapshot()
        model.addNode(at: CGPoint.zero)
        #expect(model.nodes.count == initialNodes.count + 1, "Node added")
        model.undo()
        let restoredNodes = model.nodes
        let idsMatch = Set(restoredNodes.map { $0.id }) == Set(initialNodes.map { $0.id })
        let labelsMatch = Set(restoredNodes.map { $0.label }) == Set(initialNodes.map { $0.label })
        let positionsMatch = zip(restoredNodes.sorted(by: { $0.id.uuidString < $1.id.uuidString }), initialNodes.sorted(by: { $0.id.uuidString < $1.id.uuidString })).allSatisfy { approximatelyEqual($0.position, $1.position, accuracy: 1e-5) }
        #expect(idsMatch && labelsMatch && positionsMatch, "Undo restores state")
    }
    
    @Test func testDeleteNodeAndEdges() {
        let storage = MockGraphStorage()
        let model = GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        #expect(!model.nodes.isEmpty, "Assumes default nodes exist")
        let nodeID = model.nodes[0].id
        let initialEdgeCount = model.edges.count
        model.deleteNode(withID: nodeID)
        #expect(model.nodes.first { $0.id == nodeID } == nil, "Node deleted")
        #expect(model.edges.count < initialEdgeCount, "Edges reduced")
    }
    
    @Test func testSaveLoadRoundTrip() {
        let storage = MockGraphStorage()
        let model = GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        let originalNodeCount = model.nodes.count
        let originalEdges = model.edges
        // Modify and snapshot to trigger save
        model.addNode(at: CGPoint.zero)
        model.snapshot()
        // New instance to trigger load
        let newModel = GraphModel(storage: storage, physicsEngine: mockPhysicsEngine())
        #expect(newModel.nodes.count == originalNodeCount + 1, "Loaded nodes include added one")
        #expect(newModel.edges == originalEdges, "Edges unchanged")
    }
    
    // New: Basic convergence test with tightened threshold
    // New: Basic convergence test with tightened threshold
    @Test(arguments: 1..<5) func testConvergencePropertyBased(seed: Int) throws {
        let model = GraphModel(storage: MockGraphStorage(), physicsEngine: mockPhysicsEngine())
        srand48(seed)  // Seed random for reproducibility
        //print(model.nodes.map { ($0.label, $0.position) })
        model.nodes = (0..<5).map { _ in
            Node(label: Int(drand48() * 10), position: CGPoint(x: CGFloat(drand48() * 300), y: CGFloat(drand48() * 300)))
        }
        model.edges = (0..<3).map { _ in
            GraphEdge(from: model.nodes[Int(drand48() * 5)].id, to: model.nodes[Int(drand48() * 5)].id)
        }
        
        model.startSimulation()
        // Manual loop for test with substeps
        for _ in 0..<Constants.Physics.maxSimulationSteps {
            var nodes = model.nodes
            var activeAccum = false  // Accumulator declared here (outside inner loop)
            for _ in 0..<20 {  // Increased substeps as suggested
                let (updatedNodes, stepActive) = model.physicsEngine.simulationStep(nodes: nodes, edges: model.edges)
                nodes = updatedNodes
                activeAccum = activeAccum || stepActive  // Update accumulator
                if !stepActive { break }  // Optional: Early break if inactive in a substep
            }
            model.nodes = nodes
            if !activeAccum { break }  // Now uses the accumulator (in scope)
        }
        
        let totalVel = model.nodes.reduce(0.0) { $0 + $1.velocity.magnitude }
        #expect(totalVel < 2.0 * CGFloat(model.nodes.count), "Velocities near zero for seed \(seed)")
    }
    // New/Fixed: Property-based convergence test with tightened threshold and proper parameterization
    @Test func testSimulationConvergence() {
        let tolerance: CGFloat = 0.05
        let model = GraphModel(storage: MockGraphStorage(), physicsEngine: mockPhysicsEngine())
        model.nodes = [
            Node(label: 1, position: CGPoint(x: 100, y: 100), velocity: CGPoint(x: 10, y: 10)),
            Node(label: 2, position: CGPoint(x: 200, y: 200), velocity: CGPoint(x: -10, y: -10))
        ]
        model.edges = [GraphEdge(from: model.nodes[0].id, to: model.nodes[1].id)]
        
        model.startSimulation()
        for _ in 0..<Constants.Physics.maxSimulationSteps {
            var nodes = model.nodes
            var activeAccum = false
            let subSteps = 20  // Increased as suggested
            for _ in 0..<subSteps {
                let edges = model.edges
                let (updatedNodes, stepActive) = model.physicsEngine.simulationStep(nodes: nodes, edges: edges)
                nodes = updatedNodes
                activeAccum = activeAccum || stepActive
                if !stepActive { break }  // Optional early break
            }
            model.nodes = nodes
            if !activeAccum { break }
        }
        
        #expect(model.nodes[0].velocity.magnitude < 1.2 + tolerance, "Node 1 velocity converges to near-zero")
        #expect(model.nodes[1].velocity.magnitude < 1.2 + tolerance, "Node 2 velocity converges to near-zero")
    }
}

struct GestureTests {
    @Test func testDragCreatesEdge() {
        let storage = MockGraphStorage()
        let physicsEngine = GraphEditorShared.PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
        let model = GraphModel(storage: storage, physicsEngine: physicsEngine)
        
        // Setup: Clear default nodes/edges if needed, but since test assumes empty edges after adding, adjust expectations.
        // Note: GraphModel init adds defaults if empty, so to match test intent, we'll clear them here for the test.
        model.nodes = []
        model.edges = []
        model.addNode(at: CGPoint(x: 0, y: 0))
        model.addNode(at: CGPoint(x: 50, y: 50))
        #expect(model.edges.isEmpty, "No edges initially")
        
        let viewModel = GraphViewModel(model: model)
        guard let node1 = model.nodes[0] as? Node else { fatalError("Expected Node") }
        guard let node2 = model.nodes[1] as? Node else { fatalError("Expected Node") }
        
        // Mock gesture properties instead of creating Value
        let mockTranslation = CGSize(width: 50, height: 50)
        
        // Simulate onEnded logic
        let draggedNode: (any NodeProtocol)? = node1
        let potentialEdgeTarget: (any NodeProtocol)? = node2
        let dragOffset: CGPoint = CGPoint(x: mockTranslation.width / 1.0, y: mockTranslation.height / 1.0)  // Assume zoomScale=1
        
        let dragDistance = hypot(mockTranslation.width, mockTranslation.height)
        if let node = draggedNode,
           let index = viewModel.model.nodes.firstIndex(where: { $0.id == node.id }) {
            viewModel.snapshot()
            if dragDistance < AppConstants.tapThreshold {
                // Tap logic (skipped)
            } else {
                // Drag logic
                if let target = potentialEdgeTarget, target.id != node.id {
                    // Break up complex predicate
                    let fromID = node.id
                    let toID = target.id
                    let edgeExists = viewModel.model.edges.contains { edge in
                        (edge.from == fromID && edge.to == toID) ||
                        (edge.from == toID && edge.to == fromID)
                    }
                    if !edgeExists {
                        viewModel.model.edges.append(GraphEdge(from: fromID, to: toID))
                        viewModel.model.startSimulation()
                    } else {
                        // Move logic (skipped, but update to use vars)
                        viewModel.model.nodes[index].position = CGPoint(x: viewModel.model.nodes[index].position.x + dragOffset.x, y: viewModel.model.nodes[index].position.y + dragOffset.y)
                        viewModel.model.startSimulation()
                    }
                }
            }
        }
        
        // Assert: Break up the expectation
        #expect(viewModel.model.edges.count == 1, "Edge created after simulated drag")
        let newEdge = viewModel.model.edges.first
        #expect(newEdge != nil, "New edge exists")
        if let newEdge = newEdge {
            #expect(newEdge.from == node1.id, "Edge from correct node")
            #expect(newEdge.to == node2.id, "Edge to correct node")
        }
    }
}

struct AccessibilityTests {
    private func mockPhysicsEngine() -> GraphEditorShared.PhysicsEngine {
        GraphEditorShared.PhysicsEngine(simulationBounds: CGSize(width: 300, height: 300))
    }
    
    @Test func testGraphDescription() {
        let storage = MockGraphStorage()
        // Preload with dummy to avoid defaults and set nextNodeLabel to 1
        storage.nodes = [Node(label: 0, position: .zero)]
        let model = GraphModel(storage: storage, physicsEngine: mockPhysicsEngine(), nextNodeLabel: 1)
        model.nodes = []  // Clear for test setup
        model.edges = []
        
        model.nextNodeLabel = 1  // Reset for consistent labeling in test
        
        model.addNode(at: .zero)  // Label 1
        model.addNode(at: CGPoint(x: 10, y: 10))  // Label 2
        model.edges.append(GraphEdge(from: model.nodes[0].id, to: model.nodes[1].id))
        
        let descNoSelect = model.graphDescription(selectedID: nil, selectedEdgeID: nil)  // Add param
        #expect(descNoSelect == "Graph with 2 nodes and 1 directed edge. No node or edge selected.", "Correct desc without selection")  // Updated expectation
        
        let descWithSelect = model.graphDescription(selectedID: model.nodes[0].id, selectedEdgeID: nil)  // Add param
        #expect(descWithSelect == "Graph with 2 nodes and 1 directed edge. Node 1 selected, outgoing to: 2; incoming from: none.", "Correct desc with selection")  // Updated expectation
    }
}
--------------------------------------------------
--------------------------------------------------
File: GraphEditorWatchUITests.swift
Path: GraphEditorWatchUITests/GraphEditorWatchUITests.swift
Last modified: 2025-08-09 17:07:24

Contents:
//
//  GraphEditorWatchUITests.swift
//  GraphEditorWatchUITests
//
//  Created by handcart on 8/4/25.
//

import XCTest

final class GraphEditorWatchUITests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.

        // In UI tests it is usually best to stop immediately when a failure occurs.
        continueAfterFailure = false

        // In UI tests it’s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }
    
    func testLaunch() throws {
            let app = XCUIApplication()
            app.launch()
            
            // Basic assertion: Check if the app launches without crashing
            XCTAssertTrue(app.exists, "App should launch successfully")
        }
    
    func testDragToCreateEdge() throws {
        let app = XCUIApplication()
        app.launch()

        let canvas = app.otherElements["GraphCanvas"]  // Assumes accessibilityIdentifier set on GraphCanvasView
        XCTAssertTrue(canvas.waitForExistence(timeout: 5), "Graph canvas should appear")

        // Assume default nodes: Adjust start/end based on positions (e.g., node0 at (100,100), node1 at (200,200))
        let startPoint = CGVector(dx: 0.3, dy: 0.3)  // Near node0
        let endPoint = CGVector(dx: 0.6, dy: 0.6)    // Near node1

        let dragStart = canvas.coordinate(withNormalizedOffset: startPoint)
        let dragEnd = canvas.coordinate(withNormalizedOffset: endPoint)
        dragStart.press(forDuration: 0.1, thenDragTo: dragEnd)

        // Assert: Updated label reflects directed edge (e.g., "Graph with 3 nodes and 4 directed edges." and mentions direction)
        let updatedLabel = app.staticTexts["Graph with 3 nodes and 4 directed edges. No node selected."]  // Adjust based on post-drag (add "directed")
        XCTAssertTrue(updatedLabel.waitForExistence(timeout: 2), "Directed edge created, updating graph description")

        // Optional: Select the from-node and check description mentions "outgoing to" the to-node
        // Simulate tap on startPoint to select, then check label includes "outgoing to: <label>"
    }
    
    func testUndoAfterAddNode() throws {
            let app = XCUIApplication()
            app.launch()
            
            let canvas = app.otherElements["GraphCanvas"]  // Assume identifier set
            XCTAssertTrue(canvas.waitForExistence(timeout: 5))
            
            // Simulate add node: Assume menu button "Add Node" exists
            app.buttons["Show Menu"].tap()  // Or long press if using gestures
            app.buttons["Add Node"].tap()
            
            // Assert: Graph description updates (e.g., nodes increase)
            let updatedLabel = app.staticTexts["Graph with 4 nodes"]  // Adjust based on defaults +1
            XCTAssertTrue(updatedLabel.waitForExistence(timeout: 2), "Node added")
            
            // Undo via button
            app.buttons["Undo"].tap()  // Assume undo button in menu or UI
            let revertedLabel = app.staticTexts["Graph with 3 nodes"]  // Back to defaults
            XCTAssertTrue(revertedLabel.waitForExistence(timeout: 2), "Undo reverts add")
        }
        
        func testMenuDisplayAndAction() throws {
            let app = XCUIApplication()
            app.launch()
            
            let canvas = app.otherElements["GraphCanvas"]
            XCTAssertTrue(canvas.waitForExistence(timeout: 5))
            
            // Long press to show menu (if using sheet)
            canvas.coordinate(withNormalizedOffset: CGVector(dx: 0.5, dy: 0.5)).press(forDuration: 1.0)
            
            // Assert menu appears with buttons
            let addButton = app.buttons["Add Node"]
            XCTAssertTrue(addButton.waitForExistence(timeout: 2), "Menu shows with actions")
            
            addButton.tap()
            // Assert action effect (e.g., via label)
            let updatedLabel = app.staticTexts["Graph with 4 nodes"]
            XCTAssertTrue(updatedLabel.waitForExistence(timeout: 2), "Menu action adds node")
        }
    
    // New: Test for digital crown zooming (using proxy button; manual test crown in simulator)
    func testDigitalCrownZooming() throws {
        let app = XCUIApplication()
        app.launch()
        
        let canvas = app.otherElements["GraphCanvas"]  // Assume identifier set
        XCTAssertTrue(canvas.waitForExistence(timeout: 5))
        
        // Simulate crown via menu button (add "Zoom In" to menu if not present)
        app.buttons["Show Menu"].tap()
        app.buttons["Zoom In"].tap()  // Proxy for crown rotation; adjust if button named differently
        
        // Assert: Check if description or visible elements change (e.g., more details visible)
        let zoomedLabel = app.staticTexts["Graph with 3 nodes"]  // Adjust to match post-zoom (e.g., if zoom reveals more)
        XCTAssertTrue(zoomedLabel.waitForExistence(timeout: 2), "Zoom updates view")
    }
    
    
    @MainActor
    func testExample() throws {
        // UI tests must launch the application that they test.
        let app = XCUIApplication()
        app.launch()

        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    @MainActor
    func testLaunchPerformance() throws {
        // This measures how long it takes to launch your application.
        measure(metrics: [XCTApplicationLaunchMetric()]) {
            XCUIApplication().launch()
        }
    }
}
--------------------------------------------------
--------------------------------------------------
File: GraphEditorWatchUITestsLaunchTests.swift
Path: GraphEditorWatchUITests/GraphEditorWatchUITestsLaunchTests.swift
Last modified: 2025-08-04 15:45:24

Contents:
//
//  GraphEditorWatchUITestsLaunchTests.swift
//  GraphEditorWatchUITests
//
//  Created by handcart on 8/4/25.
//

import XCTest

final class GraphEditorWatchUITestsLaunchTests: XCTestCase {

    override class var runsForEachTargetApplicationUIConfiguration: Bool {
        true
    }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    @MainActor
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        // Insert steps here to perform after app launch but before taking a screenshot,
        // such as logging into a test account or navigating somewhere in the app

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = "Launch Screen"
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}
--------------------------------------------------
